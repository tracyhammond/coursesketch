package coursesketch.database;

import com.mongodb.MongoClient;
import com.mongodb.client.FindIterable;
import com.mongodb.client.MongoCollection;
import com.mongodb.client.MongoDatabase;
import coursesketch.database.auth.AuthenticationChecker;
import coursesketch.database.auth.AuthenticationException;
import coursesketch.database.auth.AuthenticationResponder;
import coursesketch.database.interfaces.AbstractCourseSketchDatabaseReader;
import coursesketch.database.util.DatabaseAccessException;
import coursesketch.database.util.DatabaseStringConstants;
import coursesketch.server.interfaces.ServerInfo;
import org.bson.Document;
import org.bson.types.ObjectId;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import protobuf.srl.grading.Rubric;
import protobuf.srl.services.authentication.Authentication;
import protobuf.srl.submission.Submission;
import protobuf.srl.utils.Util;

import static coursesketch.database.util.DatabaseStringConstants.REGISTRATION_KEY;
import static coursesketch.database.util.DatabaseStringConstants.SELF_ID;

/**
 * Holds information for the answer checker server.
 */
public class AnswerCheckerDatabase extends AbstractCourseSketchDatabaseReader implements RubricDataHandler {

    /**
     * Declaration and Definition of Logger.
     */
    private static final Logger LOG = LoggerFactory.getLogger(AnswerCheckerDatabase.class);

    /**
     * Mongo database.
     */
    private MongoDatabase database;
    /**
     * Used for authentication.
     */
    private final AuthenticationChecker auth;

    /**
     * Takes in a list of addressees where the database can be found and a name of the database.
     *
     * @param serverInfo Information about the server.
     * @param auth Used for authentication of users.
     */
    public AnswerCheckerDatabase(final ServerInfo serverInfo, final AuthenticationChecker auth) {
        super(serverInfo);
        this.auth = auth;
    }

    @Override
    protected final void setUpIndexes() {
        // Does nothing
    }

    @Override
    protected final void onStartDatabase() throws DatabaseAccessException {
        final MongoClient mongoClient = new MongoClient(super.getServerInfo().getDatabaseUrl());
        database = mongoClient.getDatabase(super.getServerInfo().getDatabaseName());
        super.setDatabaseStarted();
    }

    /**
     * Generates a key for the solution so the answer checker can grab the solution later.
     *
     * @param authId The id of the person inserting the solution.
     * @param solution The solution.
     * @return A key that was generated by the user.
     * @throws DatabaseAccessException If There are database problems.
     * @throws AuthenticationException If the user does not have permission.
     */
    public final String generateKey(final String authId, final Submission.SrlSolution solution)
            throws DatabaseAccessException, AuthenticationException {

        final MongoCollection<Document> collection = database.getCollection(DatabaseStringConstants.SOLUTION_COLLECTION);
        final FindIterable<Document> documents = collection.find(new Document(SELF_ID, new ObjectId(solution.getProblemBankId())));
        if (documents.iterator().hasNext()) {
            // We can just quit early since the work has already been done.
            return null;
        }

        final AuthenticationResponder authenticationResponder = new AuthenticationResponder(
                auth.isAuthenticated(Util.ItemType.BANK_PROBLEM, solution.getProblemBankId(), authId,
                        Authentication.AuthType.newBuilder()
                                .setCheckingOwner(true)
                                .setCheckingAdmin(true)
                                .build()));
        if (!authenticationResponder.hasTeacherPermission()) {
            throw new AuthenticationException("User does not have permission to create key", AuthenticationException.INVALID_PERMISSION);
        }

        final ObjectId key = new ObjectId();

        collection.insertOne(new Document(SELF_ID, new ObjectId(solution.getProblemBankId())).append(REGISTRATION_KEY, key));

        return key.toString();
        // do stuff
    }

    /**
     * Generates a key for the solution so the answer checker can grab the solution later.
     *
     * @param authId The id of the person getting the key.
     * @param studentExperiment The student experiment.
     * @return A key that was generated by the user.
     * @throws AuthenticationException If the user or experiment does not have permission.
     * @throws DatabaseAccessException If There are database problems.
     */
    public final String getKey(final String authId, final Submission.SrlExperiment studentExperiment)
            throws AuthenticationException, DatabaseAccessException {

        final Authentication.AuthResponse authenticated = auth
                .isAuthenticated(Util.ItemType.COURSE_PROBLEM, studentExperiment.getProblemId(), authId, Authentication.AuthType
                        .newBuilder().setCheckAccess(true).setCheckingUser(true).build());

        if (!new AuthenticationResponder(authenticated).hasStudentPermission()) {
            throw new AuthenticationException("User can not get this submission graded", AuthenticationException.INVALID_PERMISSION);
        }

        final AuthenticationResponder bankProblemResponder =
                new AuthenticationResponder(
                        auth.isAuthenticated(Util.ItemType.BANK_PROBLEM, studentExperiment.getProblemBankId(),
                                studentExperiment.getCourseId(),
                                Authentication.AuthType.newBuilder().setCheckingUser(true).build()));
        if (!bankProblemResponder.hasStudentPermission()) {
            throw new AuthenticationException("User does not have permission to create key", AuthenticationException.INVALID_PERMISSION);
        }

        final MongoCollection<Document> collection = database.getCollection(DatabaseStringConstants.SOLUTION_COLLECTION);
        final Document first = collection.find(new Document(SELF_ID, new ObjectId(studentExperiment.getProblemBankId()))).first();

        return first.get(REGISTRATION_KEY).toString();
    }

    /**
     * Loads a rubric from the database.
     *
     * @param rubricId The id of where the rubric lives.
     * @return The rubric data
     */
    public final Rubric.GradingRubric.Builder loadRubric(Util.DomainId rubricId) {
        LOG.info("Loading Rubric with id {}", rubricId);
        return Rubric.GradingRubric.newBuilder();
    }
}
