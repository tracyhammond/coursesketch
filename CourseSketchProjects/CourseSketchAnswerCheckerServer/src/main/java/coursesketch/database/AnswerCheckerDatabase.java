package coursesketch.database;

import com.mongodb.MongoClient;
import com.mongodb.client.FindIterable;
import com.mongodb.client.MongoCollection;
import com.mongodb.client.MongoDatabase;
import coursesketch.database.auth.AuthenticationException;
import coursesketch.database.auth.AuthenticationResponder;
import coursesketch.database.auth.Authenticator;
import coursesketch.database.interfaces.AbstractCourseSketchDatabaseReader;
import coursesketch.database.util.DatabaseAccessException;
import coursesketch.database.util.DatabaseStringConstants;
import coursesketch.server.interfaces.ServerInfo;
import org.bson.Document;
import org.bson.types.ObjectId;
import protobuf.srl.services.authentication.Authentication;
import protobuf.srl.submission.Submission;
import protobuf.srl.utils.Util;

import static coursesketch.database.util.DatabaseStringConstants.REGISTRATION_KEY;
import static coursesketch.database.util.DatabaseStringConstants.SELF_ID;

/**
 * Holds information for the answer checker server.
 */
public class AnswerCheckerDatabase extends AbstractCourseSketchDatabaseReader {
    /**
     * Mongo database.
     */
    private MongoDatabase database;
    /**
     * Used for authentication.
     */
    private final Authenticator auth;

    /**
     * Takes in a list of addressees where the database can be found and a name of the database.
     *
     * @param serverInfo Information about the server.
     * @param auth Used for authentication of users.
     */
    public AnswerCheckerDatabase(final ServerInfo serverInfo, final Authenticator auth) {
        super(serverInfo);
        this.auth = auth;
    }

    @Override
    protected final void setUpIndexes() {
        // Does nothing
    }

    @Override
    protected final void onStartDatabase() throws DatabaseAccessException {
        final MongoClient mongoClient = new MongoClient(super.getServerInfo().getDatabaseUrl());
        database = mongoClient.getDatabase(super.getServerInfo().getDatabaseName());
        super.setDatabaseStarted();
    }

    /**
     * Generates a key for the solution so the answer checker can grab the solution later.
     *
     * @param authId The id of the person inserting the solution.
     * @param solution The solution.
     * @return A key that was generated by the user.
     * @throws DatabaseAccessException If There are database problems.
     * @throws AuthenticationException If the user does not have permission.
     */
    public final String generateKey(final String authId, final Submission.SrlSolution solution)
            throws DatabaseAccessException, AuthenticationException {

        final MongoCollection<Document> collection = database.getCollection(DatabaseStringConstants.SOLUTION_COLLECTION);
        final FindIterable<Document> documents = collection.find(new Document(SELF_ID, new ObjectId(solution.getProblemBankId())));
        if (documents.iterator().hasNext()) {
            // We can just quit early since the work has already been done.
            return null;
        }

        final AuthenticationResponder authenticationResponder =
                auth.checkAuthentication(Util.ItemType.BANK_PROBLEM, solution.getProblemBankId(), authId,
                        0,
                        Authentication.AuthType.newBuilder()
                                .setCheckingOwner(true)
                                .setCheckingAdmin(true)
                                .build());
        if (!authenticationResponder.hasTeacherPermission()) {
            throw new AuthenticationException("User does not have permission to create key", AuthenticationException.INVALID_PERMISSION);
        }

        final ObjectId key = new ObjectId();

        collection.insertOne(new Document(SELF_ID, new ObjectId(solution.getProblemBankId())).append(REGISTRATION_KEY, key));

        return key.toString();
        // do stuff
    }

    /**
     * Generates a key for the solution so the answer checker can grab the solution later.
     *
     * @param authId The id of the person getting the key.
     * @param studentExperiment The student experiment.
     * @return A key that was generated by the user.
     * @throws AuthenticationException If the user or experiment does not have permission.
     */
    public final String getKey(final String authId, final Submission.SrlExperiment studentExperiment) throws AuthenticationException {

        // Checks user has permission to problem
        final AuthenticationResponder courseProblemResponder =
                auth.checkAuthentication(Util.ItemType.COURSE_PROBLEM, studentExperiment.getProblemId(),
                        authId, 0,
                        Authentication.AuthType.newBuilder().setCheckingUser(true).build());
        if (!courseProblemResponder.hasStudentPermission()) {
            throw new AuthenticationException("User does not have permission to create key", AuthenticationException.INVALID_PERMISSION);
        }

        final AuthenticationResponder bankProblemResponder = auth.checkAuthentication(Util.ItemType.BANK_PROBLEM, studentExperiment.getProblemId(),
                studentExperiment.getCourseId(), 0,
                Authentication.AuthType.newBuilder().setCheckingUser(true).build());
        if (!bankProblemResponder.hasStudentPermission()) {
            throw new AuthenticationException("User does not have permission to create key", AuthenticationException.INVALID_PERMISSION);
        }

        final MongoCollection<Document> collection = database.getCollection(DatabaseStringConstants.SOLUTION_COLLECTION);
        final Document first = collection.find(new Document(SELF_ID, new ObjectId(studentExperiment.getProblemBankId()))).first();

        return first.get(REGISTRATION_KEY).toString();
    }
}
