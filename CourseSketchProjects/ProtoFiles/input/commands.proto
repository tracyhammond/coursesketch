package protobuf.srl.commands;
/* https://developers.google.com/protocol-buffers/docs/proto#oneof */

message SrlUpdateList {
	repeated SrlUpdate list = 1;
}

message SrlUpdate {
	required string updateId = 1;
	optional int64 time = 2;
	repeated SrlCommand commands = 3;
	optional int32 commandNumber = 4; // this is only mainly used in a SYNC Command
}

// inheritance does not exist so this will replace shape
message SrlCommand {
	required CommandType commandType = 1;
	required bool isUserCreated = 2;
	optional bytes commandData = 3;
	optional string commandId = 4;
}

/**
 * These are attempted to be ordered by the most common occurrence
 * but are grouped by what make sense.
 *
 * Changing the value of a command will invalidate all current checksums and cause a version issue with stored updateList
 */
enum CommandType {
	ADD_STROKE = 0;		// Adds a Stroke:		This will only contain an SRL_Stroke in commandData
	ADD_SHAPE = 1;		// Adds a shape:		This will only contain an SRL_Shape in commandData
	PACKAGE_SHAPE = 2;	// Repackages shapes from the surface to inside another shape
	REMOVE_OBJECT = 3;	// Removes an object:	This will only contain an IdChain in commandData.
	ASSIGN_ATTRIBUTE = 4;
	REMOVE_ATTRIBUTE = 5;
	MARKER = 6; //marker has a number and a MARKERTYPE
	FORCE_INTERPRETATION = 10;

	// Stack Commands, They do not have any other data associated with it.
	UNDO = 11; // "pop" one command and Undo its effect.
	REDO = 12; // Redo one command and Redo its effect.
	REWRITE = 13; // Forces all commands in the list that are past the current state to be removed.
	CLEAR_STACK = 14; // Clears the stack.
	OPEN_SYNC = 15; // Tells this machine that it will recieve a list of Updates and to execute them and compare order
	CLOSE_SYNC = 16; // Tells the machine that it is going back to normal mode.
}

/**
 * A sub message that contains a list of Ids.
 * The first Id will be at the level of the sketch, all further ids are subshapes of that shape.
 */
message IdChain {
	repeated string idChain = 1;
}

/**
 * Contains an id and a MarkerType.
 *
 * Marks can have special purposes.  For example quick look through for the progress of the sketch (like when reviewing)
 */
message Marker {
	required MarkerType type = 1;
	enum MarkerType {
		SUBMISSION = 0; // notes that the sketch was submitted at this point.
		FEEDBACK = 1; // notes that the user recieved answer checking feedback at this point.
		SAVE = 2; // notes that the sketch was saved at this point.
		// when an undo / redo branch occurs this is the marker that signifies the split.
		// additionally some special care needs to be done to check when saving the sketch that splits do not corrupt existing sketch data.
		SPLIT = 3;
		CLEAR = 4; // To be supported later
	}
	optional string otherData = 2;
}

/**
 * This tells us to do 2 things
 * #1 add all shapes with an id in the list of {@link shapesToBeContained} into shape with an id of {@link newContainerId}
 * #2 delete all the shapes with the id in the list of from the sketch
 *
 * If the Id chain does not exist then we assume it is talking about the top most level, which is the sketch object itself.
 */
message ActionPackageShape {
	optional IdChain oldContainerId = 1;
	optional IdChain newContainerId = 2;
	repeated string shapesToBeContained = 3; // This is a list of shapes ids
}

/**
 * Gives the shape with the current Id a new interpretation
 */
message ActionForceInterpretation {
	required bytes interpretation = 1;
	required IdChain shapeId = 2;
}

/**
 * Assigns an attribute to a shape.
 */
message ActionAddAttribtue {
	required IdChain shapeId = 1;
	required string attributeKey = 2;
	required bytes attributeValue = 3;
}

/**
 * Removes an attribute from a shape.
 *
 * the value that is removed is stored here.
 * A ReplaceAttribute is a combination of a RemoveAttribtue and then an AddAttribtue
 */
message ActionRemoveAttribtue {
	required IdChain shapeId = 1;
	required string attributeKey = 2;
	required bytes attributeValue = 3;
}