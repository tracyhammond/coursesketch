<html>
<head>
<meta charset="utf-8">
<title>Command Methods test</title>
<!-- test Library -->
<link rel="import" href="/test/testUtilities/testUtilities.html">

<!-- files needed for testing -->
<link rel="import" href="/src/utilities/connection/protobufInclude.html">
<link rel="import" href="/src/sketching/srl/srlLibraryInclude.html">
<script src="/src/sketching/sketchSurfaceManager.js"></script>
<script src="/src/sketching/storage/commandMethods.js"></script>

<!-- file being tested. -->
<script src="/src/sketching/storage/updatemanager.js" data-cover></script>
</head>
<body>
	<div id="qunit"></div>
	<div id="qunit-fixture"></div>

    <script>
        // COPY PASTA FOR TESTING TAKEN FROM DEFAULT_SKETCH_COMMANDS.js
        /**
         * Do nothing
         *
         * @returns {boolean} true.  because if we switch sketch we should probably do something about it.
         */
        CourseSketch.prutil.getSrlCommandClass().addRedoMethod(CourseSketch.prutil.CommandType.CREATE_SKETCH, function() {
            return true;
        });

        /**
         * Do nothing
         *
         * @returns {boolean} true.  because if we switch sketch we should probably do something about it.
         */
        CourseSketch.prutil.getSrlCommandClass().addRedoMethod(CourseSketch.prutil.CommandType.SWITCH_SKETCH, function() {
            return true;
        });

        /**
         * Do nothing
         *
         * @returns {boolean} true.  because if we switch sketch we should probably do something about it.
         */
        CourseSketch.prutil.getSrlCommandClass().addUndoMethod(CourseSketch.prutil.CommandType.CREATE_SKETCH, function() {
            return true;
        });

        /**
         * Do nothing
         *
         * @returns {boolean} true.  because if we switch sketch we should probably do something about it.
         */
        CourseSketch.prutil.getSrlCommandClass().addUndoMethod(CourseSketch.prutil.CommandType.SWITCH_SKETCH, function() {
            return true;
        });
    </script>
	<script>
        var MinListNumber = 10;
        QUnit.config.testTimeout = 5000;
        QUnit.module("creation");
        QUnit.test("creation of manager works", function(assert) {
            var update = new UpdateManager(undefined, undefined);
            assert.ok("no exceptions were thrown :)");
        });
    </script>
	<script>
        QUnit.module("misc Functions", {
            sketch : {
                resetSketch : function() {
                }
            }
        });
        QUnit.test("createMarker returns correct value", function(assert) {
            var update = new UpdateManager(undefined, undefined);
            var otherData = "data";
            var markerObject = update.createMarker(true, CourseSketch.prutil.getMarkerClass().MarkerType.SAVE, otherData);
            assert.ok(markerObject instanceof CourseSketch.prutil.getSrlCommandClass(), "testing that command is an object of the correct protobuf type");
            assert.equal(markerObject.isUserCreated, true, "testing input for userCreated matches");
            assert.equal(markerObject.getCommandType(), CourseSketch.prutil.CommandType.MARKER, "testing input for commandType matches");
            assert.notEqual(markerObject.getCommandId(), null, "testing that the command Id is not null");

            var markerData = CourseSketch.prutil.decodeProtobuf(markerObject.getCommandData(), CourseSketch.prutil.getMarkerClass());
            assert.equal(markerData.type, CourseSketch.prutil.getMarkerClass().MarkerType.SAVE);
            assert.equal(markerData.otherData, otherData);
        });

        QUnit.asyncTest("get Clean list returns the same list but different objects", function(assert) {
            var updateList = new UpdateManager(undefined, function(error) {
                assert.ok(false, error);
                QUnit.start();
            });
            CourseSketch.prutil.getSrlCommandClass().addRedoMethod(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE, function() {
                return false;
            });
            CourseSketch.prutil.getSrlCommandClass().addUndoMethod(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE, function() {
                return false;
            });
            for (var i = 0; i < MinListNumber; i++) {
                var SAVEObject = updateList.createMarker(true, CourseSketch.prutil.getMarkerClass().MarkerType.SAVE, "SAVE the sketch!");
                var SAVEUpdate = CourseSketch.prutil.createUpdateFromCommands([ SAVEObject ]);
                updateList.addUpdate(SAVEUpdate);

                var markerObject = updateList.createMarker(true, CourseSketch.prutil.getMarkerClass().MarkerType.SUBMISSION, "pounded you to submission");
                var update = CourseSketch.prutil.createUpdateFromCommands([ markerObject ]);
                updateList.addUpdate(update);

                var assignAt = CourseSketch.prutil.createBaseCommand(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE, true);
                var assignUpdate = CourseSketch.prutil.createUpdateFromCommands([ assignAt ]);
                updateList.addUpdate(assignUpdate);
            }

            var listCallback = undefined;
            var listOne = updateList.getUpdateList(function(listThree) {
                listCallback = listThree;
                // do nothing it is fine;
            });
            assert.updateListEqual(listCallback, listOne);
            restoreRealTime();

            updateList.getCleanUpdateList(function(list) {
                assert.equal(listOne.length, list.length, "list size should be the same");
                for (var i = 0; i < listOne.length; i++) {
                    assert.notEqual(listOne[i], list[i]);
                    assert.updateEqual(listOne[i], list[i]);
                }
                QUnit.start();
            });
            CourseSketch.prutil.getSrlCommandClass().removeRedoMethod(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE);
            CourseSketch.prutil.getSrlCommandClass().removeUndoMethod(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE);
        });

        QUnit.test("setUpdateList creates the updates in the correct order", function(assert) {
            var clock = sinon.useFakeTimers();
            var localSketch = this.sketch;
            var updateList = new UpdateManager({
                    getCurrentSketch: function() {
                        return localSketch;
                    }
                }, function(error) {
                assert.ok(false, error);
            });

            var localUpdateList = new Array();
            for (var i = 0; i < MinListNumber; i++) {
                var SAVEObject = updateList.createMarker(true, CourseSketch.prutil.getMarkerClass().MarkerType.SAVE, "SAVE the sketch!");
                var SAVEUpdate = CourseSketch.prutil.createUpdateFromCommands([ SAVEObject ]);
                localUpdateList.push(SAVEUpdate);

                var markerObject = updateList.createMarker(true, CourseSketch.prutil.getMarkerClass().MarkerType.SUBMISSION, "pounded you to submission");
                var update = CourseSketch.prutil.createUpdateFromCommands([ markerObject ]);
                localUpdateList.push(update);

                var assignAt = CourseSketch.prutil.createBaseCommand(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE, true);
                var assignUpdate = CourseSketch.prutil.createUpdateFromCommands([ assignAt ]);
                localUpdateList.push(assignUpdate);
            }

            CourseSketch.prutil.getSrlCommandClass().addRedoMethod(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE, function() {
            });
            CourseSketch.prutil.getSrlCommandClass().addUndoMethod(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE, function() {
            });

            updateList.setUpdateList(localUpdateList);
            for (var i = 0; i < MinListNumber * 3; i++) {
                clock.tick(20);
            }

            CourseSketch.prutil.getSrlCommandClass().removeRedoMethod(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE);
            CourseSketch.prutil.getSrlCommandClass().removeUndoMethod(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE);
            var listCallback = undefined;
            var listOne = updateList.getUpdateList();
            assert.updateListEqual(listOne, localUpdateList);
            restoreRealTime();
        });

        QUnit.test("setUpdateList calls with the correct values", function(assert) {
            var clock = sinon.useFakeTimers();
            var localSketch = this.sketch;
            var updateList = new UpdateManager({
                    getCurrentSketch: function() {
                        return localSketch;
                    }
                }, function(error) {
                assert.ok(false, error);
            });

            var localUpdateList = new Array();
            for (var i = 0; i < MinListNumber; i++) {
                var SAVEObject = updateList.createMarker(true, CourseSketch.prutil.getMarkerClass().MarkerType.SAVE, "SAVE the sketch!");
                var SAVEUpdate = CourseSketch.prutil.createUpdateFromCommands([ SAVEObject ]);
                localUpdateList.push(SAVEUpdate);

                var markerObject = updateList.createMarker(true, CourseSketch.prutil.getMarkerClass().MarkerType.SUBMISSION, "pounded you to submission");
                var update = CourseSketch.prutil.createUpdateFromCommands([ markerObject ]);
                localUpdateList.push(update);

                var assignAt = CourseSketch.prutil.createBaseCommand(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE, true);
                var assignUpdate = CourseSketch.prutil.createUpdateFromCommands([ assignAt ]);
                localUpdateList.push(assignUpdate);
            }

            CourseSketch.prutil.getSrlCommandClass().addRedoMethod(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE, function() {
            });
            CourseSketch.prutil.getSrlCommandClass().addUndoMethod(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE, function() {
            });

            var percent = this.spy();
            var finished = this.spy();
            var bar = {
                isRunning : function() {
                    return true;
                },
                updatePercentBar : percent,
                finishWaiting : finished
            };
            updateList.setUpdateList(localUpdateList, bar);
            var total = MinListNumber * 3;
            for (var i = 0; i < total; i++) {
                clock.tick(20);
                assert.ok(percent.calledWith(i, total));
            }
            assert.ok(percent.calledWith(1, 1));
            CourseSketch.prutil.getSrlCommandClass().removeRedoMethod(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE);
            CourseSketch.prutil.getSrlCommandClass().removeUndoMethod(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE);

            assert.ok(finished.calledOnce, "the percent bar finishes");
        });
    </script>
	<script>
        QUnit.module("submission tests", {
            sketch : {
                resetSketch : function() {
                }
            },
        });
        QUnit.asyncTest("testing adding an update Marker.SUBMISSION And test the last update is submission", function(assert) {
            var updateList = new UpdateManager(undefined, function(error) {
                assert.ok(false, error);
                QUnit.start();
            });

            assert.equal(updateList.isLastUpdateSubmission(), false, "there are no submissions before the marker submission is added");

            var markerObject = updateList.createMarker(true, CourseSketch.prutil.getMarkerClass().MarkerType.SUBMISSION, "pounded you to submission");
            var update = CourseSketch.prutil.createUpdateFromCommands([ markerObject ]);
            updateList.addUpdate(update);

            assert.equal(updateList.isLastUpdateSubmission(), true, "afer marker is added the submission is the last update");
            QUnit.start();
        });

        QUnit.test("testing isValidForSubmission with empty list", function(assert) {
            var updateList = new UpdateManager(undefined, function(error) {
                assert.ok(false, error);
                QUnit.start();
            });
            assert.equal(updateList.isValidForSubmission(), false, "empty list are not valid for submissions");
        });

        QUnit.asyncTest("testing isValidForSubmission with last item being a submission marker", function(assert) {

            var updateList = new UpdateManager(undefined, function(error) {
                assert.ok(false, error);
                QUnit.start();
            });

            var markerObject = updateList.createMarker(true, CourseSketch.prutil.getMarkerClass().MarkerType.SUBMISSION, "pounded you to submission");
            var update = CourseSketch.prutil.createUpdateFromCommands([ markerObject ]);
            updateList.addUpdate(update);

            assert.equal(updateList.isValidForSubmission(), false, "afer marker is added the submission is the last update");
            QUnit.start();
        });

        QUnit.asyncTest("testing isValidForSubmission with last item being a submission marker", function(assert) {

            var updateList = new UpdateManager(undefined, function(error) {
                assert.ok(false, error);
                QUnit.start();
            });

            var markerObject = updateList.createMarker(true, CourseSketch.prutil.getMarkerClass().MarkerType.SAVE, "pounded you to saving");
            var update = CourseSketch.prutil.createUpdateFromCommands([ markerObject ]);
            updateList.addUpdate(update);

            assert.equal(updateList.isValidForSubmission(), true, "afer marker is added the save is the last update");
            QUnit.start();
        });
    </script>
	<script>
        QUnit.module("addUpdateTest", {
            sketch : {
                resetSketch : function() {
                },
                id: "SketchId!"
            },
            sketchManager : {
                getCurrentSketch : function() {
                    return this.sketch;
                },
                deleteSketch : function() {
                },
                createSketch : function() {
                }
            },
        });

        QUnit.test("testing adding an empty update should throw an exception", function(assert) {

            var updateList = new UpdateManager(undefined, function(error) {
                assert.ok(error instanceof UpdateException, error);
            });

            var update = CourseSketch.prutil.createUpdateFromCommands([]);
            updateList.addUpdate(update);
        });

        QUnit.test("testing adding an update ASSIGN_ATTRIBUTE (return false)", function(assert) {

            var stub = this.stub();
            stub.returns(false); // we are not drawing.

            CourseSketch.prutil.getSrlCommandClass().addRedoMethod(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE, stub);
            var updateList = new UpdateManager(undefined, function(error) {
                assert.ok(false, error);
            });
            var markerObject = CourseSketch.prutil.createBaseCommand(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE, true);
            var update = CourseSketch.prutil.createUpdateFromCommands([ markerObject ]);
            updateList.addUpdate(update);
            assert.ok(stub.calledOnce, "spy is called once");
            CourseSketch.prutil.getSrlCommandClass().removeRedoMethod(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE);
        });

        QUnit.test("testing adding an update Marker.SUBMISSION after adding SAVE And test the last update is submission", function(assert) {

            var updateList = new UpdateManager(undefined, function(error) {
                assert.ok(false, error);
            });

            assert.equal(updateList.isLastUpdateSubmission(), false, "there are no submissions before the marker submission is added");

            var SAVEObject = updateList.createMarker(true, CourseSketch.prutil.getMarkerClass().MarkerType.SAVE, "SAVE the sketch!");
            var update = CourseSketch.prutil.createUpdateFromCommands([ SAVEObject ]);
            updateList.addUpdate(update);

            assert.equal(updateList.isLastUpdateSubmission(), false, "there are no submissions before the marker submission is added");

            var markerObject = updateList.createMarker(true, CourseSketch.prutil.getMarkerClass().MarkerType.SUBMISSION, "pounded you to submission");
            var update = CourseSketch.prutil.createUpdateFromCommands([ markerObject ]);
            updateList.addUpdate(update);

            assert.equal(updateList.isLastUpdateSubmission(), true, "afer marker is added the submission is the last update");
        });

        QUnit.test("testing adding a Create sketch command", function(assert) {

            var clock = sinon.useFakeTimers();

            var localSketch = this.sketch;
            this.sketchManager = new SketchSurfaceManager();
            var updateList = new UpdateManager(this.sketchManager, function(error) {
                console.log(error);
                assert.ok(false, error);
            });

            var spy = this.spy(this.sketchManager, "createSketch");
            var stub = this.stub(this.sketchManager, "getSketch");

            var secondSketch = {
            };

            stub.returns(secondSketch);

            var command = CourseSketch.prutil.createBaseCommand(CourseSketch.prutil.CommandType.CREATE_SKETCH, false);
            var sketchData = CourseSketch.prutil.ActionCreateSketch();
            var idChain = CourseSketch.prutil.IdChain();
            var id = generateUUID();
            idChain.idChain = [ id ];
            console.log(id);
            sketchData.sketchId = idChain;
            command.setCommandData(sketchData.toArrayBuffer());
            var update = CourseSketch.prutil.createUpdateFromCommands([ command ]);
            updateList.addUpdate(update);

            clock.tick(20);

            assert.ok(spy.calledWith(id) && spy.calledOnce);
            assert.ok(stub.calledWith(id) && stub.calledOnce);
        });

        QUnit.test("testing adding a switch sketch command", function(assert) {

            var clock = sinon.useFakeTimers();

            this.sketchManager = new SketchSurfaceManager();
            var updateList = new UpdateManager(this.sketchManager, function(error) {
                assert.ok(false, error);
            }, this.sketchManager);

            var stub = this.stub(this.sketchManager, "getSketch");

            var secondSketch = {
            };

            stub.returns(secondSketch);

            var command = CourseSketch.prutil.createBaseCommand(CourseSketch.prutil.CommandType.SWITCH_SKETCH, false);
            var idChain = CourseSketch.prutil.IdChain();
            var id = generateUUID();
            idChain.idChain = [ id ];
            command.setCommandData(idChain.toArrayBuffer());
            var update = CourseSketch.prutil.createUpdateFromCommands([ command ]);
            updateList.addUpdate(update);

            clock.tick(20);

            assert.ok(stub.calledWith(id) && stub.calledOnce);
        });

        QUnit.test("testing adding a switch sketch command undefined manager", function(assert) {

            var clock = sinon.useFakeTimers();

            var updateList = new UpdateManager(undefined, function(error) {
                assert.ok(error instanceof UpdateException, error);
            });

            var command = CourseSketch.prutil.createBaseCommand(CourseSketch.prutil.CommandType.SWITCH_SKETCH, false);
            var idChain = CourseSketch.prutil.IdChain();
            var id = generateUUID();
            idChain.idChain = [ id ];
            command.setCommandData(idChain.toArrayBuffer());
            var update = CourseSketch.prutil.createUpdateFromCommands([ command ]);
            updateList.addUpdate(update);
        });
    </script>

	<script>
        QUnit.module("CLEAR data tests", {
            sketch : {
                resetSketch : function() {
                }
            },
            sketchManager : new SketchSurfaceManager()
        }); // basically a bunch of test about wether or not it is resetable.
        QUnit.asyncTest("tests that the list is empty, and the submission pointer and current pointer is changed.", function(assert) {

            var updateList = new UpdateManager(this.sketchManager, function(error) {
                assert.ok(false, error);
                QUnit.start();
            });


            var localSketch = this.sketch;
            this.sketchManager.getCurrentSketch = function() { return localSketch };

            var saveObject = updateList.createMarker(true, CourseSketch.prutil.getMarkerClass().MarkerType.SAVE, "Save the sketch!");
            var saveUpdate = CourseSketch.prutil.createUpdateFromCommands([ saveObject ]);
            updateList.addUpdate(saveUpdate);

            var markerObject = updateList.createMarker(true, CourseSketch.prutil.getMarkerClass().MarkerType.SUBMISSION, "pounded you to submission");
            var update = CourseSketch.prutil.createUpdateFromCommands([ markerObject ]);
            updateList.addUpdate(update);

            var list = updateList.getUpdateList();
            assert.updateEqual(list[0], saveUpdate, "first object added was a SAVE object");
            assert.updateEqual(list[1], update, "second object added was a submission object");

            assert.equal(updateList.isLastUpdateSubmission(), true, "afer marker is added the submission is the last update");
            assert.equal(updateList.getCurrentPointer(), 2, "there are two items in the list and the pointer should be 2");

            updateList.clearUpdates(false);

            assert.equal(updateList.isLastUpdateSubmission(), false, "afer Clear there should not be a last update submission");
            assert.equal(updateList.getCurrentPointer(), 0, "afer SAVE the pointer should be 0");
            assert.deepEqual(updateList.getUpdateList(), [], "afer SAVE there should be an empty list");
            QUnit.start();
        });
    </script>
	<script>
        QUnit.module("undo and redo tests", {
            sketch : {
                resetSketch : function() {
                }
            },
            sketchManager : new SketchSurfaceManager()
        });
        QUnit.asyncTest("trying to redo when you can't redo throws an error", function(assert) {

            var updateList = new UpdateManager(undefined, function(error) {
                assert.ok(error instanceof UndoRedoException, error);
                QUnit.start();
            });

            var markerObject = CourseSketch.prutil.createBaseCommand(CourseSketch.prutil.CommandType.REDO, false);
            var update = CourseSketch.prutil.createUpdateFromCommands([ markerObject ]);
            updateList.addUpdate(update);
        });

        QUnit.asyncTest("single undo throws error when list is empty", function(assert) {

            var updateList = new UpdateManager(undefined, function(error) {
                assert.ok(error instanceof UndoRedoException, error);
                QUnit.start();

            });

            var undoMarkerObject = CourseSketch.prutil.createBaseCommand(CourseSketch.prutil.CommandType.UNDO, false);
            var undoUpdate = CourseSketch.prutil.createUpdateFromCommands([ undoMarkerObject ]);
            updateList.addUpdate(undoUpdate);
        });

        QUnit.asyncTest("you can undo a marker (maybe it just skips over it?)", function(assert) {

            var updateList = new UpdateManager(this.sketchManager, function(error) {
                console.log(error);
                assert.ok(false, error);
                QUnit.start();
            });

            var localSketch = this.sketch;
            this.sketchManager.getCurrentSketch = function() { return localSketch };

            var submissionObject = updateList.createMarker(true, CourseSketch.prutil.getMarkerClass().MarkerType.SUBMISSION, "pounded you to submission");
            var subUpdate = CourseSketch.prutil.createUpdateFromCommands([ submissionObject ]);
            updateList.addUpdate(subUpdate);

            assert.equal(updateList.getCurrentPointer(), 1, "a single item means pointer is at 1");

            var markerObject = CourseSketch.prutil.createBaseCommand(CourseSketch.prutil.CommandType.UNDO, false);
            var update = CourseSketch.prutil.createUpdateFromCommands([ markerObject ]);
            updateList.addUpdate(update);

            assert.equal(updateList.getCurrentPointer(), 0, "after undoing once the pointer should be at zero");
            QUnit.start();
        });

        QUnit.asyncTest("a single undo", function(assert) {

            var updateList = new UpdateManager(undefined, function(error) {
                assert.ok(false, error);
                QUnit.start();
            });

            var stub = this.stub();
            stub.returns(false); // we are not drawing.
            CourseSketch.prutil.getSrlCommandClass().addRedoMethod(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE, function() {
            });
            CourseSketch.prutil.getSrlCommandClass().addUndoMethod(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE, stub);
            var assignAt = CourseSketch.prutil.createBaseCommand(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE, true);
            var assignUpdate = CourseSketch.prutil.createUpdateFromCommands([ assignAt ]);
            updateList.addUpdate(assignUpdate);

            assert.equal(updateList.getCurrentPointer(), 1, "a single item means pointer is at 1");

            var markerObject = CourseSketch.prutil.createBaseCommand(CourseSketch.prutil.CommandType.UNDO, false);
            var update = CourseSketch.prutil.createUpdateFromCommands([ markerObject ]);
            updateList.addUpdate(update);

            assert.equal(updateList.getCurrentPointer(), 0, "after undoing once the pointer should be at zero");
            assert.ok(stub.calledOnce, "Undo method for the assign should be called once");

            CourseSketch.prutil.getSrlCommandClass().removeRedoMethod(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE);
            CourseSketch.prutil.getSrlCommandClass().removeUndoMethod(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE);
            QUnit.start();
        });

        QUnit.asyncTest("double undo throws error", function(assert) {
            expect(1);

            var updateList = new UpdateManager(this.sketchManager, function(error) {
                assert.ok(error instanceof UndoRedoException, error);
                QUnit.start();
            });

            CourseSketch.prutil.getSrlCommandClass().addRedoMethod(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE, function() {
            });
            CourseSketch.prutil.getSrlCommandClass().addUndoMethod(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE, function() {
            });
            var assignAt = CourseSketch.prutil.createBaseCommand(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE, true);
            var assignUpdate = CourseSketch.prutil.createUpdateFromCommands([ assignAt ]);
            updateList.addUpdate(assignUpdate);

            var markerObject = CourseSketch.prutil.createBaseCommand(CourseSketch.prutil.CommandType.UNDO, false);
            var update = CourseSketch.prutil.createUpdateFromCommands([ markerObject ]);
            updateList.addUpdate(update);

            var undoMarkerObject = CourseSketch.prutil.createBaseCommand(CourseSketch.prutil.CommandType.UNDO, false);
            var undoUpdate = CourseSketch.prutil.createUpdateFromCommands([ undoMarkerObject ]);
            updateList.addUpdate(undoUpdate);

            CourseSketch.prutil.getSrlCommandClass().removeRedoMethod(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE);
            CourseSketch.prutil.getSrlCommandClass().removeUndoMethod(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE);
        });

        QUnit.asyncTest("a single undo then redo", function(assert) {

            var updateList = new UpdateManager(this.sketchManager, function(error) {
                assert.ok(false, error);
                QUnit.start();
            });

            var undoStub = this.stub();
            undoStub.returns(false); // we are not drawing.

            var redoStub = this.stub();
            redoStub.returns(false); // we are not drawing.
            CourseSketch.prutil.getSrlCommandClass().addRedoMethod(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE, redoStub);
            CourseSketch.prutil.getSrlCommandClass().addUndoMethod(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE, undoStub);
            var assignAt = CourseSketch.prutil.createBaseCommand(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE, true);
            var assignUpdate = CourseSketch.prutil.createUpdateFromCommands([ assignAt ]);
            updateList.addUpdate(assignUpdate);

            assert.equal(updateList.getCurrentPointer(), 1, "a single item means pointer is at 1");
            assert.ok(redoStub.calledOnce, "Redo should be called once");

            var undoMarkerObject = CourseSketch.prutil.createBaseCommand(CourseSketch.prutil.CommandType.UNDO, false);
            var undoUpdate = CourseSketch.prutil.createUpdateFromCommands([ undoMarkerObject ]);
            updateList.addUpdate(undoUpdate);

            assert.equal(updateList.getCurrentPointer(), 0, "after undoing once the pointer should be at zero");
            assert.ok(undoStub.calledOnce, "Undo method for the assign should be called once");

            var undoMarkerObject = CourseSketch.prutil.createBaseCommand(CourseSketch.prutil.CommandType.REDO, false);
            var undoUpdate = CourseSketch.prutil.createUpdateFromCommands([ undoMarkerObject ]);
            updateList.addUpdate(undoUpdate);

            assert.equal(updateList.getCurrentPointer(), 1, "after undoing once the pointer should be at zero");
            assert.ok(redoStub.calledTwice, "redo method for the assign should be called a second time");

            CourseSketch.prutil.getSrlCommandClass().removeRedoMethod(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE);
            CourseSketch.prutil.getSrlCommandClass().removeUndoMethod(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE);
            QUnit.start();
        });

        QUnit.asyncTest("a single undo then redo using udoAction and redoAction methods", function(assert) {

            var updateList = new UpdateManager(undefined, function(error) {
                assert.ok(false, error);
                QUnit.start();
            });

            var undoStub = this.stub();
            undoStub.returns(false); // we are not drawing.

            var redoStub = this.stub();
            redoStub.returns(false); // we are not drawing.
            CourseSketch.prutil.getSrlCommandClass().addRedoMethod(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE, redoStub);
            CourseSketch.prutil.getSrlCommandClass().addUndoMethod(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE, undoStub);
            var assignAt = CourseSketch.prutil.createBaseCommand(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE, true);
            var assignUpdate = CourseSketch.prutil.createUpdateFromCommands([ assignAt ]);
            updateList.addUpdate(assignUpdate);

            assert.equal(updateList.getCurrentPointer(), 1, "a single item means pointer is at 1");
            assert.ok(redoStub.calledOnce, "Redo should be called once");

            updateList.undoAction(false);

            assert.equal(updateList.getCurrentPointer(), 0, "after undoing once the pointer should be at zero");
            assert.ok(undoStub.calledOnce, "Undo method for the assign should be called once");

            updateList.redoAction(false);

            assert.equal(updateList.getCurrentPointer(), 1, "after undoing once the pointer should be at zero");
            assert.ok(redoStub.calledTwice, "redo method for the assign should be called a second time");

            CourseSketch.prutil.getSrlCommandClass().removeRedoMethod(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE);
            CourseSketch.prutil.getSrlCommandClass().removeUndoMethod(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE);
            QUnit.start();
        });

        QUnit.asyncTest("a undo/redo causing a split", function(assert) {

            var updateList = new UpdateManager(undefined, function(error) {
                assert.ok(false, error);
                QUnit.start();
            });

            var undoStub = this.stub();
            undoStub.returns(false); // we are not drawing.

            var redoStub = this.stub();
            redoStub.returns(false); // we are not drawing.
            CourseSketch.prutil.getSrlCommandClass().addRedoMethod(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE, redoStub);
            CourseSketch.prutil.getSrlCommandClass().addUndoMethod(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE, undoStub);
            var assignAt = CourseSketch.prutil.createBaseCommand(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE, true);
            var assignUpdate = CourseSketch.prutil.createUpdateFromCommands([ assignAt ]);
            updateList.addUpdate(assignUpdate);

            updateList.undoAction(false);

            updateList.redoAction(false);

            var assignAt = CourseSketch.prutil.createBaseCommand(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE, true);
            var assignUpdate = CourseSketch.prutil.createUpdateFromCommands([ assignAt ]);
            updateList.addUpdate(assignUpdate);

            CourseSketch.prutil.getSrlCommandClass().removeRedoMethod(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE);
            CourseSketch.prutil.getSrlCommandClass().removeUndoMethod(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE);

            var updateList = updateList.getUpdateList();
            console.log(updateList);
            assert.equal(6, updateList.length);
            assert.equal(updateList[0].commands[0].commandType, CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE);
            assert.equal(updateList[1].commands[0].commandType, CourseSketch.prutil.CommandType.MARKER);
            assert.equal(updateList[2].commands[0].commandType, CourseSketch.prutil.CommandType.UNDO);
            assert.equal(updateList[3].commands[0].commandType, CourseSketch.prutil.CommandType.REDO);
            assert.equal(updateList[4].commands[0].commandType, CourseSketch.prutil.CommandType.MARKER);
            assert.equal(updateList[5].commands[0].commandType, CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE);
            QUnit.start();
        });

        QUnit.test("adding a Create sketch command then calling undo on it", function(assert) {

            var clock = sinon.useFakeTimers();

            var updateList = new UpdateManager(this.sketchManager, function(error) {
                assert.ok(false, error);
            });

            var spy = this.spy(this.sketchManager, "createSketch");
            var stub1 = this.stub(this.sketchManager, "getSketch");
            var stub2 = this.stub(this.sketchManager, "deleteSketch");
            var stub3 = this.stub(this.sketchManager, "getCurrentSketch");

            var secondSketch = {
            };

            stub1.returns(secondSketch);
            stub3.returns(secondSketch);

            var command = CourseSketch.prutil.createBaseCommand(CourseSketch.prutil.CommandType.CREATE_SKETCH, false);
            var sketchData = CourseSketch.prutil.ActionCreateSketch();
            var idChain = CourseSketch.prutil.IdChain();
            var id1 = generateUUID();
            idChain.idChain = [ id1 ];
            sketchData.sketchId = idChain;
            command.setCommandData(sketchData.toArrayBuffer());
            var update = CourseSketch.prutil.createUpdateFromCommands([ command ]);
            updateList.addUpdate(update);

            var command = CourseSketch.prutil.createBaseCommand(CourseSketch.prutil.CommandType.CREATE_SKETCH, false);
            var sketchData = CourseSketch.prutil.ActionCreateSketch();
            var idChain = CourseSketch.prutil.IdChain();
            var id = generateUUID();
            idChain.idChain = [ id ];
            sketchData.sketchId = idChain;
            command.setCommandData(sketchData.toArrayBuffer());
            var update = CourseSketch.prutil.createUpdateFromCommands([ command ]);
            updateList.addUpdate(update);

            clock.tick(10);

            assert.ok(spy.calledWith(id) && spy.calledTwice);
            assert.ok(stub1.calledWith(id) && stub1.calledTwice);

            updateList.undoAction(true);
            clock.tick(10);

            assert.ok(stub1.calledWith(id1) && stub1.calledThrice, "get sketch should be called 3 times");
            assert.ok(stub2.calledWith(id) && stub2.calledOnce, "delete should only happen once");
        });

        QUnit.test("undoing first create sketch throws an exception", function(assert) {

            var clock = sinon.useFakeTimers();

            var updateList = new UpdateManager(this.sketchManager, function(error) {
                assert.ok(error instanceof UpdateException, "Successfully threw: " + error);
            });

            var spy = this.spy(this.sketchManager, "createSketch");
            var stub1 = this.stub(this.sketchManager, "getSketch");
            var stub2 = this.stub(this.sketchManager, "deleteSketch");

            var secondSketch = {
            };

            stub1.returns(secondSketch);

            var command = CourseSketch.prutil.createBaseCommand(CourseSketch.prutil.CommandType.CREATE_SKETCH, false);
            var sketchData = CourseSketch.prutil.ActionCreateSketch();
            var idChain = CourseSketch.prutil.IdChain();
            var id = generateUUID();
            idChain.idChain = [ id ];
            sketchData.sketchId = idChain;
            command.setCommandData(sketchData.toArrayBuffer());
            var update = CourseSketch.prutil.createUpdateFromCommands([ command ]);
            updateList.addUpdate(update);

            clock.tick(10);

            updateList.undoAction(true);
            clock.tick(10);
        });

        QUnit.test("adding a swtich sketch and then undoing that creation", function(assert) {

            var clock = sinon.useFakeTimers();

            var updateList = new UpdateManager(this.sketchManager, function(error) {
                assert.ok(false, error);
            }, this.sketchManager);

            var stub = this.stub(this.sketchManager, "getSketch");
            var stub2 = this.stub(this.sketchManager, "getCurrentSketch");

            var secondSketch = {
            };

            stub.returns(secondSketch);
            stub2.returns(secondSketch);

            // assuming this works!
            var command = CourseSketch.prutil.createBaseCommand(CourseSketch.prutil.CommandType.CREATE_SKETCH, false);
            var sketchData = CourseSketch.prutil.ActionCreateSketch();
            var idChain = CourseSketch.prutil.IdChain();
            var id = generateUUID();
            idChain.idChain = [ id ];
            sketchData.sketchId = idChain;
            command.setCommandData(sketchData.toArrayBuffer());
            var update = CourseSketch.prutil.createUpdateFromCommands([ command ]);
            updateList.addUpdate(update);

            clock.tick(10);

            // TEST CODE HERE
            var command = CourseSketch.prutil.createBaseCommand(CourseSketch.prutil.CommandType.SWITCH_SKETCH, false);
            var idChain = CourseSketch.prutil.IdChain();
            var id2 = generateUUID();
            idChain.idChain = [ id2 ];
            command.setCommandData(idChain.toArrayBuffer());
            var update = CourseSketch.prutil.createUpdateFromCommands([ command ]);
            updateList.addUpdate(update);

            clock.tick(10);

            // first call is from create sketch
            assert.ok(stub.calledWith(id2), "get sketch should be called with: " + id2);
            assert.ok(stub.calledTwice, "get sketch should be called twice, once for create another for switch");

            updateList.undoAction(false);
            clock.tick(10);

            assert.ok(stub.calledWith(id), "get sketch should also be called with: " + id);
            assert.ok(stub.calledThrice, "get sketch should be called a third time after undoing");
        });

        QUnit.test("undo switch sketch throws exception no previous sketch exist", function(assert) {

            var clock = sinon.useFakeTimers();

            var updateList = new UpdateManager(this.sketchManager, function(error) {
                assert.ok(error instanceof UpdateException, "Successfully threw: " + error);
            });

            var stub = this.stub(this.sketchManager, "getSketch");

            var secondSketch = {
            };

            stub.returns(secondSketch);

            var command = CourseSketch.prutil.createBaseCommand(CourseSketch.prutil.CommandType.SWITCH_SKETCH, false);
            var idChain = CourseSketch.prutil.IdChain();
            var id = generateUUID();
            idChain.idChain = [ id ];
            command.setCommandData(idChain.toArrayBuffer());
            var update = CourseSketch.prutil.createUpdateFromCommands([ command ]);
            updateList.addUpdate(update);

            clock.tick(10);

            updateList.undoAction(false);
            clock.tick(10);
        });
    </script>
	<script>
        QUnit.module("SPLIT tests", {
            sketch : {
                resetSketch : function() {
                }
            },
            sketchManager : new SketchSurfaceManager()
        });
        QUnit.asyncTest("a single split", function(assert) {

            var updateList = new UpdateManager(this.sketch, function(error) {
                assert.ok(false, error);
                QUnit.start();
            });

            var startSplitObject = updateList.createMarker(true, CourseSketch.prutil.getMarkerClass().MarkerType.SPLIT, "1");
            var startSplitUpdate = CourseSketch.prutil.createUpdateFromCommands([ startSplitObject ]);
            updateList.addUpdate(startSplitUpdate);

            var undoStub = this.stub();
            undoStub.returns(false); // we are not drawing.

            var redoStub = this.stub();
            redoStub.returns(false); // we are not drawing.
            CourseSketch.prutil.getSrlCommandClass().addRedoMethod(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE, redoStub);
            CourseSketch.prutil.getSrlCommandClass().addUndoMethod(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE, undoStub);
            var assignAt = CourseSketch.prutil.createBaseCommand(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE, true);
            var assignUpdate = CourseSketch.prutil.createUpdateFromCommands([ assignAt ]);
            updateList.addUpdate(assignUpdate);

            var endSplitObject = updateList.createMarker(true, CourseSketch.prutil.getMarkerClass().MarkerType.SPLIT, "-1");
            var endSplitUpdate = CourseSketch.prutil.createUpdateFromCommands([ endSplitObject ]);
            updateList.addUpdate(endSplitUpdate);

            sinon.assert.notCalled(redoStub);
            sinon.assert.notCalled(undoStub);
            CourseSketch.prutil.getSrlCommandClass().removeRedoMethod(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE);
            CourseSketch.prutil.getSrlCommandClass().removeUndoMethod(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE);
            QUnit.start();
        });

        QUnit.module("Complex tests", {
            sketch : {
                resetSketch : function() {
                }
            },
        });

        QUnit.asyncTest("a single split then an undo then a redo", function(assert) {

            var updateList = new UpdateManager(this.sketchManager, function(error) {
                assert.ok(false, error);
                QUnit.start();
            });

            var startSplitObject = updateList.createMarker(true, CourseSketch.prutil.getMarkerClass().MarkerType.SPLIT, "1");
            var startSplitUpdate = CourseSketch.prutil.createUpdateFromCommands([ startSplitObject ]);
            updateList.addUpdate(startSplitUpdate);

            var undoStub = this.stub();
            undoStub.returns(false); // we are not drawing.

            var redoStub = this.stub();
            redoStub.returns(false); // we are not drawing.
            CourseSketch.prutil.getSrlCommandClass().addRedoMethod(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE, redoStub);
            CourseSketch.prutil.getSrlCommandClass().addUndoMethod(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE, undoStub);
            var assignAt = CourseSketch.prutil.createBaseCommand(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE, true);
            var assignUpdate = CourseSketch.prutil.createUpdateFromCommands([ assignAt ]);
            updateList.addUpdate(assignUpdate);

            var endSplitObject = updateList.createMarker(true, CourseSketch.prutil.getMarkerClass().MarkerType.SPLIT, "-1");
            var endSplitUpdate = CourseSketch.prutil.createUpdateFromCommands([ endSplitObject ]);
            updateList.addUpdate(endSplitUpdate);

            var undoMarkerObject = CourseSketch.prutil.createBaseCommand(CourseSketch.prutil.CommandType.UNDO, false);
            var undoUpdate = CourseSketch.prutil.createUpdateFromCommands([ undoMarkerObject ]);
            updateList.addUpdate(undoUpdate);

            assert.equal(updateList.getCurrentPointer(), 0);

            var redoMarkerObject = CourseSketch.prutil.createBaseCommand(CourseSketch.prutil.CommandType.REDO, false);
            var redoUpdate = CourseSketch.prutil.createUpdateFromCommands([ redoMarkerObject ]);
            updateList.addUpdate(redoUpdate);

            assert.equal(updateList.getCurrentPointer(), updateList.getListLength() - 2);

            sinon.assert.notCalled(redoStub);
            sinon.assert.notCalled(undoStub);
            CourseSketch.prutil.getSrlCommandClass().removeRedoMethod(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE);
            CourseSketch.prutil.getSrlCommandClass().removeUndoMethod(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE);
            QUnit.start();
        });
    </script>

    <script>
        QUnit.module("plugin tests", {
            sketch : {
                resetSketch : function() {
                },
                id: "SketchId!"
            },
            sketchManager : {
                getCurrentSketch : function() {
                    return this.sketch;
                },
                deleteSketch : function() {
                },
                createSketch : function() {
                }
            },
        });

        QUnit.test("plugin gets correct data for simple update", function(assert) {
            expect(5);
            var clock = sinon.useFakeTimers();
            var stub = this.stub();
            stub.returns(false); // we are not drawing.

            CourseSketch.prutil.getSrlCommandClass().addRedoMethod(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE, stub);
            var updateList = new UpdateManager(undefined, function(error) {
                assert.ok(false, error);
            });

            var markerObject = CourseSketch.prutil.createBaseCommand(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE, true);
            var update = CourseSketch.prutil.createUpdateFromCommands([ markerObject ]);

            // actual test
            updateList.addPlugin({
                addUpdate : function(pluginUpdate, redraw, updateIndex, lastUpdateType) {
                    assert.updateEqual(pluginUpdate, update);
                    assert.equal(redraw, false);
                    assert.equal(updateIndex, 1);
                    assert.equal(lastUpdateType, 0);
                }
            });

            updateList.addSynchronousUpdate(update);

            // only used for plugins not for update itself
            clock.tick(10);
            assert.ok(stub.calledOnce, "spy is called once");
            CourseSketch.prutil.getSrlCommandClass().removeRedoMethod(CourseSketch.prutil.CommandType.ASSIGN_ATTRIBUTE);
        });
    </script>
</body>
