<html>
<head>
<meta charset="utf-8">
<title>Command Methods test</title>
<!-- test Library -->
<link rel="import" href="/test/testUtilities/testUtilities.html">

<!-- files needed for testing -->
<link rel="import" href="/src/utilities/includes/protobufInclude.html">
<script src="/src/sketching/storage/commandMethods.js"></script>

<!-- file being tested. -->
<script src="/src/sketching/storage/updatemanager.js" data-cover></script>
</head>
<body>
	<div id="qunit"></div>
	<div id="qunit-fixture"></div>

	<script>
        var MinListNumber = 10;
        QUnit.config.testTimeout = 5000;
        QUnit.module("creation");
        QUnit.test("creation of manager works", function(assert) {
            var update = new UpdateManager(undefined, undefined);
            assert.ok("no exceptions were thrown :)");
        });
    </script>
	<script>
        QUnit.module("misc Functions", {
            sketch : {
                resetSketch : function() {
                },
                drawEntireSketch : function() {
                },
            }
        });
        QUnit.test("createMarker returns correct value", function(assert) {
            var update = new UpdateManager(undefined, undefined);
            var otherData = "data";
            var markerObject = update.createMarker(true, PROTOBUF_UTIL.getMarkerClass().MarkerType.SAVE, otherData);
            assert.ok(markerObject instanceof PROTOBUF_UTIL.getSrlCommandClass(), "testing that command is an object of the correct protobuf type");
            assert.equal(markerObject.isUserCreated, true, "testing input for userCreated matches");
            assert.equal(markerObject.getCommandType(), PROTOBUF_UTIL.CommandType.MARKER, "testing input for commandType matches");
            assert.notEqual(markerObject.getCommandId(), null, "testing that the command Id is not null");

            var markerData = PROTOBUF_UTIL.decodeProtobuf(markerObject.getCommandData(), PROTOBUF_UTIL.getMarkerClass());
            assert.equal(markerData.type, PROTOBUF_UTIL.getMarkerClass().MarkerType.SAVE);
            assert.equal(markerData.otherData, otherData);
        });

        QUnit.asyncTest("get Clean list returns the same list but different objects", function(assert) {
            var updateList = new UpdateManager(this.sketch, function(error) {
                assert.ok(false, error);
                QUnit.start();
            });
            PROTOBUF_UTIL.getSrlCommandClass().addRedoMethod(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE, function() {
            });
            PROTOBUF_UTIL.getSrlCommandClass().addUndoMethod(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE, function() {
            });
            for (var i = 0; i < MinListNumber; i++) {
                var SAVEObject = updateList.createMarker(true, PROTOBUF_UTIL.getMarkerClass().MarkerType.SAVE, "SAVE the sketch!");
                var SAVEUpdate = PROTOBUF_UTIL.createUpdateFromCommands([ SAVEObject ]);
                updateList.addUpdate(SAVEUpdate);

                var markerObject = updateList.createMarker(true, PROTOBUF_UTIL.getMarkerClass().MarkerType.SUBMISSION, "pounded you to submission");
                var update = PROTOBUF_UTIL.createUpdateFromCommands([ markerObject ]);
                updateList.addUpdate(update);

                var assignAt = PROTOBUF_UTIL.createBaseCommand(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE, true);
                var assignUpdate = PROTOBUF_UTIL.createUpdateFromCommands([ assignAt ]);
                updateList.addUpdate(assignUpdate);
            }

            var listCallback = undefined;
            var listOne = updateList.getUpdateList(function(listThree) {
                listCallback = listThree;
                // do nothing it is fine;
            });
            assert.deepEqual(listCallback, listOne);
            restoreRealTime();

            updateList.getCleanUpdateList(function(list) {
                assert.equal(listOne.length, list.length, "list size should be the same");
                for (var i = 0; i < listOne.length; i++) {
                    assert.notEqual(listOne[i], list[i]);
                    assert.deepEqual(listOne[i], list[i]);
                }
                QUnit.start();
            });
            PROTOBUF_UTIL.getSrlCommandClass().removeRedoMethod(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE);
            PROTOBUF_UTIL.getSrlCommandClass().removeUndoMethod(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE);
        });

        QUnit.test("setUpdateList creates the updates in the correct order", function(assert) {
            var clock = sinon.useFakeTimers();
            var updateList = new UpdateManager(this.sketch, function(error) {
                assert.ok(false, error);
            });

            var localUpdateList = new Array();
            for (var i = 0; i < MinListNumber; i++) {
                var SAVEObject = updateList.createMarker(true, PROTOBUF_UTIL.getMarkerClass().MarkerType.SAVE, "SAVE the sketch!");
                var SAVEUpdate = PROTOBUF_UTIL.createUpdateFromCommands([ SAVEObject ]);
                localUpdateList.push(SAVEUpdate);

                var markerObject = updateList.createMarker(true, PROTOBUF_UTIL.getMarkerClass().MarkerType.SUBMISSION, "pounded you to submission");
                var update = PROTOBUF_UTIL.createUpdateFromCommands([ markerObject ]);
                localUpdateList.push(update);

                var assignAt = PROTOBUF_UTIL.createBaseCommand(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE, true);
                var assignUpdate = PROTOBUF_UTIL.createUpdateFromCommands([ assignAt ]);
                localUpdateList.push(assignUpdate);
            }

            PROTOBUF_UTIL.getSrlCommandClass().addRedoMethod(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE, function() {
            });
            PROTOBUF_UTIL.getSrlCommandClass().addUndoMethod(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE, function() {
            });

            updateList.setUpdateList(localUpdateList);
            for (var i = 0; i < MinListNumber * 3; i++) {
                clock.tick(20);
            }

            PROTOBUF_UTIL.getSrlCommandClass().removeRedoMethod(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE);
            PROTOBUF_UTIL.getSrlCommandClass().removeUndoMethod(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE);
            var listCallback = undefined;
            var listOne = updateList.getUpdateList();
            assert.deepEqual(listOne, localUpdateList);

            restoreRealTime();
        });

        QUnit.test("setUpdateList calls with the correct values", function(assert) {
            var clock = sinon.useFakeTimers();
            var updateList = new UpdateManager(this.sketch, function(error) {
                assert.ok(false, error);
            });

            var localUpdateList = new Array();
            for (var i = 0; i < MinListNumber; i++) {
                var SAVEObject = updateList.createMarker(true, PROTOBUF_UTIL.getMarkerClass().MarkerType.SAVE, "SAVE the sketch!");
                var SAVEUpdate = PROTOBUF_UTIL.createUpdateFromCommands([ SAVEObject ]);
                localUpdateList.push(SAVEUpdate);

                var markerObject = updateList.createMarker(true, PROTOBUF_UTIL.getMarkerClass().MarkerType.SUBMISSION, "pounded you to submission");
                var update = PROTOBUF_UTIL.createUpdateFromCommands([ markerObject ]);
                localUpdateList.push(update);

                var assignAt = PROTOBUF_UTIL.createBaseCommand(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE, true);
                var assignUpdate = PROTOBUF_UTIL.createUpdateFromCommands([ assignAt ]);
                localUpdateList.push(assignUpdate);
            }

            PROTOBUF_UTIL.getSrlCommandClass().addRedoMethod(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE, function() {
            });
            PROTOBUF_UTIL.getSrlCommandClass().addUndoMethod(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE, function() {
            });

            var percent = this.spy();
            var finished = this.spy();
            var bar = {
                isRunning : function() {
                    return true;
                },
                updatePercentBar : percent,
                finishWaiting : finished
            };
            updateList.setUpdateList(localUpdateList, bar);
            var total = MinListNumber * 3;
            for (var i = 0; i < total; i++) {
                clock.tick(20);
                assert.ok(percent.calledWith(i, total));
            }
            assert.ok(percent.calledWith(1, 1));
            PROTOBUF_UTIL.getSrlCommandClass().removeRedoMethod(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE);
            PROTOBUF_UTIL.getSrlCommandClass().removeUndoMethod(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE);

            assert.ok(finished.calledOnce, "the percent bar finishes");
        });

        QUnit.test("clear and draw sketch", function(assert) {
            var updateList = new UpdateManager(this.sketch, function(error) {
                assert.ok(false, error);
            });
            var spy1 = this.spy(this.sketch, "resetSketch");
            var spy2 = this.spy(this.sketch, "drawEntireSketch");
            updateList.clearSketch(true);
            assert.ok(spy1.calledOnce);
            assert.ok(spy2.calledOnce);
        });
    </script>
	<script>
        QUnit.module("submission tests", {
            sketch : {
                resetSketch : function() {
                },
                drawEntireSketch : function() {
                }
            },
        });
        QUnit.asyncTest("testing adding an update Marker.SUBMISSION And test the last update is submission", function(assert) {
            var updateList = new UpdateManager(this.sketch, function(error) {
                assert.ok(false, error);
                QUnit.start();
            });

            assert.equal(updateList.isLastUpdateSubmission(), false, "there are no submissions before the marker submission is added");

            var markerObject = updateList.createMarker(true, PROTOBUF_UTIL.getMarkerClass().MarkerType.SUBMISSION, "pounded you to submission");
            var update = PROTOBUF_UTIL.createUpdateFromCommands([ markerObject ]);
            updateList.addUpdate(update);

            assert.equal(updateList.isLastUpdateSubmission(), true, "afer marker is added the submission is the last update");
            QUnit.start();
        });

        QUnit.test("testing isValidForSubmission with empty list", function(assert) {
            var updateList = new UpdateManager(this.sketch, function(error) {
                assert.ok(false, error);
                QUnit.start();
            });
            assert.equal(updateList.isValidForSubmission(), false, "empty list are not valid for submissions");
        });

        QUnit.asyncTest("testing isValidForSubmission with last item being a submission marker", function(assert) {

            var updateList = new UpdateManager(this.sketch, function(error) {
                assert.ok(false, error);
                QUnit.start();
            });

            var markerObject = updateList.createMarker(true, PROTOBUF_UTIL.getMarkerClass().MarkerType.SUBMISSION, "pounded you to submission");
            var update = PROTOBUF_UTIL.createUpdateFromCommands([ markerObject ]);
            updateList.addUpdate(update);

            assert.equal(updateList.isValidForSubmission(), false, "afer marker is added the submission is the last update");
            QUnit.start();
        });

        QUnit.asyncTest("testing isValidForSubmission with last item being a submission marker", function(assert) {

            var updateList = new UpdateManager(this.sketch, function(error) {
                assert.ok(false, error);
                QUnit.start();
            });

            var markerObject = updateList.createMarker(true, PROTOBUF_UTIL.getMarkerClass().MarkerType.SAVE, "pounded you to saving");
            var update = PROTOBUF_UTIL.createUpdateFromCommands([ markerObject ]);
            updateList.addUpdate(update);

            assert.equal(updateList.isValidForSubmission(), true, "afer marker is added the save is the last update");
            QUnit.start();
        });
    </script>
	<script>
        QUnit.module("addUpdateTest", {
            sketch : {
                resetSketch : function() {
                },
                drawEntireSketch : function() {
                }
            },
            sketchManager : {
                getSketch : function() {
                },
                deleteSketch : function() {
                },
                createSketch : function() {
                }
            },
        });

        QUnit.test("testing adding an empty update should throw an exception", function(assert) {

            var updateList = new UpdateManager(this.sketch, function(error) {
                assert.ok(error instanceof UpdateException, error);
            });

            var update = PROTOBUF_UTIL.createUpdateFromCommands([]);
            updateList.addUpdate(update);
        });

        QUnit.test("testing adding an update ASSIGN_ATTRIBUTE (return false)", function(assert) {

            var stub = this.stub();
            stub.returns(false); // we are not drawing.

            PROTOBUF_UTIL.getSrlCommandClass().addRedoMethod(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE, stub);
            var updateList = new UpdateManager(this.sketch, function(error) {
                assert.ok(false, error);
            });
            var markerObject = PROTOBUF_UTIL.createBaseCommand(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE, true);
            var update = PROTOBUF_UTIL.createUpdateFromCommands([ markerObject ]);
            updateList.addUpdate(update);
            assert.ok(stub.calledOnce, "spy is called once");
            PROTOBUF_UTIL.getSrlCommandClass().removeRedoMethod(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE);
        });

        QUnit.test("testing adding an update Marker.SUBMISSION after adding SAVE And test the last update is submission", function(assert) {

            var updateList = new UpdateManager(this.sketch, function(error) {
                assert.ok(false, error);
            });

            assert.equal(updateList.isLastUpdateSubmission(), false, "there are no submissions before the marker submission is added");

            var SAVEObject = updateList.createMarker(true, PROTOBUF_UTIL.getMarkerClass().MarkerType.SAVE, "SAVE the sketch!");
            var update = PROTOBUF_UTIL.createUpdateFromCommands([ SAVEObject ]);
            updateList.addUpdate(update);

            assert.equal(updateList.isLastUpdateSubmission(), false, "there are no submissions before the marker submission is added");

            var markerObject = updateList.createMarker(true, PROTOBUF_UTIL.getMarkerClass().MarkerType.SUBMISSION, "pounded you to submission");
            var update = PROTOBUF_UTIL.createUpdateFromCommands([ markerObject ]);
            updateList.addUpdate(update);

            assert.equal(updateList.isLastUpdateSubmission(), true, "afer marker is added the submission is the last update");
        });

        QUnit.test("testing adding a Create sketch command", function(assert) {

            var clock = sinon.useFakeTimers();

            var updateList = new UpdateManager(this.sketch, function(error) {
                assert.ok(false, error);
            }, this.sketchManager);

            var spy = this.spy(this.sketchManager, "createSketch");
            var stub = this.stub(this.sketchManager, "getSketch");

            var spy2 = this.spy();
            var secondSketch = {
                drawEntireSketch : spy2,
            };

            stub.returns(secondSketch);

            var command = PROTOBUF_UTIL.createBaseCommand(PROTOBUF_UTIL.CommandType.CREATE_SKETCH, false);
            var idChain = PROTOBUF_UTIL.IdChain();
            var id = generateUUID();
            idChain.idChain = [ id ];
            command.setCommandData(idChain.toArrayBuffer());
            var update = PROTOBUF_UTIL.createUpdateFromCommands([ command ]);
            updateList.addUpdate(update);

            clock.tick(20);

            assert.ok(spy.calledWith(id) && spy.calledOnce);
            assert.ok(stub.calledWith(id) && stub.calledOnce);
            assert.ok(spy2.calledOnce);
        });

        QUnit.test("testing adding a switch sketch command", function(assert) {

            var clock = sinon.useFakeTimers();

            var updateList = new UpdateManager(this.sketch, function(error) {
                assert.ok(false, error);
            }, this.sketchManager);

            var stub = this.stub(this.sketchManager, "getSketch");

            var spy2 = this.spy();
            var secondSketch = {
                drawEntireSketch : spy2,
            };

            stub.returns(secondSketch);

            var command = PROTOBUF_UTIL.createBaseCommand(PROTOBUF_UTIL.CommandType.SWITCH_SKETCH, false);
            var idChain = PROTOBUF_UTIL.IdChain();
            var id = generateUUID();
            idChain.idChain = [ id ];
            command.setCommandData(idChain.toArrayBuffer());
            var update = PROTOBUF_UTIL.createUpdateFromCommands([ command ]);
            updateList.addUpdate(update);

            clock.tick(20);

            assert.ok(stub.calledWith(id) && stub.calledOnce);
            assert.ok(spy2.calledOnce);
        });

        QUnit.test("testing adding a switch sketch command undefined manager", function(assert) {

            var clock = sinon.useFakeTimers();

            var updateList = new UpdateManager(this.sketch, function(error) {
                assert.ok(error instanceof UpdateException, error);
            });

            var spy2 = this.spy();
            var secondSketch = {
                drawEntireSketch : spy2,
            };

            var command = PROTOBUF_UTIL.createBaseCommand(PROTOBUF_UTIL.CommandType.SWITCH_SKETCH, false);
            var idChain = PROTOBUF_UTIL.IdChain();
            var id = generateUUID();
            idChain.idChain = [ id ];
            command.setCommandData(idChain.toArrayBuffer());
            var update = PROTOBUF_UTIL.createUpdateFromCommands([ command ]);
            updateList.addUpdate(update);
        });
    </script>

	<script>
        QUnit.module("CLEAR data tests", {
            sketch : {
                resetSketch : function() {
                },
                drawEntireSketch : function() {
                }
            },
        }); // basically a bunch of test about wether or not it is resetable.
        QUnit.asyncTest("tests that the list is empty, and the submission pointer and current pointer is changed.", function(assert) {

            var updateList = new UpdateManager(this.sketch, function(error) {
                assert.ok(false, error);
                QUnit.start();
            });

            var saveObject = updateList.createMarker(true, PROTOBUF_UTIL.getMarkerClass().MarkerType.SAVE, "Save the sketch!");
            var saveUpdate = PROTOBUF_UTIL.createUpdateFromCommands([ saveObject ]);
            updateList.addUpdate(saveUpdate);

            var markerObject = updateList.createMarker(true, PROTOBUF_UTIL.getMarkerClass().MarkerType.SUBMISSION, "pounded you to submission");
            var update = PROTOBUF_UTIL.createUpdateFromCommands([ markerObject ]);
            updateList.addUpdate(update);

            var list = updateList.getUpdateList();
            assert.equal(list[0], saveUpdate, "first object added was a SAVE object");
            assert.equal(list[1], update, "second object added was a submission object");

            assert.equal(updateList.isLastUpdateSubmission(), true, "afer marker is added the submission is the last update");
            assert.equal(updateList.getCurrentPointer(), 2, "there are two items in the list and the pointer should be 2");

            updateList.clearUpdates(false);

            assert.equal(updateList.isLastUpdateSubmission(), false, "afer Clear there should not be a last update submission");
            assert.equal(updateList.getCurrentPointer(), 0, "afer SAVE the pointer should be 0");
            assert.deepEqual(updateList.getUpdateList(), [], "afer SAVE there should be an empty list");
            QUnit.start();
        });
    </script>
	<script>
        QUnit.module("undo and redo tests", {
            sketch : {
                resetSketch : function() {
                },
                drawEntireSketch : function() {
                }
            },
            sketchManager : {
                getSketch : function() {
                },
                deleteSketch : function() {
                },
                createSketch : function() {
                }
            },
        });
        QUnit.asyncTest("trying to redo when you can't redo throws an error", function(assert) {

            var updateList = new UpdateManager(this.sketch, function(error) {
                assert.ok(error instanceof UndoRedoException, error);
                QUnit.start();
            });

            var markerObject = PROTOBUF_UTIL.createBaseCommand(PROTOBUF_UTIL.CommandType.REDO, false);
            var update = PROTOBUF_UTIL.createUpdateFromCommands([ markerObject ]);
            updateList.addUpdate(update);
        });

        QUnit.asyncTest("single undo throws error when list is empty", function(assert) {

            var updateList = new UpdateManager(this.sketch, function(error) {
                assert.ok(error instanceof UndoRedoException, error);
                QUnit.start();

            });

            var undoMarkerObject = PROTOBUF_UTIL.createBaseCommand(PROTOBUF_UTIL.CommandType.UNDO, false);
            var undoUpdate = PROTOBUF_UTIL.createUpdateFromCommands([ undoMarkerObject ]);
            updateList.addUpdate(undoUpdate);
        });

        QUnit.asyncTest("you can undo a marker (maybe it just skips over it?)", function(assert) {

            var updateList = new UpdateManager(this.sketch, function(error) {
                assert.ok(false, error);
                QUnit.start();
            });

            var submissionObject = updateList.createMarker(true, PROTOBUF_UTIL.getMarkerClass().MarkerType.SUBMISSION, "pounded you to submission");
            var subUpdate = PROTOBUF_UTIL.createUpdateFromCommands([ submissionObject ]);
            updateList.addUpdate(subUpdate);

            assert.equal(updateList.getCurrentPointer(), 1, "a single item means pointer is at 1");

            var markerObject = PROTOBUF_UTIL.createBaseCommand(PROTOBUF_UTIL.CommandType.UNDO, false);
            var update = PROTOBUF_UTIL.createUpdateFromCommands([ markerObject ]);
            updateList.addUpdate(update);

            assert.equal(updateList.getCurrentPointer(), 0, "after undoing once the pointer should be at zero");
            QUnit.start();
        });

        QUnit.asyncTest("a single undo", function(assert) {

            var updateList = new UpdateManager(this.sketch, function(error) {
                assert.ok(false, error);
                QUnit.start();
            });

            var stub = this.stub();
            stub.returns(false); // we are not drawing.
            PROTOBUF_UTIL.getSrlCommandClass().addRedoMethod(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE, function() {
            });
            PROTOBUF_UTIL.getSrlCommandClass().addUndoMethod(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE, stub);
            var assignAt = PROTOBUF_UTIL.createBaseCommand(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE, true);
            var assignUpdate = PROTOBUF_UTIL.createUpdateFromCommands([ assignAt ]);
            updateList.addUpdate(assignUpdate);

            assert.equal(updateList.getCurrentPointer(), 1, "a single item means pointer is at 1");

            var markerObject = PROTOBUF_UTIL.createBaseCommand(PROTOBUF_UTIL.CommandType.UNDO, false);
            var update = PROTOBUF_UTIL.createUpdateFromCommands([ markerObject ]);
            updateList.addUpdate(update);

            assert.equal(updateList.getCurrentPointer(), 0, "after undoing once the pointer should be at zero");
            assert.ok(stub.calledOnce, "Undo method for the assign should be called once");

            PROTOBUF_UTIL.getSrlCommandClass().removeRedoMethod(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE);
            PROTOBUF_UTIL.getSrlCommandClass().removeUndoMethod(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE);
            QUnit.start();
        });

        QUnit.asyncTest("double undo throws error", function(assert) {
            expect(1);

            var updateList = new UpdateManager(this.sketch, function(error) {
                assert.ok(error instanceof UndoRedoException, error);
                QUnit.start();

            });

            PROTOBUF_UTIL.getSrlCommandClass().addRedoMethod(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE, function() {
            });
            PROTOBUF_UTIL.getSrlCommandClass().addUndoMethod(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE, function() {
            });
            var assignAt = PROTOBUF_UTIL.createBaseCommand(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE, true);
            var assignUpdate = PROTOBUF_UTIL.createUpdateFromCommands([ assignAt ]);
            updateList.addUpdate(assignUpdate);

            var markerObject = PROTOBUF_UTIL.createBaseCommand(PROTOBUF_UTIL.CommandType.UNDO, false);
            var update = PROTOBUF_UTIL.createUpdateFromCommands([ markerObject ]);
            updateList.addUpdate(update);

            var undoMarkerObject = PROTOBUF_UTIL.createBaseCommand(PROTOBUF_UTIL.CommandType.UNDO, false);
            var undoUpdate = PROTOBUF_UTIL.createUpdateFromCommands([ undoMarkerObject ]);
            updateList.addUpdate(undoUpdate);

            PROTOBUF_UTIL.getSrlCommandClass().removeRedoMethod(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE);
            PROTOBUF_UTIL.getSrlCommandClass().removeUndoMethod(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE);
        });

        QUnit.asyncTest("a single undo then redo", function(assert) {

            var updateList = new UpdateManager(this.sketch, function(error) {
                assert.ok(false, error);
                QUnit.start();
            });

            var undoStub = this.stub();
            undoStub.returns(false); // we are not drawing.

            var redoStub = this.stub();
            redoStub.returns(false); // we are not drawing.
            PROTOBUF_UTIL.getSrlCommandClass().addRedoMethod(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE, redoStub);
            PROTOBUF_UTIL.getSrlCommandClass().addUndoMethod(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE, undoStub);
            var assignAt = PROTOBUF_UTIL.createBaseCommand(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE, true);
            var assignUpdate = PROTOBUF_UTIL.createUpdateFromCommands([ assignAt ]);
            updateList.addUpdate(assignUpdate);

            assert.equal(updateList.getCurrentPointer(), 1, "a single item means pointer is at 1");
            assert.ok(redoStub.calledOnce, "Redo should be called once");

            var undoMarkerObject = PROTOBUF_UTIL.createBaseCommand(PROTOBUF_UTIL.CommandType.UNDO, false);
            var undoUpdate = PROTOBUF_UTIL.createUpdateFromCommands([ undoMarkerObject ]);
            updateList.addUpdate(undoUpdate);

            assert.equal(updateList.getCurrentPointer(), 0, "after undoing once the pointer should be at zero");
            assert.ok(undoStub.calledOnce, "Undo method for the assign should be called once");

            var undoMarkerObject = PROTOBUF_UTIL.createBaseCommand(PROTOBUF_UTIL.CommandType.REDO, false);
            var undoUpdate = PROTOBUF_UTIL.createUpdateFromCommands([ undoMarkerObject ]);
            updateList.addUpdate(undoUpdate);

            assert.equal(updateList.getCurrentPointer(), 1, "after undoing once the pointer should be at zero");
            assert.ok(redoStub.calledTwice, "redo method for the assign should be called a second time");

            PROTOBUF_UTIL.getSrlCommandClass().removeRedoMethod(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE);
            PROTOBUF_UTIL.getSrlCommandClass().removeUndoMethod(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE);
            QUnit.start();
        });

        QUnit.asyncTest("a single undo then redo using udoAction and redoAction methods", function(assert) {

            var updateList = new UpdateManager(this.sketch, function(error) {
                assert.ok(false, error);
                QUnit.start();
            });

            var undoStub = this.stub();
            undoStub.returns(false); // we are not drawing.

            var redoStub = this.stub();
            redoStub.returns(false); // we are not drawing.
            PROTOBUF_UTIL.getSrlCommandClass().addRedoMethod(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE, redoStub);
            PROTOBUF_UTIL.getSrlCommandClass().addUndoMethod(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE, undoStub);
            var assignAt = PROTOBUF_UTIL.createBaseCommand(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE, true);
            var assignUpdate = PROTOBUF_UTIL.createUpdateFromCommands([ assignAt ]);
            updateList.addUpdate(assignUpdate);

            assert.equal(updateList.getCurrentPointer(), 1, "a single item means pointer is at 1");
            assert.ok(redoStub.calledOnce, "Redo should be called once");

            updateList.undoAction(false);

            assert.equal(updateList.getCurrentPointer(), 0, "after undoing once the pointer should be at zero");
            assert.ok(undoStub.calledOnce, "Undo method for the assign should be called once");

            updateList.redoAction(false);

            assert.equal(updateList.getCurrentPointer(), 1, "after undoing once the pointer should be at zero");
            assert.ok(redoStub.calledTwice, "redo method for the assign should be called a second time");

            PROTOBUF_UTIL.getSrlCommandClass().removeRedoMethod(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE);
            PROTOBUF_UTIL.getSrlCommandClass().removeUndoMethod(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE);
            QUnit.start();
        });

        QUnit.asyncTest("a undo/redo causing a split", function(assert) {

            var updateList = new UpdateManager(this.sketch, function(error) {
                assert.ok(false, error);
                QUnit.start();
            });

            var undoStub = this.stub();
            undoStub.returns(false); // we are not drawing.

            var redoStub = this.stub();
            redoStub.returns(false); // we are not drawing.
            PROTOBUF_UTIL.getSrlCommandClass().addRedoMethod(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE, redoStub);
            PROTOBUF_UTIL.getSrlCommandClass().addUndoMethod(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE, undoStub);
            var assignAt = PROTOBUF_UTIL.createBaseCommand(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE, true);
            var assignUpdate = PROTOBUF_UTIL.createUpdateFromCommands([ assignAt ]);
            updateList.addUpdate(assignUpdate);

            updateList.undoAction(false);

            updateList.redoAction(false);

            var assignAt = PROTOBUF_UTIL.createBaseCommand(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE, true);
            var assignUpdate = PROTOBUF_UTIL.createUpdateFromCommands([ assignAt ]);
            updateList.addUpdate(assignUpdate);

            PROTOBUF_UTIL.getSrlCommandClass().removeRedoMethod(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE);
            PROTOBUF_UTIL.getSrlCommandClass().removeUndoMethod(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE);

            var updateList = updateList.getUpdateList();
            console.log(updateList);
            assert.equal(6, updateList.length);
            assert.equal(updateList[0].commands[0].commandType, PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE);
            assert.equal(updateList[1].commands[0].commandType, PROTOBUF_UTIL.CommandType.MARKER);
            assert.equal(updateList[2].commands[0].commandType, PROTOBUF_UTIL.CommandType.UNDO);
            assert.equal(updateList[3].commands[0].commandType, PROTOBUF_UTIL.CommandType.REDO);
            assert.equal(updateList[4].commands[0].commandType, PROTOBUF_UTIL.CommandType.MARKER);
            assert.equal(updateList[5].commands[0].commandType, PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE);
            QUnit.start();
        });

        QUnit.test("adding a Create sketch command then calling undo on it", function(assert) {

            var clock = sinon.useFakeTimers();

            var updateList = new UpdateManager(this.sketch, function(error) {
                assert.ok(false, error);
            }, this.sketchManager);

            var spy = this.spy(this.sketchManager, "createSketch");
            var stub1 = this.stub(this.sketchManager, "getSketch");
            var stub2 = this.stub(this.sketchManager, "deleteSketch");

            var spy2 = this.spy();
            var secondSketch = {
                drawEntireSketch : spy2,
            };

            stub1.returns(secondSketch);

            var command = PROTOBUF_UTIL.createBaseCommand(PROTOBUF_UTIL.CommandType.CREATE_SKETCH, false);
            var idChain = PROTOBUF_UTIL.IdChain();
            var id = generateUUID();
            idChain.idChain = [ id ];
            command.setCommandData(idChain.toArrayBuffer());
            var update = PROTOBUF_UTIL.createUpdateFromCommands([ command ]);
            updateList.addUpdate(update);

            clock.tick(10);

            assert.ok(spy.calledWith(id) && spy.calledOnce);
            assert.ok(stub1.calledWith(id) && stub1.calledOnce);
            assert.ok(spy2.calledOnce);

            updateList.undoAction(true);
            clock.tick(10);

            assert.ok(stub1.calledWith(undefined) && stub1.calledTwice);
            assert.ok(stub2.calledWith(id) && stub2.calledOnce);
            assert.ok(spy2.calledTwice);
        });

        QUnit.test("adding a swtich sketch and then undoing that creation", function(assert) {

            var clock = sinon.useFakeTimers();

            var updateList = new UpdateManager(this.sketch, function(error) {
                assert.ok(false, error);
            }, this.sketchManager);

            var stub = this.stub(this.sketchManager, "getSketch");

            var spy2 = this.spy();
            var secondSketch = {
                drawEntireSketch : spy2,
            };

            stub.returns(secondSketch);

            var command = PROTOBUF_UTIL.createBaseCommand(PROTOBUF_UTIL.CommandType.SWITCH_SKETCH, false);
            var idChain = PROTOBUF_UTIL.IdChain();
            var id = generateUUID();
            idChain.idChain = [ id ];
            command.setCommandData(idChain.toArrayBuffer());
            var update = PROTOBUF_UTIL.createUpdateFromCommands([ command ]);
            updateList.addUpdate(update);

            clock.tick(10);

            assert.ok(stub.calledWith(id) && stub.calledOnce);
            assert.ok(spy2.calledOnce);

            updateList.undoAction(false);
            clock.tick(10);

            assert.ok(stub.calledWith(undefined) && stub.calledTwice);
            assert.ok(spy2.calledTwice);
        });
    </script>
	<script>
        QUnit.module("SPLIT tests", {
            sketch : {
                resetSketch : function() {
                },
                drawEntireSketch : function() {
                }
            },
        });
        QUnit.asyncTest("a single split", function(assert) {

            var updateList = new UpdateManager(this.sketch, function(error) {
                assert.ok(false, error);
                QUnit.start();
            });

            var startSplitObject = updateList.createMarker(true, PROTOBUF_UTIL.getMarkerClass().MarkerType.SPLIT, "1");
            var startSplitUpdate = PROTOBUF_UTIL.createUpdateFromCommands([ startSplitObject ]);
            updateList.addUpdate(startSplitUpdate);

            var undoStub = this.stub();
            undoStub.returns(false); // we are not drawing.

            var redoStub = this.stub();
            redoStub.returns(false); // we are not drawing.
            PROTOBUF_UTIL.getSrlCommandClass().addRedoMethod(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE, redoStub);
            PROTOBUF_UTIL.getSrlCommandClass().addUndoMethod(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE, undoStub);
            var assignAt = PROTOBUF_UTIL.createBaseCommand(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE, true);
            var assignUpdate = PROTOBUF_UTIL.createUpdateFromCommands([ assignAt ]);
            updateList.addUpdate(assignUpdate);

            var endSplitObject = updateList.createMarker(true, PROTOBUF_UTIL.getMarkerClass().MarkerType.SPLIT, "-1");
            var endSplitUpdate = PROTOBUF_UTIL.createUpdateFromCommands([ endSplitObject ]);
            updateList.addUpdate(endSplitUpdate);

            sinon.assert.notCalled(redoStub);
            sinon.assert.notCalled(undoStub);
            PROTOBUF_UTIL.getSrlCommandClass().removeRedoMethod(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE);
            PROTOBUF_UTIL.getSrlCommandClass().removeUndoMethod(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE);
            QUnit.start();
        });

        QUnit.module("Complex tests", {
            sketch : {
                resetSketch : function() {
                },
                drawEntireSketch : function() {
                }
            },
        });

        QUnit.asyncTest("a single split then an undo then a redo", function(assert) {

            var updateList = new UpdateManager(this.sketch, function(error) {
                assert.ok(false, error);
                QUnit.start();
            });

            var startSplitObject = updateList.createMarker(true, PROTOBUF_UTIL.getMarkerClass().MarkerType.SPLIT, "1");
            var startSplitUpdate = PROTOBUF_UTIL.createUpdateFromCommands([ startSplitObject ]);
            updateList.addUpdate(startSplitUpdate);

            var undoStub = this.stub();
            undoStub.returns(false); // we are not drawing.

            var redoStub = this.stub();
            redoStub.returns(false); // we are not drawing.
            PROTOBUF_UTIL.getSrlCommandClass().addRedoMethod(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE, redoStub);
            PROTOBUF_UTIL.getSrlCommandClass().addUndoMethod(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE, undoStub);
            var assignAt = PROTOBUF_UTIL.createBaseCommand(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE, true);
            var assignUpdate = PROTOBUF_UTIL.createUpdateFromCommands([ assignAt ]);
            updateList.addUpdate(assignUpdate);

            var endSplitObject = updateList.createMarker(true, PROTOBUF_UTIL.getMarkerClass().MarkerType.SPLIT, "-1");
            var endSplitUpdate = PROTOBUF_UTIL.createUpdateFromCommands([ endSplitObject ]);
            updateList.addUpdate(endSplitUpdate);

            var undoMarkerObject = PROTOBUF_UTIL.createBaseCommand(PROTOBUF_UTIL.CommandType.UNDO, false);
            var undoUpdate = PROTOBUF_UTIL.createUpdateFromCommands([ undoMarkerObject ]);
            updateList.addUpdate(undoUpdate);

            assert.equal(updateList.getCurrentPointer(), 0);

            var redoMarkerObject = PROTOBUF_UTIL.createBaseCommand(PROTOBUF_UTIL.CommandType.REDO, false);
            var redoUpdate = PROTOBUF_UTIL.createUpdateFromCommands([ redoMarkerObject ]);
            updateList.addUpdate(redoUpdate);

            assert.equal(updateList.getCurrentPointer(), updateList.getListLength() - 2);

            sinon.assert.notCalled(redoStub);
            sinon.assert.notCalled(undoStub);
            PROTOBUF_UTIL.getSrlCommandClass().removeRedoMethod(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE);
            PROTOBUF_UTIL.getSrlCommandClass().removeUndoMethod(PROTOBUF_UTIL.CommandType.ASSIGN_ATTRIBUTE);
            QUnit.start();
        });
    </script>
</body>