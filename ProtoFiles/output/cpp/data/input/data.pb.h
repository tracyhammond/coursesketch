// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: input/data.proto

#ifndef PROTOBUF_input_2fdata_2eproto__INCLUDED
#define PROTOBUF_input_2fdata_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf {
namespace srl {
namespace query {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_input_2fdata_2eproto();
void protobuf_AssignDesc_input_2fdata_2eproto();
void protobuf_ShutdownFile_input_2fdata_2eproto();

class DataRequest;
class ItemRequest;
class DataSend;
class ItemSend;
class DataResult;
class ItemResult;
class AdvanceCourseGradePull;
class AdvanceUserGradePull;
class AdvanceReview;

enum ItemQuery {
  COURSE = 0,
  ASSIGNMENT = 1,
  COURSE_PROBLEM = 2,
  BANK_PROBLEM = 3,
  USERGROUP = 4,
  CLASS_GRADE = 5,
  USER_INFO = 6,
  SOLUTION = 7,
  EXPERIMENT = 8
};
bool ItemQuery_IsValid(int value);
const ItemQuery ItemQuery_MIN = COURSE;
const ItemQuery ItemQuery_MAX = EXPERIMENT;
const int ItemQuery_ARRAYSIZE = ItemQuery_MAX + 1;

const ::google::protobuf::EnumDescriptor* ItemQuery_descriptor();
inline const ::std::string& ItemQuery_Name(ItemQuery value) {
  return ::google::protobuf::internal::NameOfEnum(
    ItemQuery_descriptor(), value);
}
inline bool ItemQuery_Parse(
    const ::std::string& name, ItemQuery* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ItemQuery>(
    ItemQuery_descriptor(), name, value);
}
// ===================================================================

class DataRequest : public ::google::protobuf::Message {
 public:
  DataRequest();
  virtual ~DataRequest();

  DataRequest(const DataRequest& from);

  inline DataRequest& operator=(const DataRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DataRequest& default_instance();

  void Swap(DataRequest* other);

  // implements Message ----------------------------------------------

  DataRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DataRequest& from);
  void MergeFrom(const DataRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string userId = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 1;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  inline void set_allocated_userid(::std::string* userid);

  // required string sessionId = 2;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionIdFieldNumber = 2;
  inline const ::std::string& sessionid() const;
  inline void set_sessionid(const ::std::string& value);
  inline void set_sessionid(const char* value);
  inline void set_sessionid(const char* value, size_t size);
  inline ::std::string* mutable_sessionid();
  inline ::std::string* release_sessionid();
  inline void set_allocated_sessionid(::std::string* sessionid);

  // repeated .protobuf.srl.query.ItemRequest items = 3;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 3;
  inline const ::protobuf::srl::query::ItemRequest& items(int index) const;
  inline ::protobuf::srl::query::ItemRequest* mutable_items(int index);
  inline ::protobuf::srl::query::ItemRequest* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::srl::query::ItemRequest >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::srl::query::ItemRequest >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:protobuf.srl.query.DataRequest)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_sessionid();
  inline void clear_has_sessionid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* userid_;
  ::std::string* sessionid_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::srl::query::ItemRequest > items_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_input_2fdata_2eproto();
  friend void protobuf_AssignDesc_input_2fdata_2eproto();
  friend void protobuf_ShutdownFile_input_2fdata_2eproto();

  void InitAsDefaultInstance();
  static DataRequest* default_instance_;
};
// -------------------------------------------------------------------

class ItemRequest : public ::google::protobuf::Message {
 public:
  ItemRequest();
  virtual ~ItemRequest();

  ItemRequest(const ItemRequest& from);

  inline ItemRequest& operator=(const ItemRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ItemRequest& default_instance();

  void Swap(ItemRequest* other);

  // implements Message ----------------------------------------------

  ItemRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ItemRequest& from);
  void MergeFrom(const ItemRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string itemId = 1;
  inline int itemid_size() const;
  inline void clear_itemid();
  static const int kItemIdFieldNumber = 1;
  inline const ::std::string& itemid(int index) const;
  inline ::std::string* mutable_itemid(int index);
  inline void set_itemid(int index, const ::std::string& value);
  inline void set_itemid(int index, const char* value);
  inline void set_itemid(int index, const char* value, size_t size);
  inline ::std::string* add_itemid();
  inline void add_itemid(const ::std::string& value);
  inline void add_itemid(const char* value);
  inline void add_itemid(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& itemid() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_itemid();

  // optional .protobuf.srl.query.ItemQuery query = 2;
  inline bool has_query() const;
  inline void clear_query();
  static const int kQueryFieldNumber = 2;
  inline ::protobuf::srl::query::ItemQuery query() const;
  inline void set_query(::protobuf::srl::query::ItemQuery value);

  // optional bytes advanceQuery = 3;
  inline bool has_advancequery() const;
  inline void clear_advancequery();
  static const int kAdvanceQueryFieldNumber = 3;
  inline const ::std::string& advancequery() const;
  inline void set_advancequery(const ::std::string& value);
  inline void set_advancequery(const char* value);
  inline void set_advancequery(const void* value, size_t size);
  inline ::std::string* mutable_advancequery();
  inline ::std::string* release_advancequery();
  inline void set_allocated_advancequery(::std::string* advancequery);

  // @@protoc_insertion_point(class_scope:protobuf.srl.query.ItemRequest)
 private:
  inline void set_has_query();
  inline void clear_has_query();
  inline void set_has_advancequery();
  inline void clear_has_advancequery();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> itemid_;
  ::std::string* advancequery_;
  int query_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_input_2fdata_2eproto();
  friend void protobuf_AssignDesc_input_2fdata_2eproto();
  friend void protobuf_ShutdownFile_input_2fdata_2eproto();

  void InitAsDefaultInstance();
  static ItemRequest* default_instance_;
};
// -------------------------------------------------------------------

class DataSend : public ::google::protobuf::Message {
 public:
  DataSend();
  virtual ~DataSend();

  DataSend(const DataSend& from);

  inline DataSend& operator=(const DataSend& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DataSend& default_instance();

  void Swap(DataSend* other);

  // implements Message ----------------------------------------------

  DataSend* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DataSend& from);
  void MergeFrom(const DataSend& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string userId = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 1;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  inline void set_allocated_userid(::std::string* userid);

  // required string sessionId = 2;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionIdFieldNumber = 2;
  inline const ::std::string& sessionid() const;
  inline void set_sessionid(const ::std::string& value);
  inline void set_sessionid(const char* value);
  inline void set_sessionid(const char* value, size_t size);
  inline ::std::string* mutable_sessionid();
  inline ::std::string* release_sessionid();
  inline void set_allocated_sessionid(::std::string* sessionid);

  // repeated .protobuf.srl.query.ItemSend items = 3;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 3;
  inline const ::protobuf::srl::query::ItemSend& items(int index) const;
  inline ::protobuf::srl::query::ItemSend* mutable_items(int index);
  inline ::protobuf::srl::query::ItemSend* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::srl::query::ItemSend >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::srl::query::ItemSend >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:protobuf.srl.query.DataSend)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_sessionid();
  inline void clear_has_sessionid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* userid_;
  ::std::string* sessionid_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::srl::query::ItemSend > items_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_input_2fdata_2eproto();
  friend void protobuf_AssignDesc_input_2fdata_2eproto();
  friend void protobuf_ShutdownFile_input_2fdata_2eproto();

  void InitAsDefaultInstance();
  static DataSend* default_instance_;
};
// -------------------------------------------------------------------

class ItemSend : public ::google::protobuf::Message {
 public:
  ItemSend();
  virtual ~ItemSend();

  ItemSend(const ItemSend& from);

  inline ItemSend& operator=(const ItemSend& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ItemSend& default_instance();

  void Swap(ItemSend* other);

  // implements Message ----------------------------------------------

  ItemSend* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ItemSend& from);
  void MergeFrom(const ItemSend& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .protobuf.srl.query.ItemQuery query = 1;
  inline bool has_query() const;
  inline void clear_query();
  static const int kQueryFieldNumber = 1;
  inline ::protobuf::srl::query::ItemQuery query() const;
  inline void set_query(::protobuf::srl::query::ItemQuery value);

  // optional bool isInsert = 2;
  inline bool has_isinsert() const;
  inline void clear_isinsert();
  static const int kIsInsertFieldNumber = 2;
  inline bool isinsert() const;
  inline void set_isinsert(bool value);

  // optional bytes data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:protobuf.srl.query.ItemSend)
 private:
  inline void set_has_query();
  inline void clear_has_query();
  inline void set_has_isinsert();
  inline void clear_has_isinsert();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int query_;
  bool isinsert_;
  ::std::string* data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_input_2fdata_2eproto();
  friend void protobuf_AssignDesc_input_2fdata_2eproto();
  friend void protobuf_ShutdownFile_input_2fdata_2eproto();

  void InitAsDefaultInstance();
  static ItemSend* default_instance_;
};
// -------------------------------------------------------------------

class DataResult : public ::google::protobuf::Message {
 public:
  DataResult();
  virtual ~DataResult();

  DataResult(const DataResult& from);

  inline DataResult& operator=(const DataResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DataResult& default_instance();

  void Swap(DataResult* other);

  // implements Message ----------------------------------------------

  DataResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DataResult& from);
  void MergeFrom(const DataResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protobuf.srl.query.ItemResult results = 1;
  inline int results_size() const;
  inline void clear_results();
  static const int kResultsFieldNumber = 1;
  inline const ::protobuf::srl::query::ItemResult& results(int index) const;
  inline ::protobuf::srl::query::ItemResult* mutable_results(int index);
  inline ::protobuf::srl::query::ItemResult* add_results();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::srl::query::ItemResult >&
      results() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::srl::query::ItemResult >*
      mutable_results();

  // @@protoc_insertion_point(class_scope:protobuf.srl.query.DataResult)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::protobuf::srl::query::ItemResult > results_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_input_2fdata_2eproto();
  friend void protobuf_AssignDesc_input_2fdata_2eproto();
  friend void protobuf_ShutdownFile_input_2fdata_2eproto();

  void InitAsDefaultInstance();
  static DataResult* default_instance_;
};
// -------------------------------------------------------------------

class ItemResult : public ::google::protobuf::Message {
 public:
  ItemResult();
  virtual ~ItemResult();

  ItemResult(const ItemResult& from);

  inline ItemResult& operator=(const ItemResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ItemResult& default_instance();

  void Swap(ItemResult* other);

  // implements Message ----------------------------------------------

  ItemResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ItemResult& from);
  void MergeFrom(const ItemResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .protobuf.srl.query.ItemQuery query = 1;
  inline bool has_query() const;
  inline void clear_query();
  static const int kQueryFieldNumber = 1;
  inline ::protobuf::srl::query::ItemQuery query() const;
  inline void set_query(::protobuf::srl::query::ItemQuery value);

  // optional bytes data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:protobuf.srl.query.ItemResult)
 private:
  inline void set_has_query();
  inline void clear_has_query();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* data_;
  int query_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_input_2fdata_2eproto();
  friend void protobuf_AssignDesc_input_2fdata_2eproto();
  friend void protobuf_ShutdownFile_input_2fdata_2eproto();

  void InitAsDefaultInstance();
  static ItemResult* default_instance_;
};
// -------------------------------------------------------------------

class AdvanceCourseGradePull : public ::google::protobuf::Message {
 public:
  AdvanceCourseGradePull();
  virtual ~AdvanceCourseGradePull();

  AdvanceCourseGradePull(const AdvanceCourseGradePull& from);

  inline AdvanceCourseGradePull& operator=(const AdvanceCourseGradePull& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AdvanceCourseGradePull& default_instance();

  void Swap(AdvanceCourseGradePull* other);

  // implements Message ----------------------------------------------

  AdvanceCourseGradePull* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AdvanceCourseGradePull& from);
  void MergeFrom(const AdvanceCourseGradePull& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string courseId = 1;
  inline bool has_courseid() const;
  inline void clear_courseid();
  static const int kCourseIdFieldNumber = 1;
  inline const ::std::string& courseid() const;
  inline void set_courseid(const ::std::string& value);
  inline void set_courseid(const char* value);
  inline void set_courseid(const char* value, size_t size);
  inline ::std::string* mutable_courseid();
  inline ::std::string* release_courseid();
  inline void set_allocated_courseid(::std::string* courseid);

  // optional bool pullAllGrades = 2;
  inline bool has_pullallgrades() const;
  inline void clear_pullallgrades();
  static const int kPullAllGradesFieldNumber = 2;
  inline bool pullallgrades() const;
  inline void set_pullallgrades(bool value);

  // repeated string userId = 3;
  inline int userid_size() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 3;
  inline const ::std::string& userid(int index) const;
  inline ::std::string* mutable_userid(int index);
  inline void set_userid(int index, const ::std::string& value);
  inline void set_userid(int index, const char* value);
  inline void set_userid(int index, const char* value, size_t size);
  inline ::std::string* add_userid();
  inline void add_userid(const ::std::string& value);
  inline void add_userid(const char* value);
  inline void add_userid(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& userid() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_userid();

  // @@protoc_insertion_point(class_scope:protobuf.srl.query.AdvanceCourseGradePull)
 private:
  inline void set_has_courseid();
  inline void clear_has_courseid();
  inline void set_has_pullallgrades();
  inline void clear_has_pullallgrades();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* courseid_;
  ::google::protobuf::RepeatedPtrField< ::std::string> userid_;
  bool pullallgrades_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_input_2fdata_2eproto();
  friend void protobuf_AssignDesc_input_2fdata_2eproto();
  friend void protobuf_ShutdownFile_input_2fdata_2eproto();

  void InitAsDefaultInstance();
  static AdvanceCourseGradePull* default_instance_;
};
// -------------------------------------------------------------------

class AdvanceUserGradePull : public ::google::protobuf::Message {
 public:
  AdvanceUserGradePull();
  virtual ~AdvanceUserGradePull();

  AdvanceUserGradePull(const AdvanceUserGradePull& from);

  inline AdvanceUserGradePull& operator=(const AdvanceUserGradePull& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AdvanceUserGradePull& default_instance();

  void Swap(AdvanceUserGradePull* other);

  // implements Message ----------------------------------------------

  AdvanceUserGradePull* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AdvanceUserGradePull& from);
  void MergeFrom(const AdvanceUserGradePull& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string userId = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 1;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  inline void set_allocated_userid(::std::string* userid);

  // optional bool pullAllGrades = 2;
  inline bool has_pullallgrades() const;
  inline void clear_pullallgrades();
  static const int kPullAllGradesFieldNumber = 2;
  inline bool pullallgrades() const;
  inline void set_pullallgrades(bool value);

  // repeated string courseId = 3;
  inline int courseid_size() const;
  inline void clear_courseid();
  static const int kCourseIdFieldNumber = 3;
  inline const ::std::string& courseid(int index) const;
  inline ::std::string* mutable_courseid(int index);
  inline void set_courseid(int index, const ::std::string& value);
  inline void set_courseid(int index, const char* value);
  inline void set_courseid(int index, const char* value, size_t size);
  inline ::std::string* add_courseid();
  inline void add_courseid(const ::std::string& value);
  inline void add_courseid(const char* value);
  inline void add_courseid(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& courseid() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_courseid();

  // @@protoc_insertion_point(class_scope:protobuf.srl.query.AdvanceUserGradePull)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_pullallgrades();
  inline void clear_has_pullallgrades();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* userid_;
  ::google::protobuf::RepeatedPtrField< ::std::string> courseid_;
  bool pullallgrades_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_input_2fdata_2eproto();
  friend void protobuf_AssignDesc_input_2fdata_2eproto();
  friend void protobuf_ShutdownFile_input_2fdata_2eproto();

  void InitAsDefaultInstance();
  static AdvanceUserGradePull* default_instance_;
};
// -------------------------------------------------------------------

class AdvanceReview : public ::google::protobuf::Message {
 public:
  AdvanceReview();
  virtual ~AdvanceReview();

  AdvanceReview(const AdvanceReview& from);

  inline AdvanceReview& operator=(const AdvanceReview& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AdvanceReview& default_instance();

  void Swap(AdvanceReview* other);

  // implements Message ----------------------------------------------

  AdvanceReview* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AdvanceReview& from);
  void MergeFrom(const AdvanceReview& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string courseId = 1;
  inline bool has_courseid() const;
  inline void clear_courseid();
  static const int kCourseIdFieldNumber = 1;
  inline const ::std::string& courseid() const;
  inline void set_courseid(const ::std::string& value);
  inline void set_courseid(const char* value);
  inline void set_courseid(const char* value, size_t size);
  inline ::std::string* mutable_courseid();
  inline ::std::string* release_courseid();
  inline void set_allocated_courseid(::std::string* courseid);

  // required string assignmentId = 2;
  inline bool has_assignmentid() const;
  inline void clear_assignmentid();
  static const int kAssignmentIdFieldNumber = 2;
  inline const ::std::string& assignmentid() const;
  inline void set_assignmentid(const ::std::string& value);
  inline void set_assignmentid(const char* value);
  inline void set_assignmentid(const char* value, size_t size);
  inline ::std::string* mutable_assignmentid();
  inline ::std::string* release_assignmentid();
  inline void set_allocated_assignmentid(::std::string* assignmentid);

  // required string courseProblemId = 3;
  inline bool has_courseproblemid() const;
  inline void clear_courseproblemid();
  static const int kCourseProblemIdFieldNumber = 3;
  inline const ::std::string& courseproblemid() const;
  inline void set_courseproblemid(const ::std::string& value);
  inline void set_courseproblemid(const char* value);
  inline void set_courseproblemid(const char* value, size_t size);
  inline ::std::string* mutable_courseproblemid();
  inline ::std::string* release_courseproblemid();
  inline void set_allocated_courseproblemid(::std::string* courseproblemid);

  // @@protoc_insertion_point(class_scope:protobuf.srl.query.AdvanceReview)
 private:
  inline void set_has_courseid();
  inline void clear_has_courseid();
  inline void set_has_assignmentid();
  inline void clear_has_assignmentid();
  inline void set_has_courseproblemid();
  inline void clear_has_courseproblemid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* courseid_;
  ::std::string* assignmentid_;
  ::std::string* courseproblemid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_input_2fdata_2eproto();
  friend void protobuf_AssignDesc_input_2fdata_2eproto();
  friend void protobuf_ShutdownFile_input_2fdata_2eproto();

  void InitAsDefaultInstance();
  static AdvanceReview* default_instance_;
};
// ===================================================================


// ===================================================================

// DataRequest

// required string userId = 1;
inline bool DataRequest::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataRequest::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataRequest::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataRequest::clear_userid() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& DataRequest::userid() const {
  return *userid_;
}
inline void DataRequest::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void DataRequest::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void DataRequest::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataRequest::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  return userid_;
}
inline ::std::string* DataRequest::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DataRequest::set_allocated_userid(::std::string* userid) {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    delete userid_;
  }
  if (userid) {
    set_has_userid();
    userid_ = userid;
  } else {
    clear_has_userid();
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string sessionId = 2;
inline bool DataRequest::has_sessionid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataRequest::set_has_sessionid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataRequest::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataRequest::clear_sessionid() {
  if (sessionid_ != &::google::protobuf::internal::kEmptyString) {
    sessionid_->clear();
  }
  clear_has_sessionid();
}
inline const ::std::string& DataRequest::sessionid() const {
  return *sessionid_;
}
inline void DataRequest::set_sessionid(const ::std::string& value) {
  set_has_sessionid();
  if (sessionid_ == &::google::protobuf::internal::kEmptyString) {
    sessionid_ = new ::std::string;
  }
  sessionid_->assign(value);
}
inline void DataRequest::set_sessionid(const char* value) {
  set_has_sessionid();
  if (sessionid_ == &::google::protobuf::internal::kEmptyString) {
    sessionid_ = new ::std::string;
  }
  sessionid_->assign(value);
}
inline void DataRequest::set_sessionid(const char* value, size_t size) {
  set_has_sessionid();
  if (sessionid_ == &::google::protobuf::internal::kEmptyString) {
    sessionid_ = new ::std::string;
  }
  sessionid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataRequest::mutable_sessionid() {
  set_has_sessionid();
  if (sessionid_ == &::google::protobuf::internal::kEmptyString) {
    sessionid_ = new ::std::string;
  }
  return sessionid_;
}
inline ::std::string* DataRequest::release_sessionid() {
  clear_has_sessionid();
  if (sessionid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sessionid_;
    sessionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DataRequest::set_allocated_sessionid(::std::string* sessionid) {
  if (sessionid_ != &::google::protobuf::internal::kEmptyString) {
    delete sessionid_;
  }
  if (sessionid) {
    set_has_sessionid();
    sessionid_ = sessionid;
  } else {
    clear_has_sessionid();
    sessionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .protobuf.srl.query.ItemRequest items = 3;
inline int DataRequest::items_size() const {
  return items_.size();
}
inline void DataRequest::clear_items() {
  items_.Clear();
}
inline const ::protobuf::srl::query::ItemRequest& DataRequest::items(int index) const {
  return items_.Get(index);
}
inline ::protobuf::srl::query::ItemRequest* DataRequest::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::protobuf::srl::query::ItemRequest* DataRequest::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::srl::query::ItemRequest >&
DataRequest::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::srl::query::ItemRequest >*
DataRequest::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// ItemRequest

// repeated string itemId = 1;
inline int ItemRequest::itemid_size() const {
  return itemid_.size();
}
inline void ItemRequest::clear_itemid() {
  itemid_.Clear();
}
inline const ::std::string& ItemRequest::itemid(int index) const {
  return itemid_.Get(index);
}
inline ::std::string* ItemRequest::mutable_itemid(int index) {
  return itemid_.Mutable(index);
}
inline void ItemRequest::set_itemid(int index, const ::std::string& value) {
  itemid_.Mutable(index)->assign(value);
}
inline void ItemRequest::set_itemid(int index, const char* value) {
  itemid_.Mutable(index)->assign(value);
}
inline void ItemRequest::set_itemid(int index, const char* value, size_t size) {
  itemid_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ItemRequest::add_itemid() {
  return itemid_.Add();
}
inline void ItemRequest::add_itemid(const ::std::string& value) {
  itemid_.Add()->assign(value);
}
inline void ItemRequest::add_itemid(const char* value) {
  itemid_.Add()->assign(value);
}
inline void ItemRequest::add_itemid(const char* value, size_t size) {
  itemid_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ItemRequest::itemid() const {
  return itemid_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ItemRequest::mutable_itemid() {
  return &itemid_;
}

// optional .protobuf.srl.query.ItemQuery query = 2;
inline bool ItemRequest::has_query() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ItemRequest::set_has_query() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ItemRequest::clear_has_query() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ItemRequest::clear_query() {
  query_ = 0;
  clear_has_query();
}
inline ::protobuf::srl::query::ItemQuery ItemRequest::query() const {
  return static_cast< ::protobuf::srl::query::ItemQuery >(query_);
}
inline void ItemRequest::set_query(::protobuf::srl::query::ItemQuery value) {
  assert(::protobuf::srl::query::ItemQuery_IsValid(value));
  set_has_query();
  query_ = value;
}

// optional bytes advanceQuery = 3;
inline bool ItemRequest::has_advancequery() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ItemRequest::set_has_advancequery() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ItemRequest::clear_has_advancequery() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ItemRequest::clear_advancequery() {
  if (advancequery_ != &::google::protobuf::internal::kEmptyString) {
    advancequery_->clear();
  }
  clear_has_advancequery();
}
inline const ::std::string& ItemRequest::advancequery() const {
  return *advancequery_;
}
inline void ItemRequest::set_advancequery(const ::std::string& value) {
  set_has_advancequery();
  if (advancequery_ == &::google::protobuf::internal::kEmptyString) {
    advancequery_ = new ::std::string;
  }
  advancequery_->assign(value);
}
inline void ItemRequest::set_advancequery(const char* value) {
  set_has_advancequery();
  if (advancequery_ == &::google::protobuf::internal::kEmptyString) {
    advancequery_ = new ::std::string;
  }
  advancequery_->assign(value);
}
inline void ItemRequest::set_advancequery(const void* value, size_t size) {
  set_has_advancequery();
  if (advancequery_ == &::google::protobuf::internal::kEmptyString) {
    advancequery_ = new ::std::string;
  }
  advancequery_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ItemRequest::mutable_advancequery() {
  set_has_advancequery();
  if (advancequery_ == &::google::protobuf::internal::kEmptyString) {
    advancequery_ = new ::std::string;
  }
  return advancequery_;
}
inline ::std::string* ItemRequest::release_advancequery() {
  clear_has_advancequery();
  if (advancequery_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = advancequery_;
    advancequery_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ItemRequest::set_allocated_advancequery(::std::string* advancequery) {
  if (advancequery_ != &::google::protobuf::internal::kEmptyString) {
    delete advancequery_;
  }
  if (advancequery) {
    set_has_advancequery();
    advancequery_ = advancequery;
  } else {
    clear_has_advancequery();
    advancequery_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// DataSend

// required string userId = 1;
inline bool DataSend::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataSend::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataSend::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataSend::clear_userid() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& DataSend::userid() const {
  return *userid_;
}
inline void DataSend::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void DataSend::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void DataSend::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataSend::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  return userid_;
}
inline ::std::string* DataSend::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DataSend::set_allocated_userid(::std::string* userid) {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    delete userid_;
  }
  if (userid) {
    set_has_userid();
    userid_ = userid;
  } else {
    clear_has_userid();
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string sessionId = 2;
inline bool DataSend::has_sessionid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataSend::set_has_sessionid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataSend::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataSend::clear_sessionid() {
  if (sessionid_ != &::google::protobuf::internal::kEmptyString) {
    sessionid_->clear();
  }
  clear_has_sessionid();
}
inline const ::std::string& DataSend::sessionid() const {
  return *sessionid_;
}
inline void DataSend::set_sessionid(const ::std::string& value) {
  set_has_sessionid();
  if (sessionid_ == &::google::protobuf::internal::kEmptyString) {
    sessionid_ = new ::std::string;
  }
  sessionid_->assign(value);
}
inline void DataSend::set_sessionid(const char* value) {
  set_has_sessionid();
  if (sessionid_ == &::google::protobuf::internal::kEmptyString) {
    sessionid_ = new ::std::string;
  }
  sessionid_->assign(value);
}
inline void DataSend::set_sessionid(const char* value, size_t size) {
  set_has_sessionid();
  if (sessionid_ == &::google::protobuf::internal::kEmptyString) {
    sessionid_ = new ::std::string;
  }
  sessionid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataSend::mutable_sessionid() {
  set_has_sessionid();
  if (sessionid_ == &::google::protobuf::internal::kEmptyString) {
    sessionid_ = new ::std::string;
  }
  return sessionid_;
}
inline ::std::string* DataSend::release_sessionid() {
  clear_has_sessionid();
  if (sessionid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sessionid_;
    sessionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DataSend::set_allocated_sessionid(::std::string* sessionid) {
  if (sessionid_ != &::google::protobuf::internal::kEmptyString) {
    delete sessionid_;
  }
  if (sessionid) {
    set_has_sessionid();
    sessionid_ = sessionid;
  } else {
    clear_has_sessionid();
    sessionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .protobuf.srl.query.ItemSend items = 3;
inline int DataSend::items_size() const {
  return items_.size();
}
inline void DataSend::clear_items() {
  items_.Clear();
}
inline const ::protobuf::srl::query::ItemSend& DataSend::items(int index) const {
  return items_.Get(index);
}
inline ::protobuf::srl::query::ItemSend* DataSend::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::protobuf::srl::query::ItemSend* DataSend::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::srl::query::ItemSend >&
DataSend::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::srl::query::ItemSend >*
DataSend::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// ItemSend

// optional .protobuf.srl.query.ItemQuery query = 1;
inline bool ItemSend::has_query() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ItemSend::set_has_query() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ItemSend::clear_has_query() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ItemSend::clear_query() {
  query_ = 0;
  clear_has_query();
}
inline ::protobuf::srl::query::ItemQuery ItemSend::query() const {
  return static_cast< ::protobuf::srl::query::ItemQuery >(query_);
}
inline void ItemSend::set_query(::protobuf::srl::query::ItemQuery value) {
  assert(::protobuf::srl::query::ItemQuery_IsValid(value));
  set_has_query();
  query_ = value;
}

// optional bool isInsert = 2;
inline bool ItemSend::has_isinsert() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ItemSend::set_has_isinsert() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ItemSend::clear_has_isinsert() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ItemSend::clear_isinsert() {
  isinsert_ = false;
  clear_has_isinsert();
}
inline bool ItemSend::isinsert() const {
  return isinsert_;
}
inline void ItemSend::set_isinsert(bool value) {
  set_has_isinsert();
  isinsert_ = value;
}

// optional bytes data = 3;
inline bool ItemSend::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ItemSend::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ItemSend::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ItemSend::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& ItemSend::data() const {
  return *data_;
}
inline void ItemSend::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ItemSend::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ItemSend::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ItemSend::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* ItemSend::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ItemSend::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// DataResult

// repeated .protobuf.srl.query.ItemResult results = 1;
inline int DataResult::results_size() const {
  return results_.size();
}
inline void DataResult::clear_results() {
  results_.Clear();
}
inline const ::protobuf::srl::query::ItemResult& DataResult::results(int index) const {
  return results_.Get(index);
}
inline ::protobuf::srl::query::ItemResult* DataResult::mutable_results(int index) {
  return results_.Mutable(index);
}
inline ::protobuf::srl::query::ItemResult* DataResult::add_results() {
  return results_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::srl::query::ItemResult >&
DataResult::results() const {
  return results_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::srl::query::ItemResult >*
DataResult::mutable_results() {
  return &results_;
}

// -------------------------------------------------------------------

// ItemResult

// optional .protobuf.srl.query.ItemQuery query = 1;
inline bool ItemResult::has_query() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ItemResult::set_has_query() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ItemResult::clear_has_query() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ItemResult::clear_query() {
  query_ = 0;
  clear_has_query();
}
inline ::protobuf::srl::query::ItemQuery ItemResult::query() const {
  return static_cast< ::protobuf::srl::query::ItemQuery >(query_);
}
inline void ItemResult::set_query(::protobuf::srl::query::ItemQuery value) {
  assert(::protobuf::srl::query::ItemQuery_IsValid(value));
  set_has_query();
  query_ = value;
}

// optional bytes data = 3;
inline bool ItemResult::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ItemResult::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ItemResult::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ItemResult::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& ItemResult::data() const {
  return *data_;
}
inline void ItemResult::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ItemResult::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ItemResult::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ItemResult::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* ItemResult::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ItemResult::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AdvanceCourseGradePull

// required string courseId = 1;
inline bool AdvanceCourseGradePull::has_courseid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdvanceCourseGradePull::set_has_courseid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AdvanceCourseGradePull::clear_has_courseid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AdvanceCourseGradePull::clear_courseid() {
  if (courseid_ != &::google::protobuf::internal::kEmptyString) {
    courseid_->clear();
  }
  clear_has_courseid();
}
inline const ::std::string& AdvanceCourseGradePull::courseid() const {
  return *courseid_;
}
inline void AdvanceCourseGradePull::set_courseid(const ::std::string& value) {
  set_has_courseid();
  if (courseid_ == &::google::protobuf::internal::kEmptyString) {
    courseid_ = new ::std::string;
  }
  courseid_->assign(value);
}
inline void AdvanceCourseGradePull::set_courseid(const char* value) {
  set_has_courseid();
  if (courseid_ == &::google::protobuf::internal::kEmptyString) {
    courseid_ = new ::std::string;
  }
  courseid_->assign(value);
}
inline void AdvanceCourseGradePull::set_courseid(const char* value, size_t size) {
  set_has_courseid();
  if (courseid_ == &::google::protobuf::internal::kEmptyString) {
    courseid_ = new ::std::string;
  }
  courseid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AdvanceCourseGradePull::mutable_courseid() {
  set_has_courseid();
  if (courseid_ == &::google::protobuf::internal::kEmptyString) {
    courseid_ = new ::std::string;
  }
  return courseid_;
}
inline ::std::string* AdvanceCourseGradePull::release_courseid() {
  clear_has_courseid();
  if (courseid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = courseid_;
    courseid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AdvanceCourseGradePull::set_allocated_courseid(::std::string* courseid) {
  if (courseid_ != &::google::protobuf::internal::kEmptyString) {
    delete courseid_;
  }
  if (courseid) {
    set_has_courseid();
    courseid_ = courseid;
  } else {
    clear_has_courseid();
    courseid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool pullAllGrades = 2;
inline bool AdvanceCourseGradePull::has_pullallgrades() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AdvanceCourseGradePull::set_has_pullallgrades() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AdvanceCourseGradePull::clear_has_pullallgrades() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AdvanceCourseGradePull::clear_pullallgrades() {
  pullallgrades_ = false;
  clear_has_pullallgrades();
}
inline bool AdvanceCourseGradePull::pullallgrades() const {
  return pullallgrades_;
}
inline void AdvanceCourseGradePull::set_pullallgrades(bool value) {
  set_has_pullallgrades();
  pullallgrades_ = value;
}

// repeated string userId = 3;
inline int AdvanceCourseGradePull::userid_size() const {
  return userid_.size();
}
inline void AdvanceCourseGradePull::clear_userid() {
  userid_.Clear();
}
inline const ::std::string& AdvanceCourseGradePull::userid(int index) const {
  return userid_.Get(index);
}
inline ::std::string* AdvanceCourseGradePull::mutable_userid(int index) {
  return userid_.Mutable(index);
}
inline void AdvanceCourseGradePull::set_userid(int index, const ::std::string& value) {
  userid_.Mutable(index)->assign(value);
}
inline void AdvanceCourseGradePull::set_userid(int index, const char* value) {
  userid_.Mutable(index)->assign(value);
}
inline void AdvanceCourseGradePull::set_userid(int index, const char* value, size_t size) {
  userid_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AdvanceCourseGradePull::add_userid() {
  return userid_.Add();
}
inline void AdvanceCourseGradePull::add_userid(const ::std::string& value) {
  userid_.Add()->assign(value);
}
inline void AdvanceCourseGradePull::add_userid(const char* value) {
  userid_.Add()->assign(value);
}
inline void AdvanceCourseGradePull::add_userid(const char* value, size_t size) {
  userid_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AdvanceCourseGradePull::userid() const {
  return userid_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AdvanceCourseGradePull::mutable_userid() {
  return &userid_;
}

// -------------------------------------------------------------------

// AdvanceUserGradePull

// required string userId = 1;
inline bool AdvanceUserGradePull::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdvanceUserGradePull::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AdvanceUserGradePull::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AdvanceUserGradePull::clear_userid() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& AdvanceUserGradePull::userid() const {
  return *userid_;
}
inline void AdvanceUserGradePull::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void AdvanceUserGradePull::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void AdvanceUserGradePull::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AdvanceUserGradePull::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  return userid_;
}
inline ::std::string* AdvanceUserGradePull::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AdvanceUserGradePull::set_allocated_userid(::std::string* userid) {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    delete userid_;
  }
  if (userid) {
    set_has_userid();
    userid_ = userid;
  } else {
    clear_has_userid();
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool pullAllGrades = 2;
inline bool AdvanceUserGradePull::has_pullallgrades() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AdvanceUserGradePull::set_has_pullallgrades() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AdvanceUserGradePull::clear_has_pullallgrades() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AdvanceUserGradePull::clear_pullallgrades() {
  pullallgrades_ = false;
  clear_has_pullallgrades();
}
inline bool AdvanceUserGradePull::pullallgrades() const {
  return pullallgrades_;
}
inline void AdvanceUserGradePull::set_pullallgrades(bool value) {
  set_has_pullallgrades();
  pullallgrades_ = value;
}

// repeated string courseId = 3;
inline int AdvanceUserGradePull::courseid_size() const {
  return courseid_.size();
}
inline void AdvanceUserGradePull::clear_courseid() {
  courseid_.Clear();
}
inline const ::std::string& AdvanceUserGradePull::courseid(int index) const {
  return courseid_.Get(index);
}
inline ::std::string* AdvanceUserGradePull::mutable_courseid(int index) {
  return courseid_.Mutable(index);
}
inline void AdvanceUserGradePull::set_courseid(int index, const ::std::string& value) {
  courseid_.Mutable(index)->assign(value);
}
inline void AdvanceUserGradePull::set_courseid(int index, const char* value) {
  courseid_.Mutable(index)->assign(value);
}
inline void AdvanceUserGradePull::set_courseid(int index, const char* value, size_t size) {
  courseid_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AdvanceUserGradePull::add_courseid() {
  return courseid_.Add();
}
inline void AdvanceUserGradePull::add_courseid(const ::std::string& value) {
  courseid_.Add()->assign(value);
}
inline void AdvanceUserGradePull::add_courseid(const char* value) {
  courseid_.Add()->assign(value);
}
inline void AdvanceUserGradePull::add_courseid(const char* value, size_t size) {
  courseid_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AdvanceUserGradePull::courseid() const {
  return courseid_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AdvanceUserGradePull::mutable_courseid() {
  return &courseid_;
}

// -------------------------------------------------------------------

// AdvanceReview

// required string courseId = 1;
inline bool AdvanceReview::has_courseid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdvanceReview::set_has_courseid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AdvanceReview::clear_has_courseid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AdvanceReview::clear_courseid() {
  if (courseid_ != &::google::protobuf::internal::kEmptyString) {
    courseid_->clear();
  }
  clear_has_courseid();
}
inline const ::std::string& AdvanceReview::courseid() const {
  return *courseid_;
}
inline void AdvanceReview::set_courseid(const ::std::string& value) {
  set_has_courseid();
  if (courseid_ == &::google::protobuf::internal::kEmptyString) {
    courseid_ = new ::std::string;
  }
  courseid_->assign(value);
}
inline void AdvanceReview::set_courseid(const char* value) {
  set_has_courseid();
  if (courseid_ == &::google::protobuf::internal::kEmptyString) {
    courseid_ = new ::std::string;
  }
  courseid_->assign(value);
}
inline void AdvanceReview::set_courseid(const char* value, size_t size) {
  set_has_courseid();
  if (courseid_ == &::google::protobuf::internal::kEmptyString) {
    courseid_ = new ::std::string;
  }
  courseid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AdvanceReview::mutable_courseid() {
  set_has_courseid();
  if (courseid_ == &::google::protobuf::internal::kEmptyString) {
    courseid_ = new ::std::string;
  }
  return courseid_;
}
inline ::std::string* AdvanceReview::release_courseid() {
  clear_has_courseid();
  if (courseid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = courseid_;
    courseid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AdvanceReview::set_allocated_courseid(::std::string* courseid) {
  if (courseid_ != &::google::protobuf::internal::kEmptyString) {
    delete courseid_;
  }
  if (courseid) {
    set_has_courseid();
    courseid_ = courseid;
  } else {
    clear_has_courseid();
    courseid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string assignmentId = 2;
inline bool AdvanceReview::has_assignmentid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AdvanceReview::set_has_assignmentid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AdvanceReview::clear_has_assignmentid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AdvanceReview::clear_assignmentid() {
  if (assignmentid_ != &::google::protobuf::internal::kEmptyString) {
    assignmentid_->clear();
  }
  clear_has_assignmentid();
}
inline const ::std::string& AdvanceReview::assignmentid() const {
  return *assignmentid_;
}
inline void AdvanceReview::set_assignmentid(const ::std::string& value) {
  set_has_assignmentid();
  if (assignmentid_ == &::google::protobuf::internal::kEmptyString) {
    assignmentid_ = new ::std::string;
  }
  assignmentid_->assign(value);
}
inline void AdvanceReview::set_assignmentid(const char* value) {
  set_has_assignmentid();
  if (assignmentid_ == &::google::protobuf::internal::kEmptyString) {
    assignmentid_ = new ::std::string;
  }
  assignmentid_->assign(value);
}
inline void AdvanceReview::set_assignmentid(const char* value, size_t size) {
  set_has_assignmentid();
  if (assignmentid_ == &::google::protobuf::internal::kEmptyString) {
    assignmentid_ = new ::std::string;
  }
  assignmentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AdvanceReview::mutable_assignmentid() {
  set_has_assignmentid();
  if (assignmentid_ == &::google::protobuf::internal::kEmptyString) {
    assignmentid_ = new ::std::string;
  }
  return assignmentid_;
}
inline ::std::string* AdvanceReview::release_assignmentid() {
  clear_has_assignmentid();
  if (assignmentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = assignmentid_;
    assignmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AdvanceReview::set_allocated_assignmentid(::std::string* assignmentid) {
  if (assignmentid_ != &::google::protobuf::internal::kEmptyString) {
    delete assignmentid_;
  }
  if (assignmentid) {
    set_has_assignmentid();
    assignmentid_ = assignmentid;
  } else {
    clear_has_assignmentid();
    assignmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string courseProblemId = 3;
inline bool AdvanceReview::has_courseproblemid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AdvanceReview::set_has_courseproblemid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AdvanceReview::clear_has_courseproblemid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AdvanceReview::clear_courseproblemid() {
  if (courseproblemid_ != &::google::protobuf::internal::kEmptyString) {
    courseproblemid_->clear();
  }
  clear_has_courseproblemid();
}
inline const ::std::string& AdvanceReview::courseproblemid() const {
  return *courseproblemid_;
}
inline void AdvanceReview::set_courseproblemid(const ::std::string& value) {
  set_has_courseproblemid();
  if (courseproblemid_ == &::google::protobuf::internal::kEmptyString) {
    courseproblemid_ = new ::std::string;
  }
  courseproblemid_->assign(value);
}
inline void AdvanceReview::set_courseproblemid(const char* value) {
  set_has_courseproblemid();
  if (courseproblemid_ == &::google::protobuf::internal::kEmptyString) {
    courseproblemid_ = new ::std::string;
  }
  courseproblemid_->assign(value);
}
inline void AdvanceReview::set_courseproblemid(const char* value, size_t size) {
  set_has_courseproblemid();
  if (courseproblemid_ == &::google::protobuf::internal::kEmptyString) {
    courseproblemid_ = new ::std::string;
  }
  courseproblemid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AdvanceReview::mutable_courseproblemid() {
  set_has_courseproblemid();
  if (courseproblemid_ == &::google::protobuf::internal::kEmptyString) {
    courseproblemid_ = new ::std::string;
  }
  return courseproblemid_;
}
inline ::std::string* AdvanceReview::release_courseproblemid() {
  clear_has_courseproblemid();
  if (courseproblemid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = courseproblemid_;
    courseproblemid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AdvanceReview::set_allocated_courseproblemid(::std::string* courseproblemid) {
  if (courseproblemid_ != &::google::protobuf::internal::kEmptyString) {
    delete courseproblemid_;
  }
  if (courseproblemid) {
    set_has_courseproblemid();
    courseproblemid_ = courseproblemid;
  } else {
    clear_has_courseproblemid();
    courseproblemid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace query
}  // namespace srl
}  // namespace protobuf

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protobuf::srl::query::ItemQuery>() {
  return ::protobuf::srl::query::ItemQuery_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_input_2fdata_2eproto__INCLUDED
