// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: input/sketch.proto

#ifndef PROTOBUF_input_2fsketch_2eproto__INCLUDED
#define PROTOBUF_input_2fsketch_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf {
namespace srl {
namespace sketch {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_input_2fsketch_2eproto();
void protobuf_AssignDesc_input_2fsketch_2eproto();
void protobuf_ShutdownFile_input_2fsketch_2eproto();

class SrlSketch;
class SrlObject;
class SrlShape;
class SrlStroke;
class SrlPoint;
class SrlInterpretation;
class SrlBoundingBox;

enum SrlObject_ObjectType {
  SrlObject_ObjectType_SHAPE = 0,
  SrlObject_ObjectType_STROKE = 1,
  SrlObject_ObjectType_POINT = 2,
  SrlObject_ObjectType_LINE = 3
};
bool SrlObject_ObjectType_IsValid(int value);
const SrlObject_ObjectType SrlObject_ObjectType_ObjectType_MIN = SrlObject_ObjectType_SHAPE;
const SrlObject_ObjectType SrlObject_ObjectType_ObjectType_MAX = SrlObject_ObjectType_LINE;
const int SrlObject_ObjectType_ObjectType_ARRAYSIZE = SrlObject_ObjectType_ObjectType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SrlObject_ObjectType_descriptor();
inline const ::std::string& SrlObject_ObjectType_Name(SrlObject_ObjectType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SrlObject_ObjectType_descriptor(), value);
}
inline bool SrlObject_ObjectType_Parse(
    const ::std::string& name, SrlObject_ObjectType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SrlObject_ObjectType>(
    SrlObject_ObjectType_descriptor(), name, value);
}
// ===================================================================

class SrlSketch : public ::google::protobuf::Message {
 public:
  SrlSketch();
  virtual ~SrlSketch();

  SrlSketch(const SrlSketch& from);

  inline SrlSketch& operator=(const SrlSketch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SrlSketch& default_instance();

  void Swap(SrlSketch* other);

  // implements Message ----------------------------------------------

  SrlSketch* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SrlSketch& from);
  void MergeFrom(const SrlSketch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string courseId = 1;
  inline bool has_courseid() const;
  inline void clear_courseid();
  static const int kCourseIdFieldNumber = 1;
  inline const ::std::string& courseid() const;
  inline void set_courseid(const ::std::string& value);
  inline void set_courseid(const char* value);
  inline void set_courseid(const char* value, size_t size);
  inline ::std::string* mutable_courseid();
  inline ::std::string* release_courseid();
  inline void set_allocated_courseid(::std::string* courseid);

  // optional string assignmentId = 2;
  inline bool has_assignmentid() const;
  inline void clear_assignmentid();
  static const int kAssignmentIdFieldNumber = 2;
  inline const ::std::string& assignmentid() const;
  inline void set_assignmentid(const ::std::string& value);
  inline void set_assignmentid(const char* value);
  inline void set_assignmentid(const char* value, size_t size);
  inline ::std::string* mutable_assignmentid();
  inline ::std::string* release_assignmentid();
  inline void set_allocated_assignmentid(::std::string* assignmentid);

  // optional string problemId = 3;
  inline bool has_problemid() const;
  inline void clear_problemid();
  static const int kProblemIdFieldNumber = 3;
  inline const ::std::string& problemid() const;
  inline void set_problemid(const ::std::string& value);
  inline void set_problemid(const char* value);
  inline void set_problemid(const char* value, size_t size);
  inline ::std::string* mutable_problemid();
  inline ::std::string* release_problemid();
  inline void set_allocated_problemid(::std::string* problemid);

  // optional string domainId = 4;
  inline bool has_domainid() const;
  inline void clear_domainid();
  static const int kDomainIdFieldNumber = 4;
  inline const ::std::string& domainid() const;
  inline void set_domainid(const ::std::string& value);
  inline void set_domainid(const char* value);
  inline void set_domainid(const char* value, size_t size);
  inline ::std::string* mutable_domainid();
  inline ::std::string* release_domainid();
  inline void set_allocated_domainid(::std::string* domainid);

  // repeated .protobuf.srl.sketch.SrlObject sketch = 5;
  inline int sketch_size() const;
  inline void clear_sketch();
  static const int kSketchFieldNumber = 5;
  inline const ::protobuf::srl::sketch::SrlObject& sketch(int index) const;
  inline ::protobuf::srl::sketch::SrlObject* mutable_sketch(int index);
  inline ::protobuf::srl::sketch::SrlObject* add_sketch();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::srl::sketch::SrlObject >&
      sketch() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::srl::sketch::SrlObject >*
      mutable_sketch();

  // @@protoc_insertion_point(class_scope:protobuf.srl.sketch.SrlSketch)
 private:
  inline void set_has_courseid();
  inline void clear_has_courseid();
  inline void set_has_assignmentid();
  inline void clear_has_assignmentid();
  inline void set_has_problemid();
  inline void clear_has_problemid();
  inline void set_has_domainid();
  inline void clear_has_domainid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* courseid_;
  ::std::string* assignmentid_;
  ::std::string* problemid_;
  ::std::string* domainid_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::srl::sketch::SrlObject > sketch_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_input_2fsketch_2eproto();
  friend void protobuf_AssignDesc_input_2fsketch_2eproto();
  friend void protobuf_ShutdownFile_input_2fsketch_2eproto();

  void InitAsDefaultInstance();
  static SrlSketch* default_instance_;
};
// -------------------------------------------------------------------

class SrlObject : public ::google::protobuf::Message {
 public:
  SrlObject();
  virtual ~SrlObject();

  SrlObject(const SrlObject& from);

  inline SrlObject& operator=(const SrlObject& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SrlObject& default_instance();

  void Swap(SrlObject* other);

  // implements Message ----------------------------------------------

  SrlObject* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SrlObject& from);
  void MergeFrom(const SrlObject& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SrlObject_ObjectType ObjectType;
  static const ObjectType SHAPE = SrlObject_ObjectType_SHAPE;
  static const ObjectType STROKE = SrlObject_ObjectType_STROKE;
  static const ObjectType POINT = SrlObject_ObjectType_POINT;
  static const ObjectType LINE = SrlObject_ObjectType_LINE;
  static inline bool ObjectType_IsValid(int value) {
    return SrlObject_ObjectType_IsValid(value);
  }
  static const ObjectType ObjectType_MIN =
    SrlObject_ObjectType_ObjectType_MIN;
  static const ObjectType ObjectType_MAX =
    SrlObject_ObjectType_ObjectType_MAX;
  static const int ObjectType_ARRAYSIZE =
    SrlObject_ObjectType_ObjectType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ObjectType_descriptor() {
    return SrlObject_ObjectType_descriptor();
  }
  static inline const ::std::string& ObjectType_Name(ObjectType value) {
    return SrlObject_ObjectType_Name(value);
  }
  static inline bool ObjectType_Parse(const ::std::string& name,
      ObjectType* value) {
    return SrlObject_ObjectType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .protobuf.srl.sketch.SrlObject.ObjectType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::protobuf::srl::sketch::SrlObject_ObjectType type() const;
  inline void set_type(::protobuf::srl::sketch::SrlObject_ObjectType value);

  // required bytes object = 2;
  inline bool has_object() const;
  inline void clear_object();
  static const int kObjectFieldNumber = 2;
  inline const ::std::string& object() const;
  inline void set_object(const ::std::string& value);
  inline void set_object(const char* value);
  inline void set_object(const void* value, size_t size);
  inline ::std::string* mutable_object();
  inline ::std::string* release_object();
  inline void set_allocated_object(::std::string* object);

  // @@protoc_insertion_point(class_scope:protobuf.srl.sketch.SrlObject)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_object();
  inline void clear_has_object();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* object_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_input_2fsketch_2eproto();
  friend void protobuf_AssignDesc_input_2fsketch_2eproto();
  friend void protobuf_ShutdownFile_input_2fsketch_2eproto();

  void InitAsDefaultInstance();
  static SrlObject* default_instance_;
};
// -------------------------------------------------------------------

class SrlShape : public ::google::protobuf::Message {
 public:
  SrlShape();
  virtual ~SrlShape();

  SrlShape(const SrlShape& from);

  inline SrlShape& operator=(const SrlShape& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SrlShape& default_instance();

  void Swap(SrlShape* other);

  // implements Message ----------------------------------------------

  SrlShape* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SrlShape& from);
  void MergeFrom(const SrlShape& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required uint64 time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline ::google::protobuf::uint64 time() const;
  inline void set_time(::google::protobuf::uint64 value);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional bool isUserCreated = 4;
  inline bool has_isusercreated() const;
  inline void clear_isusercreated();
  static const int kIsUserCreatedFieldNumber = 4;
  inline bool isusercreated() const;
  inline void set_isusercreated(bool value);

  // repeated .protobuf.srl.sketch.SrlInterpretation interpretations = 5;
  inline int interpretations_size() const;
  inline void clear_interpretations();
  static const int kInterpretationsFieldNumber = 5;
  inline const ::protobuf::srl::sketch::SrlInterpretation& interpretations(int index) const;
  inline ::protobuf::srl::sketch::SrlInterpretation* mutable_interpretations(int index);
  inline ::protobuf::srl::sketch::SrlInterpretation* add_interpretations();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::srl::sketch::SrlInterpretation >&
      interpretations() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::srl::sketch::SrlInterpretation >*
      mutable_interpretations();

  // repeated .protobuf.srl.sketch.SrlObject subComponents = 6;
  inline int subcomponents_size() const;
  inline void clear_subcomponents();
  static const int kSubComponentsFieldNumber = 6;
  inline const ::protobuf::srl::sketch::SrlObject& subcomponents(int index) const;
  inline ::protobuf::srl::sketch::SrlObject* mutable_subcomponents(int index);
  inline ::protobuf::srl::sketch::SrlObject* add_subcomponents();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::srl::sketch::SrlObject >&
      subcomponents() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::srl::sketch::SrlObject >*
      mutable_subcomponents();

  // optional .protobuf.srl.sketch.SrlBoundingBox boundingbox = 7;
  inline bool has_boundingbox() const;
  inline void clear_boundingbox();
  static const int kBoundingboxFieldNumber = 7;
  inline const ::protobuf::srl::sketch::SrlBoundingBox& boundingbox() const;
  inline ::protobuf::srl::sketch::SrlBoundingBox* mutable_boundingbox();
  inline ::protobuf::srl::sketch::SrlBoundingBox* release_boundingbox();
  inline void set_allocated_boundingbox(::protobuf::srl::sketch::SrlBoundingBox* boundingbox);

  // @@protoc_insertion_point(class_scope:protobuf.srl.sketch.SrlShape)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_isusercreated();
  inline void clear_has_isusercreated();
  inline void set_has_boundingbox();
  inline void clear_has_boundingbox();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::google::protobuf::uint64 time_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::srl::sketch::SrlInterpretation > interpretations_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::srl::sketch::SrlObject > subcomponents_;
  ::protobuf::srl::sketch::SrlBoundingBox* boundingbox_;
  bool isusercreated_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_input_2fsketch_2eproto();
  friend void protobuf_AssignDesc_input_2fsketch_2eproto();
  friend void protobuf_ShutdownFile_input_2fsketch_2eproto();

  void InitAsDefaultInstance();
  static SrlShape* default_instance_;
};
// -------------------------------------------------------------------

class SrlStroke : public ::google::protobuf::Message {
 public:
  SrlStroke();
  virtual ~SrlStroke();

  SrlStroke(const SrlStroke& from);

  inline SrlStroke& operator=(const SrlStroke& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SrlStroke& default_instance();

  void Swap(SrlStroke* other);

  // implements Message ----------------------------------------------

  SrlStroke* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SrlStroke& from);
  void MergeFrom(const SrlStroke& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required uint64 time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline ::google::protobuf::uint64 time() const;
  inline void set_time(::google::protobuf::uint64 value);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .protobuf.srl.sketch.SrlPoint points = 4;
  inline int points_size() const;
  inline void clear_points();
  static const int kPointsFieldNumber = 4;
  inline const ::protobuf::srl::sketch::SrlPoint& points(int index) const;
  inline ::protobuf::srl::sketch::SrlPoint* mutable_points(int index);
  inline ::protobuf::srl::sketch::SrlPoint* add_points();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::srl::sketch::SrlPoint >&
      points() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::srl::sketch::SrlPoint >*
      mutable_points();

  // optional .protobuf.srl.sketch.SrlBoundingBox boundingbox = 5;
  inline bool has_boundingbox() const;
  inline void clear_boundingbox();
  static const int kBoundingboxFieldNumber = 5;
  inline const ::protobuf::srl::sketch::SrlBoundingBox& boundingbox() const;
  inline ::protobuf::srl::sketch::SrlBoundingBox* mutable_boundingbox();
  inline ::protobuf::srl::sketch::SrlBoundingBox* release_boundingbox();
  inline void set_allocated_boundingbox(::protobuf::srl::sketch::SrlBoundingBox* boundingbox);

  // @@protoc_insertion_point(class_scope:protobuf.srl.sketch.SrlStroke)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_boundingbox();
  inline void clear_has_boundingbox();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::google::protobuf::uint64 time_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::srl::sketch::SrlPoint > points_;
  ::protobuf::srl::sketch::SrlBoundingBox* boundingbox_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_input_2fsketch_2eproto();
  friend void protobuf_AssignDesc_input_2fsketch_2eproto();
  friend void protobuf_ShutdownFile_input_2fsketch_2eproto();

  void InitAsDefaultInstance();
  static SrlStroke* default_instance_;
};
// -------------------------------------------------------------------

class SrlPoint : public ::google::protobuf::Message {
 public:
  SrlPoint();
  virtual ~SrlPoint();

  SrlPoint(const SrlPoint& from);

  inline SrlPoint& operator=(const SrlPoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SrlPoint& default_instance();

  void Swap(SrlPoint* other);

  // implements Message ----------------------------------------------

  SrlPoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SrlPoint& from);
  void MergeFrom(const SrlPoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required uint64 time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline ::google::protobuf::uint64 time() const;
  inline void set_time(::google::protobuf::uint64 value);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required double x = 4;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 4;
  inline double x() const;
  inline void set_x(double value);

  // required double y = 5;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 5;
  inline double y() const;
  inline void set_y(double value);

  // optional double pressure = 6;
  inline bool has_pressure() const;
  inline void clear_pressure();
  static const int kPressureFieldNumber = 6;
  inline double pressure() const;
  inline void set_pressure(double value);

  // optional double size = 7;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 7;
  inline double size() const;
  inline void set_size(double value);

  // optional double speed = 8;
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 8;
  inline double speed() const;
  inline void set_speed(double value);

  // @@protoc_insertion_point(class_scope:protobuf.srl.sketch.SrlPoint)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_pressure();
  inline void clear_has_pressure();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_speed();
  inline void clear_has_speed();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::google::protobuf::uint64 time_;
  ::std::string* name_;
  double x_;
  double y_;
  double pressure_;
  double size_;
  double speed_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_input_2fsketch_2eproto();
  friend void protobuf_AssignDesc_input_2fsketch_2eproto();
  friend void protobuf_ShutdownFile_input_2fsketch_2eproto();

  void InitAsDefaultInstance();
  static SrlPoint* default_instance_;
};
// -------------------------------------------------------------------

class SrlInterpretation : public ::google::protobuf::Message {
 public:
  SrlInterpretation();
  virtual ~SrlInterpretation();

  SrlInterpretation(const SrlInterpretation& from);

  inline SrlInterpretation& operator=(const SrlInterpretation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SrlInterpretation& default_instance();

  void Swap(SrlInterpretation* other);

  // implements Message ----------------------------------------------

  SrlInterpretation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SrlInterpretation& from);
  void MergeFrom(const SrlInterpretation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string label = 1;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 1;
  inline const ::std::string& label() const;
  inline void set_label(const ::std::string& value);
  inline void set_label(const char* value);
  inline void set_label(const char* value, size_t size);
  inline ::std::string* mutable_label();
  inline ::std::string* release_label();
  inline void set_allocated_label(::std::string* label);

  // required double confidence = 2;
  inline bool has_confidence() const;
  inline void clear_confidence();
  static const int kConfidenceFieldNumber = 2;
  inline double confidence() const;
  inline void set_confidence(double value);

  // optional double complexity = 3;
  inline bool has_complexity() const;
  inline void clear_complexity();
  static const int kComplexityFieldNumber = 3;
  inline double complexity() const;
  inline void set_complexity(double value);

  // @@protoc_insertion_point(class_scope:protobuf.srl.sketch.SrlInterpretation)
 private:
  inline void set_has_label();
  inline void clear_has_label();
  inline void set_has_confidence();
  inline void clear_has_confidence();
  inline void set_has_complexity();
  inline void clear_has_complexity();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* label_;
  double confidence_;
  double complexity_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_input_2fsketch_2eproto();
  friend void protobuf_AssignDesc_input_2fsketch_2eproto();
  friend void protobuf_ShutdownFile_input_2fsketch_2eproto();

  void InitAsDefaultInstance();
  static SrlInterpretation* default_instance_;
};
// -------------------------------------------------------------------

class SrlBoundingBox : public ::google::protobuf::Message {
 public:
  SrlBoundingBox();
  virtual ~SrlBoundingBox();

  SrlBoundingBox(const SrlBoundingBox& from);

  inline SrlBoundingBox& operator=(const SrlBoundingBox& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SrlBoundingBox& default_instance();

  void Swap(SrlBoundingBox* other);

  // implements Message ----------------------------------------------

  SrlBoundingBox* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SrlBoundingBox& from);
  void MergeFrom(const SrlBoundingBox& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline double x() const;
  inline void set_x(double value);

  // required double y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline double y() const;
  inline void set_y(double value);

  // required double width = 3;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 3;
  inline double width() const;
  inline void set_width(double value);

  // required double height = 4;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 4;
  inline double height() const;
  inline void set_height(double value);

  // @@protoc_insertion_point(class_scope:protobuf.srl.sketch.SrlBoundingBox)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double x_;
  double y_;
  double width_;
  double height_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_input_2fsketch_2eproto();
  friend void protobuf_AssignDesc_input_2fsketch_2eproto();
  friend void protobuf_ShutdownFile_input_2fsketch_2eproto();

  void InitAsDefaultInstance();
  static SrlBoundingBox* default_instance_;
};
// ===================================================================


// ===================================================================

// SrlSketch

// optional string courseId = 1;
inline bool SrlSketch::has_courseid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SrlSketch::set_has_courseid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SrlSketch::clear_has_courseid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SrlSketch::clear_courseid() {
  if (courseid_ != &::google::protobuf::internal::kEmptyString) {
    courseid_->clear();
  }
  clear_has_courseid();
}
inline const ::std::string& SrlSketch::courseid() const {
  return *courseid_;
}
inline void SrlSketch::set_courseid(const ::std::string& value) {
  set_has_courseid();
  if (courseid_ == &::google::protobuf::internal::kEmptyString) {
    courseid_ = new ::std::string;
  }
  courseid_->assign(value);
}
inline void SrlSketch::set_courseid(const char* value) {
  set_has_courseid();
  if (courseid_ == &::google::protobuf::internal::kEmptyString) {
    courseid_ = new ::std::string;
  }
  courseid_->assign(value);
}
inline void SrlSketch::set_courseid(const char* value, size_t size) {
  set_has_courseid();
  if (courseid_ == &::google::protobuf::internal::kEmptyString) {
    courseid_ = new ::std::string;
  }
  courseid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlSketch::mutable_courseid() {
  set_has_courseid();
  if (courseid_ == &::google::protobuf::internal::kEmptyString) {
    courseid_ = new ::std::string;
  }
  return courseid_;
}
inline ::std::string* SrlSketch::release_courseid() {
  clear_has_courseid();
  if (courseid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = courseid_;
    courseid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlSketch::set_allocated_courseid(::std::string* courseid) {
  if (courseid_ != &::google::protobuf::internal::kEmptyString) {
    delete courseid_;
  }
  if (courseid) {
    set_has_courseid();
    courseid_ = courseid;
  } else {
    clear_has_courseid();
    courseid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string assignmentId = 2;
inline bool SrlSketch::has_assignmentid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SrlSketch::set_has_assignmentid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SrlSketch::clear_has_assignmentid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SrlSketch::clear_assignmentid() {
  if (assignmentid_ != &::google::protobuf::internal::kEmptyString) {
    assignmentid_->clear();
  }
  clear_has_assignmentid();
}
inline const ::std::string& SrlSketch::assignmentid() const {
  return *assignmentid_;
}
inline void SrlSketch::set_assignmentid(const ::std::string& value) {
  set_has_assignmentid();
  if (assignmentid_ == &::google::protobuf::internal::kEmptyString) {
    assignmentid_ = new ::std::string;
  }
  assignmentid_->assign(value);
}
inline void SrlSketch::set_assignmentid(const char* value) {
  set_has_assignmentid();
  if (assignmentid_ == &::google::protobuf::internal::kEmptyString) {
    assignmentid_ = new ::std::string;
  }
  assignmentid_->assign(value);
}
inline void SrlSketch::set_assignmentid(const char* value, size_t size) {
  set_has_assignmentid();
  if (assignmentid_ == &::google::protobuf::internal::kEmptyString) {
    assignmentid_ = new ::std::string;
  }
  assignmentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlSketch::mutable_assignmentid() {
  set_has_assignmentid();
  if (assignmentid_ == &::google::protobuf::internal::kEmptyString) {
    assignmentid_ = new ::std::string;
  }
  return assignmentid_;
}
inline ::std::string* SrlSketch::release_assignmentid() {
  clear_has_assignmentid();
  if (assignmentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = assignmentid_;
    assignmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlSketch::set_allocated_assignmentid(::std::string* assignmentid) {
  if (assignmentid_ != &::google::protobuf::internal::kEmptyString) {
    delete assignmentid_;
  }
  if (assignmentid) {
    set_has_assignmentid();
    assignmentid_ = assignmentid;
  } else {
    clear_has_assignmentid();
    assignmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string problemId = 3;
inline bool SrlSketch::has_problemid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SrlSketch::set_has_problemid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SrlSketch::clear_has_problemid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SrlSketch::clear_problemid() {
  if (problemid_ != &::google::protobuf::internal::kEmptyString) {
    problemid_->clear();
  }
  clear_has_problemid();
}
inline const ::std::string& SrlSketch::problemid() const {
  return *problemid_;
}
inline void SrlSketch::set_problemid(const ::std::string& value) {
  set_has_problemid();
  if (problemid_ == &::google::protobuf::internal::kEmptyString) {
    problemid_ = new ::std::string;
  }
  problemid_->assign(value);
}
inline void SrlSketch::set_problemid(const char* value) {
  set_has_problemid();
  if (problemid_ == &::google::protobuf::internal::kEmptyString) {
    problemid_ = new ::std::string;
  }
  problemid_->assign(value);
}
inline void SrlSketch::set_problemid(const char* value, size_t size) {
  set_has_problemid();
  if (problemid_ == &::google::protobuf::internal::kEmptyString) {
    problemid_ = new ::std::string;
  }
  problemid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlSketch::mutable_problemid() {
  set_has_problemid();
  if (problemid_ == &::google::protobuf::internal::kEmptyString) {
    problemid_ = new ::std::string;
  }
  return problemid_;
}
inline ::std::string* SrlSketch::release_problemid() {
  clear_has_problemid();
  if (problemid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = problemid_;
    problemid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlSketch::set_allocated_problemid(::std::string* problemid) {
  if (problemid_ != &::google::protobuf::internal::kEmptyString) {
    delete problemid_;
  }
  if (problemid) {
    set_has_problemid();
    problemid_ = problemid;
  } else {
    clear_has_problemid();
    problemid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string domainId = 4;
inline bool SrlSketch::has_domainid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SrlSketch::set_has_domainid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SrlSketch::clear_has_domainid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SrlSketch::clear_domainid() {
  if (domainid_ != &::google::protobuf::internal::kEmptyString) {
    domainid_->clear();
  }
  clear_has_domainid();
}
inline const ::std::string& SrlSketch::domainid() const {
  return *domainid_;
}
inline void SrlSketch::set_domainid(const ::std::string& value) {
  set_has_domainid();
  if (domainid_ == &::google::protobuf::internal::kEmptyString) {
    domainid_ = new ::std::string;
  }
  domainid_->assign(value);
}
inline void SrlSketch::set_domainid(const char* value) {
  set_has_domainid();
  if (domainid_ == &::google::protobuf::internal::kEmptyString) {
    domainid_ = new ::std::string;
  }
  domainid_->assign(value);
}
inline void SrlSketch::set_domainid(const char* value, size_t size) {
  set_has_domainid();
  if (domainid_ == &::google::protobuf::internal::kEmptyString) {
    domainid_ = new ::std::string;
  }
  domainid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlSketch::mutable_domainid() {
  set_has_domainid();
  if (domainid_ == &::google::protobuf::internal::kEmptyString) {
    domainid_ = new ::std::string;
  }
  return domainid_;
}
inline ::std::string* SrlSketch::release_domainid() {
  clear_has_domainid();
  if (domainid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domainid_;
    domainid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlSketch::set_allocated_domainid(::std::string* domainid) {
  if (domainid_ != &::google::protobuf::internal::kEmptyString) {
    delete domainid_;
  }
  if (domainid) {
    set_has_domainid();
    domainid_ = domainid;
  } else {
    clear_has_domainid();
    domainid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .protobuf.srl.sketch.SrlObject sketch = 5;
inline int SrlSketch::sketch_size() const {
  return sketch_.size();
}
inline void SrlSketch::clear_sketch() {
  sketch_.Clear();
}
inline const ::protobuf::srl::sketch::SrlObject& SrlSketch::sketch(int index) const {
  return sketch_.Get(index);
}
inline ::protobuf::srl::sketch::SrlObject* SrlSketch::mutable_sketch(int index) {
  return sketch_.Mutable(index);
}
inline ::protobuf::srl::sketch::SrlObject* SrlSketch::add_sketch() {
  return sketch_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::srl::sketch::SrlObject >&
SrlSketch::sketch() const {
  return sketch_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::srl::sketch::SrlObject >*
SrlSketch::mutable_sketch() {
  return &sketch_;
}

// -------------------------------------------------------------------

// SrlObject

// required .protobuf.srl.sketch.SrlObject.ObjectType type = 1;
inline bool SrlObject::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SrlObject::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SrlObject::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SrlObject::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::protobuf::srl::sketch::SrlObject_ObjectType SrlObject::type() const {
  return static_cast< ::protobuf::srl::sketch::SrlObject_ObjectType >(type_);
}
inline void SrlObject::set_type(::protobuf::srl::sketch::SrlObject_ObjectType value) {
  assert(::protobuf::srl::sketch::SrlObject_ObjectType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required bytes object = 2;
inline bool SrlObject::has_object() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SrlObject::set_has_object() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SrlObject::clear_has_object() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SrlObject::clear_object() {
  if (object_ != &::google::protobuf::internal::kEmptyString) {
    object_->clear();
  }
  clear_has_object();
}
inline const ::std::string& SrlObject::object() const {
  return *object_;
}
inline void SrlObject::set_object(const ::std::string& value) {
  set_has_object();
  if (object_ == &::google::protobuf::internal::kEmptyString) {
    object_ = new ::std::string;
  }
  object_->assign(value);
}
inline void SrlObject::set_object(const char* value) {
  set_has_object();
  if (object_ == &::google::protobuf::internal::kEmptyString) {
    object_ = new ::std::string;
  }
  object_->assign(value);
}
inline void SrlObject::set_object(const void* value, size_t size) {
  set_has_object();
  if (object_ == &::google::protobuf::internal::kEmptyString) {
    object_ = new ::std::string;
  }
  object_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlObject::mutable_object() {
  set_has_object();
  if (object_ == &::google::protobuf::internal::kEmptyString) {
    object_ = new ::std::string;
  }
  return object_;
}
inline ::std::string* SrlObject::release_object() {
  clear_has_object();
  if (object_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = object_;
    object_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlObject::set_allocated_object(::std::string* object) {
  if (object_ != &::google::protobuf::internal::kEmptyString) {
    delete object_;
  }
  if (object) {
    set_has_object();
    object_ = object;
  } else {
    clear_has_object();
    object_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SrlShape

// required string id = 1;
inline bool SrlShape::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SrlShape::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SrlShape::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SrlShape::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& SrlShape::id() const {
  return *id_;
}
inline void SrlShape::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void SrlShape::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void SrlShape::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlShape::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* SrlShape::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlShape::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint64 time = 2;
inline bool SrlShape::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SrlShape::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SrlShape::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SrlShape::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::uint64 SrlShape::time() const {
  return time_;
}
inline void SrlShape::set_time(::google::protobuf::uint64 value) {
  set_has_time();
  time_ = value;
}

// optional string name = 3;
inline bool SrlShape::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SrlShape::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SrlShape::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SrlShape::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& SrlShape::name() const {
  return *name_;
}
inline void SrlShape::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SrlShape::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SrlShape::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlShape::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* SrlShape::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlShape::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool isUserCreated = 4;
inline bool SrlShape::has_isusercreated() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SrlShape::set_has_isusercreated() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SrlShape::clear_has_isusercreated() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SrlShape::clear_isusercreated() {
  isusercreated_ = false;
  clear_has_isusercreated();
}
inline bool SrlShape::isusercreated() const {
  return isusercreated_;
}
inline void SrlShape::set_isusercreated(bool value) {
  set_has_isusercreated();
  isusercreated_ = value;
}

// repeated .protobuf.srl.sketch.SrlInterpretation interpretations = 5;
inline int SrlShape::interpretations_size() const {
  return interpretations_.size();
}
inline void SrlShape::clear_interpretations() {
  interpretations_.Clear();
}
inline const ::protobuf::srl::sketch::SrlInterpretation& SrlShape::interpretations(int index) const {
  return interpretations_.Get(index);
}
inline ::protobuf::srl::sketch::SrlInterpretation* SrlShape::mutable_interpretations(int index) {
  return interpretations_.Mutable(index);
}
inline ::protobuf::srl::sketch::SrlInterpretation* SrlShape::add_interpretations() {
  return interpretations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::srl::sketch::SrlInterpretation >&
SrlShape::interpretations() const {
  return interpretations_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::srl::sketch::SrlInterpretation >*
SrlShape::mutable_interpretations() {
  return &interpretations_;
}

// repeated .protobuf.srl.sketch.SrlObject subComponents = 6;
inline int SrlShape::subcomponents_size() const {
  return subcomponents_.size();
}
inline void SrlShape::clear_subcomponents() {
  subcomponents_.Clear();
}
inline const ::protobuf::srl::sketch::SrlObject& SrlShape::subcomponents(int index) const {
  return subcomponents_.Get(index);
}
inline ::protobuf::srl::sketch::SrlObject* SrlShape::mutable_subcomponents(int index) {
  return subcomponents_.Mutable(index);
}
inline ::protobuf::srl::sketch::SrlObject* SrlShape::add_subcomponents() {
  return subcomponents_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::srl::sketch::SrlObject >&
SrlShape::subcomponents() const {
  return subcomponents_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::srl::sketch::SrlObject >*
SrlShape::mutable_subcomponents() {
  return &subcomponents_;
}

// optional .protobuf.srl.sketch.SrlBoundingBox boundingbox = 7;
inline bool SrlShape::has_boundingbox() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SrlShape::set_has_boundingbox() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SrlShape::clear_has_boundingbox() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SrlShape::clear_boundingbox() {
  if (boundingbox_ != NULL) boundingbox_->::protobuf::srl::sketch::SrlBoundingBox::Clear();
  clear_has_boundingbox();
}
inline const ::protobuf::srl::sketch::SrlBoundingBox& SrlShape::boundingbox() const {
  return boundingbox_ != NULL ? *boundingbox_ : *default_instance_->boundingbox_;
}
inline ::protobuf::srl::sketch::SrlBoundingBox* SrlShape::mutable_boundingbox() {
  set_has_boundingbox();
  if (boundingbox_ == NULL) boundingbox_ = new ::protobuf::srl::sketch::SrlBoundingBox;
  return boundingbox_;
}
inline ::protobuf::srl::sketch::SrlBoundingBox* SrlShape::release_boundingbox() {
  clear_has_boundingbox();
  ::protobuf::srl::sketch::SrlBoundingBox* temp = boundingbox_;
  boundingbox_ = NULL;
  return temp;
}
inline void SrlShape::set_allocated_boundingbox(::protobuf::srl::sketch::SrlBoundingBox* boundingbox) {
  delete boundingbox_;
  boundingbox_ = boundingbox;
  if (boundingbox) {
    set_has_boundingbox();
  } else {
    clear_has_boundingbox();
  }
}

// -------------------------------------------------------------------

// SrlStroke

// required string id = 1;
inline bool SrlStroke::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SrlStroke::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SrlStroke::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SrlStroke::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& SrlStroke::id() const {
  return *id_;
}
inline void SrlStroke::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void SrlStroke::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void SrlStroke::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlStroke::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* SrlStroke::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlStroke::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint64 time = 2;
inline bool SrlStroke::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SrlStroke::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SrlStroke::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SrlStroke::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::uint64 SrlStroke::time() const {
  return time_;
}
inline void SrlStroke::set_time(::google::protobuf::uint64 value) {
  set_has_time();
  time_ = value;
}

// optional string name = 3;
inline bool SrlStroke::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SrlStroke::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SrlStroke::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SrlStroke::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& SrlStroke::name() const {
  return *name_;
}
inline void SrlStroke::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SrlStroke::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SrlStroke::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlStroke::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* SrlStroke::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlStroke::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .protobuf.srl.sketch.SrlPoint points = 4;
inline int SrlStroke::points_size() const {
  return points_.size();
}
inline void SrlStroke::clear_points() {
  points_.Clear();
}
inline const ::protobuf::srl::sketch::SrlPoint& SrlStroke::points(int index) const {
  return points_.Get(index);
}
inline ::protobuf::srl::sketch::SrlPoint* SrlStroke::mutable_points(int index) {
  return points_.Mutable(index);
}
inline ::protobuf::srl::sketch::SrlPoint* SrlStroke::add_points() {
  return points_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::srl::sketch::SrlPoint >&
SrlStroke::points() const {
  return points_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::srl::sketch::SrlPoint >*
SrlStroke::mutable_points() {
  return &points_;
}

// optional .protobuf.srl.sketch.SrlBoundingBox boundingbox = 5;
inline bool SrlStroke::has_boundingbox() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SrlStroke::set_has_boundingbox() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SrlStroke::clear_has_boundingbox() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SrlStroke::clear_boundingbox() {
  if (boundingbox_ != NULL) boundingbox_->::protobuf::srl::sketch::SrlBoundingBox::Clear();
  clear_has_boundingbox();
}
inline const ::protobuf::srl::sketch::SrlBoundingBox& SrlStroke::boundingbox() const {
  return boundingbox_ != NULL ? *boundingbox_ : *default_instance_->boundingbox_;
}
inline ::protobuf::srl::sketch::SrlBoundingBox* SrlStroke::mutable_boundingbox() {
  set_has_boundingbox();
  if (boundingbox_ == NULL) boundingbox_ = new ::protobuf::srl::sketch::SrlBoundingBox;
  return boundingbox_;
}
inline ::protobuf::srl::sketch::SrlBoundingBox* SrlStroke::release_boundingbox() {
  clear_has_boundingbox();
  ::protobuf::srl::sketch::SrlBoundingBox* temp = boundingbox_;
  boundingbox_ = NULL;
  return temp;
}
inline void SrlStroke::set_allocated_boundingbox(::protobuf::srl::sketch::SrlBoundingBox* boundingbox) {
  delete boundingbox_;
  boundingbox_ = boundingbox;
  if (boundingbox) {
    set_has_boundingbox();
  } else {
    clear_has_boundingbox();
  }
}

// -------------------------------------------------------------------

// SrlPoint

// required string id = 1;
inline bool SrlPoint::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SrlPoint::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SrlPoint::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SrlPoint::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& SrlPoint::id() const {
  return *id_;
}
inline void SrlPoint::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void SrlPoint::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void SrlPoint::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlPoint::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* SrlPoint::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlPoint::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint64 time = 2;
inline bool SrlPoint::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SrlPoint::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SrlPoint::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SrlPoint::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::uint64 SrlPoint::time() const {
  return time_;
}
inline void SrlPoint::set_time(::google::protobuf::uint64 value) {
  set_has_time();
  time_ = value;
}

// optional string name = 3;
inline bool SrlPoint::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SrlPoint::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SrlPoint::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SrlPoint::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& SrlPoint::name() const {
  return *name_;
}
inline void SrlPoint::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SrlPoint::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SrlPoint::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlPoint::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* SrlPoint::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlPoint::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required double x = 4;
inline bool SrlPoint::has_x() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SrlPoint::set_has_x() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SrlPoint::clear_has_x() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SrlPoint::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double SrlPoint::x() const {
  return x_;
}
inline void SrlPoint::set_x(double value) {
  set_has_x();
  x_ = value;
}

// required double y = 5;
inline bool SrlPoint::has_y() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SrlPoint::set_has_y() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SrlPoint::clear_has_y() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SrlPoint::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double SrlPoint::y() const {
  return y_;
}
inline void SrlPoint::set_y(double value) {
  set_has_y();
  y_ = value;
}

// optional double pressure = 6;
inline bool SrlPoint::has_pressure() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SrlPoint::set_has_pressure() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SrlPoint::clear_has_pressure() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SrlPoint::clear_pressure() {
  pressure_ = 0;
  clear_has_pressure();
}
inline double SrlPoint::pressure() const {
  return pressure_;
}
inline void SrlPoint::set_pressure(double value) {
  set_has_pressure();
  pressure_ = value;
}

// optional double size = 7;
inline bool SrlPoint::has_size() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SrlPoint::set_has_size() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SrlPoint::clear_has_size() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SrlPoint::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline double SrlPoint::size() const {
  return size_;
}
inline void SrlPoint::set_size(double value) {
  set_has_size();
  size_ = value;
}

// optional double speed = 8;
inline bool SrlPoint::has_speed() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SrlPoint::set_has_speed() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SrlPoint::clear_has_speed() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SrlPoint::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline double SrlPoint::speed() const {
  return speed_;
}
inline void SrlPoint::set_speed(double value) {
  set_has_speed();
  speed_ = value;
}

// -------------------------------------------------------------------

// SrlInterpretation

// required string label = 1;
inline bool SrlInterpretation::has_label() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SrlInterpretation::set_has_label() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SrlInterpretation::clear_has_label() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SrlInterpretation::clear_label() {
  if (label_ != &::google::protobuf::internal::kEmptyString) {
    label_->clear();
  }
  clear_has_label();
}
inline const ::std::string& SrlInterpretation::label() const {
  return *label_;
}
inline void SrlInterpretation::set_label(const ::std::string& value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void SrlInterpretation::set_label(const char* value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void SrlInterpretation::set_label(const char* value, size_t size) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlInterpretation::mutable_label() {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  return label_;
}
inline ::std::string* SrlInterpretation::release_label() {
  clear_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = label_;
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlInterpretation::set_allocated_label(::std::string* label) {
  if (label_ != &::google::protobuf::internal::kEmptyString) {
    delete label_;
  }
  if (label) {
    set_has_label();
    label_ = label;
  } else {
    clear_has_label();
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required double confidence = 2;
inline bool SrlInterpretation::has_confidence() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SrlInterpretation::set_has_confidence() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SrlInterpretation::clear_has_confidence() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SrlInterpretation::clear_confidence() {
  confidence_ = 0;
  clear_has_confidence();
}
inline double SrlInterpretation::confidence() const {
  return confidence_;
}
inline void SrlInterpretation::set_confidence(double value) {
  set_has_confidence();
  confidence_ = value;
}

// optional double complexity = 3;
inline bool SrlInterpretation::has_complexity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SrlInterpretation::set_has_complexity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SrlInterpretation::clear_has_complexity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SrlInterpretation::clear_complexity() {
  complexity_ = 0;
  clear_has_complexity();
}
inline double SrlInterpretation::complexity() const {
  return complexity_;
}
inline void SrlInterpretation::set_complexity(double value) {
  set_has_complexity();
  complexity_ = value;
}

// -------------------------------------------------------------------

// SrlBoundingBox

// required double x = 1;
inline bool SrlBoundingBox::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SrlBoundingBox::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SrlBoundingBox::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SrlBoundingBox::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double SrlBoundingBox::x() const {
  return x_;
}
inline void SrlBoundingBox::set_x(double value) {
  set_has_x();
  x_ = value;
}

// required double y = 2;
inline bool SrlBoundingBox::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SrlBoundingBox::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SrlBoundingBox::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SrlBoundingBox::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double SrlBoundingBox::y() const {
  return y_;
}
inline void SrlBoundingBox::set_y(double value) {
  set_has_y();
  y_ = value;
}

// required double width = 3;
inline bool SrlBoundingBox::has_width() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SrlBoundingBox::set_has_width() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SrlBoundingBox::clear_has_width() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SrlBoundingBox::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline double SrlBoundingBox::width() const {
  return width_;
}
inline void SrlBoundingBox::set_width(double value) {
  set_has_width();
  width_ = value;
}

// required double height = 4;
inline bool SrlBoundingBox::has_height() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SrlBoundingBox::set_has_height() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SrlBoundingBox::clear_has_height() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SrlBoundingBox::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline double SrlBoundingBox::height() const {
  return height_;
}
inline void SrlBoundingBox::set_height(double value) {
  set_has_height();
  height_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace sketch
}  // namespace srl
}  // namespace protobuf

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protobuf::srl::sketch::SrlObject_ObjectType>() {
  return ::protobuf::srl::sketch::SrlObject_ObjectType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_input_2fsketch_2eproto__INCLUDED
