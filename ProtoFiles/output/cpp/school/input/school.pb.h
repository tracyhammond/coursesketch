// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: input/school.proto

#ifndef PROTOBUF_input_2fschool_2eproto__INCLUDED
#define PROTOBUF_input_2fschool_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf {
namespace srl {
namespace school {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_input_2fschool_2eproto();
void protobuf_AssignDesc_input_2fschool_2eproto();
void protobuf_ShutdownFile_input_2fschool_2eproto();

class SrlSchool;
class SrlCourse;
class SrlAssignment;
class SrlProblem;
class subproblemInformation;

enum subproblemInformation_QuestionType {
  subproblemInformation_QuestionType_SKETCH = 1,
  subproblemInformation_QuestionType_MULT_CHOICE = 2,
  subproblemInformation_QuestionType_FREE_RESP = 3,
  subproblemInformation_QuestionType_CHECK_BOX = 4
};
bool subproblemInformation_QuestionType_IsValid(int value);
const subproblemInformation_QuestionType subproblemInformation_QuestionType_QuestionType_MIN = subproblemInformation_QuestionType_SKETCH;
const subproblemInformation_QuestionType subproblemInformation_QuestionType_QuestionType_MAX = subproblemInformation_QuestionType_CHECK_BOX;
const int subproblemInformation_QuestionType_QuestionType_ARRAYSIZE = subproblemInformation_QuestionType_QuestionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* subproblemInformation_QuestionType_descriptor();
inline const ::std::string& subproblemInformation_QuestionType_Name(subproblemInformation_QuestionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    subproblemInformation_QuestionType_descriptor(), value);
}
inline bool subproblemInformation_QuestionType_Parse(
    const ::std::string& name, subproblemInformation_QuestionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<subproblemInformation_QuestionType>(
    subproblemInformation_QuestionType_descriptor(), name, value);
}
// ===================================================================

class SrlSchool : public ::google::protobuf::Message {
 public:
  SrlSchool();
  virtual ~SrlSchool();

  SrlSchool(const SrlSchool& from);

  inline SrlSchool& operator=(const SrlSchool& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SrlSchool& default_instance();

  void Swap(SrlSchool* other);

  // implements Message ----------------------------------------------

  SrlSchool* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SrlSchool& from);
  void MergeFrom(const SrlSchool& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protobuf.srl.school.SrlCourse courses = 1;
  inline int courses_size() const;
  inline void clear_courses();
  static const int kCoursesFieldNumber = 1;
  inline const ::protobuf::srl::school::SrlCourse& courses(int index) const;
  inline ::protobuf::srl::school::SrlCourse* mutable_courses(int index);
  inline ::protobuf::srl::school::SrlCourse* add_courses();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlCourse >&
      courses() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlCourse >*
      mutable_courses();

  // repeated .protobuf.srl.school.SrlAssignment assignments = 2;
  inline int assignments_size() const;
  inline void clear_assignments();
  static const int kAssignmentsFieldNumber = 2;
  inline const ::protobuf::srl::school::SrlAssignment& assignments(int index) const;
  inline ::protobuf::srl::school::SrlAssignment* mutable_assignments(int index);
  inline ::protobuf::srl::school::SrlAssignment* add_assignments();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlAssignment >&
      assignments() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlAssignment >*
      mutable_assignments();

  // repeated .protobuf.srl.school.SrlProblem problems = 3;
  inline int problems_size() const;
  inline void clear_problems();
  static const int kProblemsFieldNumber = 3;
  inline const ::protobuf::srl::school::SrlProblem& problems(int index) const;
  inline ::protobuf::srl::school::SrlProblem* mutable_problems(int index);
  inline ::protobuf::srl::school::SrlProblem* add_problems();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlProblem >&
      problems() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlProblem >*
      mutable_problems();

  // @@protoc_insertion_point(class_scope:protobuf.srl.school.SrlSchool)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlCourse > courses_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlAssignment > assignments_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlProblem > problems_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_input_2fschool_2eproto();
  friend void protobuf_AssignDesc_input_2fschool_2eproto();
  friend void protobuf_ShutdownFile_input_2fschool_2eproto();

  void InitAsDefaultInstance();
  static SrlSchool* default_instance_;
};
// -------------------------------------------------------------------

class SrlCourse : public ::google::protobuf::Message {
 public:
  SrlCourse();
  virtual ~SrlCourse();

  SrlCourse(const SrlCourse& from);

  inline SrlCourse& operator=(const SrlCourse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SrlCourse& default_instance();

  void Swap(SrlCourse* other);

  // implements Message ----------------------------------------------

  SrlCourse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SrlCourse& from);
  void MergeFrom(const SrlCourse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string courseId = 1;
  inline bool has_courseid() const;
  inline void clear_courseid();
  static const int kCourseIdFieldNumber = 1;
  inline const ::std::string& courseid() const;
  inline void set_courseid(const ::std::string& value);
  inline void set_courseid(const char* value);
  inline void set_courseid(const char* value, size_t size);
  inline ::std::string* mutable_courseid();
  inline ::std::string* release_courseid();
  inline void set_allocated_courseid(::std::string* courseid);

  // optional string courseName = 2;
  inline bool has_coursename() const;
  inline void clear_coursename();
  static const int kCourseNameFieldNumber = 2;
  inline const ::std::string& coursename() const;
  inline void set_coursename(const ::std::string& value);
  inline void set_coursename(const char* value);
  inline void set_coursename(const char* value, size_t size);
  inline ::std::string* mutable_coursename();
  inline ::std::string* release_coursename();
  inline void set_allocated_coursename(::std::string* coursename);

  // @@protoc_insertion_point(class_scope:protobuf.srl.school.SrlCourse)
 private:
  inline void set_has_courseid();
  inline void clear_has_courseid();
  inline void set_has_coursename();
  inline void clear_has_coursename();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* courseid_;
  ::std::string* coursename_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_input_2fschool_2eproto();
  friend void protobuf_AssignDesc_input_2fschool_2eproto();
  friend void protobuf_ShutdownFile_input_2fschool_2eproto();

  void InitAsDefaultInstance();
  static SrlCourse* default_instance_;
};
// -------------------------------------------------------------------

class SrlAssignment : public ::google::protobuf::Message {
 public:
  SrlAssignment();
  virtual ~SrlAssignment();

  SrlAssignment(const SrlAssignment& from);

  inline SrlAssignment& operator=(const SrlAssignment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SrlAssignment& default_instance();

  void Swap(SrlAssignment* other);

  // implements Message ----------------------------------------------

  SrlAssignment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SrlAssignment& from);
  void MergeFrom(const SrlAssignment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 courseId = 1;
  inline bool has_courseid() const;
  inline void clear_courseid();
  static const int kCourseIdFieldNumber = 1;
  inline ::google::protobuf::uint64 courseid() const;
  inline void set_courseid(::google::protobuf::uint64 value);

  // required string assignmentId = 2;
  inline bool has_assignmentid() const;
  inline void clear_assignmentid();
  static const int kAssignmentIdFieldNumber = 2;
  inline const ::std::string& assignmentid() const;
  inline void set_assignmentid(const ::std::string& value);
  inline void set_assignmentid(const char* value);
  inline void set_assignmentid(const char* value, size_t size);
  inline ::std::string* mutable_assignmentid();
  inline ::std::string* release_assignmentid();
  inline void set_allocated_assignmentid(::std::string* assignmentid);

  // optional string assignmentName = 3;
  inline bool has_assignmentname() const;
  inline void clear_assignmentname();
  static const int kAssignmentNameFieldNumber = 3;
  inline const ::std::string& assignmentname() const;
  inline void set_assignmentname(const ::std::string& value);
  inline void set_assignmentname(const char* value);
  inline void set_assignmentname(const char* value, size_t size);
  inline ::std::string* mutable_assignmentname();
  inline ::std::string* release_assignmentname();
  inline void set_allocated_assignmentname(::std::string* assignmentname);

  // @@protoc_insertion_point(class_scope:protobuf.srl.school.SrlAssignment)
 private:
  inline void set_has_courseid();
  inline void clear_has_courseid();
  inline void set_has_assignmentid();
  inline void clear_has_assignmentid();
  inline void set_has_assignmentname();
  inline void clear_has_assignmentname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 courseid_;
  ::std::string* assignmentid_;
  ::std::string* assignmentname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_input_2fschool_2eproto();
  friend void protobuf_AssignDesc_input_2fschool_2eproto();
  friend void protobuf_ShutdownFile_input_2fschool_2eproto();

  void InitAsDefaultInstance();
  static SrlAssignment* default_instance_;
};
// -------------------------------------------------------------------

class SrlProblem : public ::google::protobuf::Message {
 public:
  SrlProblem();
  virtual ~SrlProblem();

  SrlProblem(const SrlProblem& from);

  inline SrlProblem& operator=(const SrlProblem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SrlProblem& default_instance();

  void Swap(SrlProblem* other);

  // implements Message ----------------------------------------------

  SrlProblem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SrlProblem& from);
  void MergeFrom(const SrlProblem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 courseId = 1;
  inline bool has_courseid() const;
  inline void clear_courseid();
  static const int kCourseIdFieldNumber = 1;
  inline ::google::protobuf::uint64 courseid() const;
  inline void set_courseid(::google::protobuf::uint64 value);

  // required uint64 assignmentId = 2;
  inline bool has_assignmentid() const;
  inline void clear_assignmentid();
  static const int kAssignmentIdFieldNumber = 2;
  inline ::google::protobuf::uint64 assignmentid() const;
  inline void set_assignmentid(::google::protobuf::uint64 value);

  // required string problemId = 3;
  inline bool has_problemid() const;
  inline void clear_problemid();
  static const int kProblemIdFieldNumber = 3;
  inline const ::std::string& problemid() const;
  inline void set_problemid(const ::std::string& value);
  inline void set_problemid(const char* value);
  inline void set_problemid(const char* value, size_t size);
  inline ::std::string* mutable_problemid();
  inline ::std::string* release_problemid();
  inline void set_allocated_problemid(::std::string* problemid);

  // optional string problemName = 4;
  inline bool has_problemname() const;
  inline void clear_problemname();
  static const int kProblemNameFieldNumber = 4;
  inline const ::std::string& problemname() const;
  inline void set_problemname(const ::std::string& value);
  inline void set_problemname(const char* value);
  inline void set_problemname(const char* value, size_t size);
  inline ::std::string* mutable_problemname();
  inline ::std::string* release_problemname();
  inline void set_allocated_problemname(::std::string* problemname);

  // optional .protobuf.srl.school.subproblemInformation mainProblem = 5;
  inline bool has_mainproblem() const;
  inline void clear_mainproblem();
  static const int kMainProblemFieldNumber = 5;
  inline const ::protobuf::srl::school::subproblemInformation& mainproblem() const;
  inline ::protobuf::srl::school::subproblemInformation* mutable_mainproblem();
  inline ::protobuf::srl::school::subproblemInformation* release_mainproblem();
  inline void set_allocated_mainproblem(::protobuf::srl::school::subproblemInformation* mainproblem);

  // repeated .protobuf.srl.school.subproblemInformation subProblems = 6;
  inline int subproblems_size() const;
  inline void clear_subproblems();
  static const int kSubProblemsFieldNumber = 6;
  inline const ::protobuf::srl::school::subproblemInformation& subproblems(int index) const;
  inline ::protobuf::srl::school::subproblemInformation* mutable_subproblems(int index);
  inline ::protobuf::srl::school::subproblemInformation* add_subproblems();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::subproblemInformation >&
      subproblems() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::subproblemInformation >*
      mutable_subproblems();

  // @@protoc_insertion_point(class_scope:protobuf.srl.school.SrlProblem)
 private:
  inline void set_has_courseid();
  inline void clear_has_courseid();
  inline void set_has_assignmentid();
  inline void clear_has_assignmentid();
  inline void set_has_problemid();
  inline void clear_has_problemid();
  inline void set_has_problemname();
  inline void clear_has_problemname();
  inline void set_has_mainproblem();
  inline void clear_has_mainproblem();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 courseid_;
  ::google::protobuf::uint64 assignmentid_;
  ::std::string* problemid_;
  ::std::string* problemname_;
  ::protobuf::srl::school::subproblemInformation* mainproblem_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::subproblemInformation > subproblems_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_input_2fschool_2eproto();
  friend void protobuf_AssignDesc_input_2fschool_2eproto();
  friend void protobuf_ShutdownFile_input_2fschool_2eproto();

  void InitAsDefaultInstance();
  static SrlProblem* default_instance_;
};
// -------------------------------------------------------------------

class subproblemInformation : public ::google::protobuf::Message {
 public:
  subproblemInformation();
  virtual ~subproblemInformation();

  subproblemInformation(const subproblemInformation& from);

  inline subproblemInformation& operator=(const subproblemInformation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const subproblemInformation& default_instance();

  void Swap(subproblemInformation* other);

  // implements Message ----------------------------------------------

  subproblemInformation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const subproblemInformation& from);
  void MergeFrom(const subproblemInformation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef subproblemInformation_QuestionType QuestionType;
  static const QuestionType SKETCH = subproblemInformation_QuestionType_SKETCH;
  static const QuestionType MULT_CHOICE = subproblemInformation_QuestionType_MULT_CHOICE;
  static const QuestionType FREE_RESP = subproblemInformation_QuestionType_FREE_RESP;
  static const QuestionType CHECK_BOX = subproblemInformation_QuestionType_CHECK_BOX;
  static inline bool QuestionType_IsValid(int value) {
    return subproblemInformation_QuestionType_IsValid(value);
  }
  static const QuestionType QuestionType_MIN =
    subproblemInformation_QuestionType_QuestionType_MIN;
  static const QuestionType QuestionType_MAX =
    subproblemInformation_QuestionType_QuestionType_MAX;
  static const int QuestionType_ARRAYSIZE =
    subproblemInformation_QuestionType_QuestionType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  QuestionType_descriptor() {
    return subproblemInformation_QuestionType_descriptor();
  }
  static inline const ::std::string& QuestionType_Name(QuestionType value) {
    return subproblemInformation_QuestionType_Name(value);
  }
  static inline bool QuestionType_Parse(const ::std::string& name,
      QuestionType* value) {
    return subproblemInformation_QuestionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string questionText = 1;
  inline bool has_questiontext() const;
  inline void clear_questiontext();
  static const int kQuestionTextFieldNumber = 1;
  inline const ::std::string& questiontext() const;
  inline void set_questiontext(const ::std::string& value);
  inline void set_questiontext(const char* value);
  inline void set_questiontext(const char* value, size_t size);
  inline ::std::string* mutable_questiontext();
  inline ::std::string* release_questiontext();
  inline void set_allocated_questiontext(::std::string* questiontext);

  // optional .protobuf.srl.school.subproblemInformation.QuestionType questionType = 2 [default = SKETCH];
  inline bool has_questiontype() const;
  inline void clear_questiontype();
  static const int kQuestionTypeFieldNumber = 2;
  inline ::protobuf::srl::school::subproblemInformation_QuestionType questiontype() const;
  inline void set_questiontype(::protobuf::srl::school::subproblemInformation_QuestionType value);

  // optional bytes options = 3;
  inline bool has_options() const;
  inline void clear_options();
  static const int kOptionsFieldNumber = 3;
  inline const ::std::string& options() const;
  inline void set_options(const ::std::string& value);
  inline void set_options(const char* value);
  inline void set_options(const void* value, size_t size);
  inline ::std::string* mutable_options();
  inline ::std::string* release_options();
  inline void set_allocated_options(::std::string* options);

  // @@protoc_insertion_point(class_scope:protobuf.srl.school.subproblemInformation)
 private:
  inline void set_has_questiontext();
  inline void clear_has_questiontext();
  inline void set_has_questiontype();
  inline void clear_has_questiontype();
  inline void set_has_options();
  inline void clear_has_options();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* questiontext_;
  ::std::string* options_;
  int questiontype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_input_2fschool_2eproto();
  friend void protobuf_AssignDesc_input_2fschool_2eproto();
  friend void protobuf_ShutdownFile_input_2fschool_2eproto();

  void InitAsDefaultInstance();
  static subproblemInformation* default_instance_;
};
// ===================================================================


// ===================================================================

// SrlSchool

// repeated .protobuf.srl.school.SrlCourse courses = 1;
inline int SrlSchool::courses_size() const {
  return courses_.size();
}
inline void SrlSchool::clear_courses() {
  courses_.Clear();
}
inline const ::protobuf::srl::school::SrlCourse& SrlSchool::courses(int index) const {
  return courses_.Get(index);
}
inline ::protobuf::srl::school::SrlCourse* SrlSchool::mutable_courses(int index) {
  return courses_.Mutable(index);
}
inline ::protobuf::srl::school::SrlCourse* SrlSchool::add_courses() {
  return courses_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlCourse >&
SrlSchool::courses() const {
  return courses_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlCourse >*
SrlSchool::mutable_courses() {
  return &courses_;
}

// repeated .protobuf.srl.school.SrlAssignment assignments = 2;
inline int SrlSchool::assignments_size() const {
  return assignments_.size();
}
inline void SrlSchool::clear_assignments() {
  assignments_.Clear();
}
inline const ::protobuf::srl::school::SrlAssignment& SrlSchool::assignments(int index) const {
  return assignments_.Get(index);
}
inline ::protobuf::srl::school::SrlAssignment* SrlSchool::mutable_assignments(int index) {
  return assignments_.Mutable(index);
}
inline ::protobuf::srl::school::SrlAssignment* SrlSchool::add_assignments() {
  return assignments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlAssignment >&
SrlSchool::assignments() const {
  return assignments_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlAssignment >*
SrlSchool::mutable_assignments() {
  return &assignments_;
}

// repeated .protobuf.srl.school.SrlProblem problems = 3;
inline int SrlSchool::problems_size() const {
  return problems_.size();
}
inline void SrlSchool::clear_problems() {
  problems_.Clear();
}
inline const ::protobuf::srl::school::SrlProblem& SrlSchool::problems(int index) const {
  return problems_.Get(index);
}
inline ::protobuf::srl::school::SrlProblem* SrlSchool::mutable_problems(int index) {
  return problems_.Mutable(index);
}
inline ::protobuf::srl::school::SrlProblem* SrlSchool::add_problems() {
  return problems_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlProblem >&
SrlSchool::problems() const {
  return problems_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlProblem >*
SrlSchool::mutable_problems() {
  return &problems_;
}

// -------------------------------------------------------------------

// SrlCourse

// required string courseId = 1;
inline bool SrlCourse::has_courseid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SrlCourse::set_has_courseid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SrlCourse::clear_has_courseid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SrlCourse::clear_courseid() {
  if (courseid_ != &::google::protobuf::internal::kEmptyString) {
    courseid_->clear();
  }
  clear_has_courseid();
}
inline const ::std::string& SrlCourse::courseid() const {
  return *courseid_;
}
inline void SrlCourse::set_courseid(const ::std::string& value) {
  set_has_courseid();
  if (courseid_ == &::google::protobuf::internal::kEmptyString) {
    courseid_ = new ::std::string;
  }
  courseid_->assign(value);
}
inline void SrlCourse::set_courseid(const char* value) {
  set_has_courseid();
  if (courseid_ == &::google::protobuf::internal::kEmptyString) {
    courseid_ = new ::std::string;
  }
  courseid_->assign(value);
}
inline void SrlCourse::set_courseid(const char* value, size_t size) {
  set_has_courseid();
  if (courseid_ == &::google::protobuf::internal::kEmptyString) {
    courseid_ = new ::std::string;
  }
  courseid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlCourse::mutable_courseid() {
  set_has_courseid();
  if (courseid_ == &::google::protobuf::internal::kEmptyString) {
    courseid_ = new ::std::string;
  }
  return courseid_;
}
inline ::std::string* SrlCourse::release_courseid() {
  clear_has_courseid();
  if (courseid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = courseid_;
    courseid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlCourse::set_allocated_courseid(::std::string* courseid) {
  if (courseid_ != &::google::protobuf::internal::kEmptyString) {
    delete courseid_;
  }
  if (courseid) {
    set_has_courseid();
    courseid_ = courseid;
  } else {
    clear_has_courseid();
    courseid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string courseName = 2;
inline bool SrlCourse::has_coursename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SrlCourse::set_has_coursename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SrlCourse::clear_has_coursename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SrlCourse::clear_coursename() {
  if (coursename_ != &::google::protobuf::internal::kEmptyString) {
    coursename_->clear();
  }
  clear_has_coursename();
}
inline const ::std::string& SrlCourse::coursename() const {
  return *coursename_;
}
inline void SrlCourse::set_coursename(const ::std::string& value) {
  set_has_coursename();
  if (coursename_ == &::google::protobuf::internal::kEmptyString) {
    coursename_ = new ::std::string;
  }
  coursename_->assign(value);
}
inline void SrlCourse::set_coursename(const char* value) {
  set_has_coursename();
  if (coursename_ == &::google::protobuf::internal::kEmptyString) {
    coursename_ = new ::std::string;
  }
  coursename_->assign(value);
}
inline void SrlCourse::set_coursename(const char* value, size_t size) {
  set_has_coursename();
  if (coursename_ == &::google::protobuf::internal::kEmptyString) {
    coursename_ = new ::std::string;
  }
  coursename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlCourse::mutable_coursename() {
  set_has_coursename();
  if (coursename_ == &::google::protobuf::internal::kEmptyString) {
    coursename_ = new ::std::string;
  }
  return coursename_;
}
inline ::std::string* SrlCourse::release_coursename() {
  clear_has_coursename();
  if (coursename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = coursename_;
    coursename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlCourse::set_allocated_coursename(::std::string* coursename) {
  if (coursename_ != &::google::protobuf::internal::kEmptyString) {
    delete coursename_;
  }
  if (coursename) {
    set_has_coursename();
    coursename_ = coursename;
  } else {
    clear_has_coursename();
    coursename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SrlAssignment

// required uint64 courseId = 1;
inline bool SrlAssignment::has_courseid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SrlAssignment::set_has_courseid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SrlAssignment::clear_has_courseid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SrlAssignment::clear_courseid() {
  courseid_ = GOOGLE_ULONGLONG(0);
  clear_has_courseid();
}
inline ::google::protobuf::uint64 SrlAssignment::courseid() const {
  return courseid_;
}
inline void SrlAssignment::set_courseid(::google::protobuf::uint64 value) {
  set_has_courseid();
  courseid_ = value;
}

// required string assignmentId = 2;
inline bool SrlAssignment::has_assignmentid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SrlAssignment::set_has_assignmentid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SrlAssignment::clear_has_assignmentid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SrlAssignment::clear_assignmentid() {
  if (assignmentid_ != &::google::protobuf::internal::kEmptyString) {
    assignmentid_->clear();
  }
  clear_has_assignmentid();
}
inline const ::std::string& SrlAssignment::assignmentid() const {
  return *assignmentid_;
}
inline void SrlAssignment::set_assignmentid(const ::std::string& value) {
  set_has_assignmentid();
  if (assignmentid_ == &::google::protobuf::internal::kEmptyString) {
    assignmentid_ = new ::std::string;
  }
  assignmentid_->assign(value);
}
inline void SrlAssignment::set_assignmentid(const char* value) {
  set_has_assignmentid();
  if (assignmentid_ == &::google::protobuf::internal::kEmptyString) {
    assignmentid_ = new ::std::string;
  }
  assignmentid_->assign(value);
}
inline void SrlAssignment::set_assignmentid(const char* value, size_t size) {
  set_has_assignmentid();
  if (assignmentid_ == &::google::protobuf::internal::kEmptyString) {
    assignmentid_ = new ::std::string;
  }
  assignmentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlAssignment::mutable_assignmentid() {
  set_has_assignmentid();
  if (assignmentid_ == &::google::protobuf::internal::kEmptyString) {
    assignmentid_ = new ::std::string;
  }
  return assignmentid_;
}
inline ::std::string* SrlAssignment::release_assignmentid() {
  clear_has_assignmentid();
  if (assignmentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = assignmentid_;
    assignmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlAssignment::set_allocated_assignmentid(::std::string* assignmentid) {
  if (assignmentid_ != &::google::protobuf::internal::kEmptyString) {
    delete assignmentid_;
  }
  if (assignmentid) {
    set_has_assignmentid();
    assignmentid_ = assignmentid;
  } else {
    clear_has_assignmentid();
    assignmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string assignmentName = 3;
inline bool SrlAssignment::has_assignmentname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SrlAssignment::set_has_assignmentname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SrlAssignment::clear_has_assignmentname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SrlAssignment::clear_assignmentname() {
  if (assignmentname_ != &::google::protobuf::internal::kEmptyString) {
    assignmentname_->clear();
  }
  clear_has_assignmentname();
}
inline const ::std::string& SrlAssignment::assignmentname() const {
  return *assignmentname_;
}
inline void SrlAssignment::set_assignmentname(const ::std::string& value) {
  set_has_assignmentname();
  if (assignmentname_ == &::google::protobuf::internal::kEmptyString) {
    assignmentname_ = new ::std::string;
  }
  assignmentname_->assign(value);
}
inline void SrlAssignment::set_assignmentname(const char* value) {
  set_has_assignmentname();
  if (assignmentname_ == &::google::protobuf::internal::kEmptyString) {
    assignmentname_ = new ::std::string;
  }
  assignmentname_->assign(value);
}
inline void SrlAssignment::set_assignmentname(const char* value, size_t size) {
  set_has_assignmentname();
  if (assignmentname_ == &::google::protobuf::internal::kEmptyString) {
    assignmentname_ = new ::std::string;
  }
  assignmentname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlAssignment::mutable_assignmentname() {
  set_has_assignmentname();
  if (assignmentname_ == &::google::protobuf::internal::kEmptyString) {
    assignmentname_ = new ::std::string;
  }
  return assignmentname_;
}
inline ::std::string* SrlAssignment::release_assignmentname() {
  clear_has_assignmentname();
  if (assignmentname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = assignmentname_;
    assignmentname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlAssignment::set_allocated_assignmentname(::std::string* assignmentname) {
  if (assignmentname_ != &::google::protobuf::internal::kEmptyString) {
    delete assignmentname_;
  }
  if (assignmentname) {
    set_has_assignmentname();
    assignmentname_ = assignmentname;
  } else {
    clear_has_assignmentname();
    assignmentname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SrlProblem

// required uint64 courseId = 1;
inline bool SrlProblem::has_courseid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SrlProblem::set_has_courseid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SrlProblem::clear_has_courseid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SrlProblem::clear_courseid() {
  courseid_ = GOOGLE_ULONGLONG(0);
  clear_has_courseid();
}
inline ::google::protobuf::uint64 SrlProblem::courseid() const {
  return courseid_;
}
inline void SrlProblem::set_courseid(::google::protobuf::uint64 value) {
  set_has_courseid();
  courseid_ = value;
}

// required uint64 assignmentId = 2;
inline bool SrlProblem::has_assignmentid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SrlProblem::set_has_assignmentid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SrlProblem::clear_has_assignmentid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SrlProblem::clear_assignmentid() {
  assignmentid_ = GOOGLE_ULONGLONG(0);
  clear_has_assignmentid();
}
inline ::google::protobuf::uint64 SrlProblem::assignmentid() const {
  return assignmentid_;
}
inline void SrlProblem::set_assignmentid(::google::protobuf::uint64 value) {
  set_has_assignmentid();
  assignmentid_ = value;
}

// required string problemId = 3;
inline bool SrlProblem::has_problemid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SrlProblem::set_has_problemid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SrlProblem::clear_has_problemid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SrlProblem::clear_problemid() {
  if (problemid_ != &::google::protobuf::internal::kEmptyString) {
    problemid_->clear();
  }
  clear_has_problemid();
}
inline const ::std::string& SrlProblem::problemid() const {
  return *problemid_;
}
inline void SrlProblem::set_problemid(const ::std::string& value) {
  set_has_problemid();
  if (problemid_ == &::google::protobuf::internal::kEmptyString) {
    problemid_ = new ::std::string;
  }
  problemid_->assign(value);
}
inline void SrlProblem::set_problemid(const char* value) {
  set_has_problemid();
  if (problemid_ == &::google::protobuf::internal::kEmptyString) {
    problemid_ = new ::std::string;
  }
  problemid_->assign(value);
}
inline void SrlProblem::set_problemid(const char* value, size_t size) {
  set_has_problemid();
  if (problemid_ == &::google::protobuf::internal::kEmptyString) {
    problemid_ = new ::std::string;
  }
  problemid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlProblem::mutable_problemid() {
  set_has_problemid();
  if (problemid_ == &::google::protobuf::internal::kEmptyString) {
    problemid_ = new ::std::string;
  }
  return problemid_;
}
inline ::std::string* SrlProblem::release_problemid() {
  clear_has_problemid();
  if (problemid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = problemid_;
    problemid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlProblem::set_allocated_problemid(::std::string* problemid) {
  if (problemid_ != &::google::protobuf::internal::kEmptyString) {
    delete problemid_;
  }
  if (problemid) {
    set_has_problemid();
    problemid_ = problemid;
  } else {
    clear_has_problemid();
    problemid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string problemName = 4;
inline bool SrlProblem::has_problemname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SrlProblem::set_has_problemname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SrlProblem::clear_has_problemname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SrlProblem::clear_problemname() {
  if (problemname_ != &::google::protobuf::internal::kEmptyString) {
    problemname_->clear();
  }
  clear_has_problemname();
}
inline const ::std::string& SrlProblem::problemname() const {
  return *problemname_;
}
inline void SrlProblem::set_problemname(const ::std::string& value) {
  set_has_problemname();
  if (problemname_ == &::google::protobuf::internal::kEmptyString) {
    problemname_ = new ::std::string;
  }
  problemname_->assign(value);
}
inline void SrlProblem::set_problemname(const char* value) {
  set_has_problemname();
  if (problemname_ == &::google::protobuf::internal::kEmptyString) {
    problemname_ = new ::std::string;
  }
  problemname_->assign(value);
}
inline void SrlProblem::set_problemname(const char* value, size_t size) {
  set_has_problemname();
  if (problemname_ == &::google::protobuf::internal::kEmptyString) {
    problemname_ = new ::std::string;
  }
  problemname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlProblem::mutable_problemname() {
  set_has_problemname();
  if (problemname_ == &::google::protobuf::internal::kEmptyString) {
    problemname_ = new ::std::string;
  }
  return problemname_;
}
inline ::std::string* SrlProblem::release_problemname() {
  clear_has_problemname();
  if (problemname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = problemname_;
    problemname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlProblem::set_allocated_problemname(::std::string* problemname) {
  if (problemname_ != &::google::protobuf::internal::kEmptyString) {
    delete problemname_;
  }
  if (problemname) {
    set_has_problemname();
    problemname_ = problemname;
  } else {
    clear_has_problemname();
    problemname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .protobuf.srl.school.subproblemInformation mainProblem = 5;
inline bool SrlProblem::has_mainproblem() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SrlProblem::set_has_mainproblem() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SrlProblem::clear_has_mainproblem() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SrlProblem::clear_mainproblem() {
  if (mainproblem_ != NULL) mainproblem_->::protobuf::srl::school::subproblemInformation::Clear();
  clear_has_mainproblem();
}
inline const ::protobuf::srl::school::subproblemInformation& SrlProblem::mainproblem() const {
  return mainproblem_ != NULL ? *mainproblem_ : *default_instance_->mainproblem_;
}
inline ::protobuf::srl::school::subproblemInformation* SrlProblem::mutable_mainproblem() {
  set_has_mainproblem();
  if (mainproblem_ == NULL) mainproblem_ = new ::protobuf::srl::school::subproblemInformation;
  return mainproblem_;
}
inline ::protobuf::srl::school::subproblemInformation* SrlProblem::release_mainproblem() {
  clear_has_mainproblem();
  ::protobuf::srl::school::subproblemInformation* temp = mainproblem_;
  mainproblem_ = NULL;
  return temp;
}
inline void SrlProblem::set_allocated_mainproblem(::protobuf::srl::school::subproblemInformation* mainproblem) {
  delete mainproblem_;
  mainproblem_ = mainproblem;
  if (mainproblem) {
    set_has_mainproblem();
  } else {
    clear_has_mainproblem();
  }
}

// repeated .protobuf.srl.school.subproblemInformation subProblems = 6;
inline int SrlProblem::subproblems_size() const {
  return subproblems_.size();
}
inline void SrlProblem::clear_subproblems() {
  subproblems_.Clear();
}
inline const ::protobuf::srl::school::subproblemInformation& SrlProblem::subproblems(int index) const {
  return subproblems_.Get(index);
}
inline ::protobuf::srl::school::subproblemInformation* SrlProblem::mutable_subproblems(int index) {
  return subproblems_.Mutable(index);
}
inline ::protobuf::srl::school::subproblemInformation* SrlProblem::add_subproblems() {
  return subproblems_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::subproblemInformation >&
SrlProblem::subproblems() const {
  return subproblems_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::subproblemInformation >*
SrlProblem::mutable_subproblems() {
  return &subproblems_;
}

// -------------------------------------------------------------------

// subproblemInformation

// optional string questionText = 1;
inline bool subproblemInformation::has_questiontext() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void subproblemInformation::set_has_questiontext() {
  _has_bits_[0] |= 0x00000001u;
}
inline void subproblemInformation::clear_has_questiontext() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void subproblemInformation::clear_questiontext() {
  if (questiontext_ != &::google::protobuf::internal::kEmptyString) {
    questiontext_->clear();
  }
  clear_has_questiontext();
}
inline const ::std::string& subproblemInformation::questiontext() const {
  return *questiontext_;
}
inline void subproblemInformation::set_questiontext(const ::std::string& value) {
  set_has_questiontext();
  if (questiontext_ == &::google::protobuf::internal::kEmptyString) {
    questiontext_ = new ::std::string;
  }
  questiontext_->assign(value);
}
inline void subproblemInformation::set_questiontext(const char* value) {
  set_has_questiontext();
  if (questiontext_ == &::google::protobuf::internal::kEmptyString) {
    questiontext_ = new ::std::string;
  }
  questiontext_->assign(value);
}
inline void subproblemInformation::set_questiontext(const char* value, size_t size) {
  set_has_questiontext();
  if (questiontext_ == &::google::protobuf::internal::kEmptyString) {
    questiontext_ = new ::std::string;
  }
  questiontext_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* subproblemInformation::mutable_questiontext() {
  set_has_questiontext();
  if (questiontext_ == &::google::protobuf::internal::kEmptyString) {
    questiontext_ = new ::std::string;
  }
  return questiontext_;
}
inline ::std::string* subproblemInformation::release_questiontext() {
  clear_has_questiontext();
  if (questiontext_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = questiontext_;
    questiontext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void subproblemInformation::set_allocated_questiontext(::std::string* questiontext) {
  if (questiontext_ != &::google::protobuf::internal::kEmptyString) {
    delete questiontext_;
  }
  if (questiontext) {
    set_has_questiontext();
    questiontext_ = questiontext;
  } else {
    clear_has_questiontext();
    questiontext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .protobuf.srl.school.subproblemInformation.QuestionType questionType = 2 [default = SKETCH];
inline bool subproblemInformation::has_questiontype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void subproblemInformation::set_has_questiontype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void subproblemInformation::clear_has_questiontype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void subproblemInformation::clear_questiontype() {
  questiontype_ = 1;
  clear_has_questiontype();
}
inline ::protobuf::srl::school::subproblemInformation_QuestionType subproblemInformation::questiontype() const {
  return static_cast< ::protobuf::srl::school::subproblemInformation_QuestionType >(questiontype_);
}
inline void subproblemInformation::set_questiontype(::protobuf::srl::school::subproblemInformation_QuestionType value) {
  assert(::protobuf::srl::school::subproblemInformation_QuestionType_IsValid(value));
  set_has_questiontype();
  questiontype_ = value;
}

// optional bytes options = 3;
inline bool subproblemInformation::has_options() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void subproblemInformation::set_has_options() {
  _has_bits_[0] |= 0x00000004u;
}
inline void subproblemInformation::clear_has_options() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void subproblemInformation::clear_options() {
  if (options_ != &::google::protobuf::internal::kEmptyString) {
    options_->clear();
  }
  clear_has_options();
}
inline const ::std::string& subproblemInformation::options() const {
  return *options_;
}
inline void subproblemInformation::set_options(const ::std::string& value) {
  set_has_options();
  if (options_ == &::google::protobuf::internal::kEmptyString) {
    options_ = new ::std::string;
  }
  options_->assign(value);
}
inline void subproblemInformation::set_options(const char* value) {
  set_has_options();
  if (options_ == &::google::protobuf::internal::kEmptyString) {
    options_ = new ::std::string;
  }
  options_->assign(value);
}
inline void subproblemInformation::set_options(const void* value, size_t size) {
  set_has_options();
  if (options_ == &::google::protobuf::internal::kEmptyString) {
    options_ = new ::std::string;
  }
  options_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* subproblemInformation::mutable_options() {
  set_has_options();
  if (options_ == &::google::protobuf::internal::kEmptyString) {
    options_ = new ::std::string;
  }
  return options_;
}
inline ::std::string* subproblemInformation::release_options() {
  clear_has_options();
  if (options_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = options_;
    options_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void subproblemInformation::set_allocated_options(::std::string* options) {
  if (options_ != &::google::protobuf::internal::kEmptyString) {
    delete options_;
  }
  if (options) {
    set_has_options();
    options_ = options;
  } else {
    clear_has_options();
    options_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace school
}  // namespace srl
}  // namespace protobuf

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protobuf::srl::school::subproblemInformation_QuestionType>() {
  return ::protobuf::srl::school::subproblemInformation_QuestionType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_input_2fschool_2eproto__INCLUDED
