// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: input/school.proto

#ifndef PROTOBUF_input_2fschool_2eproto__INCLUDED
#define PROTOBUF_input_2fschool_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf {
namespace srl {
namespace school {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_input_2fschool_2eproto();
void protobuf_AssignDesc_input_2fschool_2eproto();
void protobuf_ShutdownFile_input_2fschool_2eproto();

class SrlSchool;
class SrlCourse;
class SrlAssignment;
class SrlProblem;
class problemBankProblem;
class DateTime;
class DomainInformation;
class State;
class SrlUser;
class SrlGroup;
class SrlSchoolId;
class SrlPermission;

enum SrlCourse_Accessibility {
  SrlCourse_Accessibility_PUBLIC = 1,
  SrlCourse_Accessibility_PROTECTED = 2,
  SrlCourse_Accessibility_PROTECTED_NOSEARCH = 3,
  SrlCourse_Accessibility_PRIVATE = 4
};
bool SrlCourse_Accessibility_IsValid(int value);
const SrlCourse_Accessibility SrlCourse_Accessibility_Accessibility_MIN = SrlCourse_Accessibility_PUBLIC;
const SrlCourse_Accessibility SrlCourse_Accessibility_Accessibility_MAX = SrlCourse_Accessibility_PRIVATE;
const int SrlCourse_Accessibility_Accessibility_ARRAYSIZE = SrlCourse_Accessibility_Accessibility_MAX + 1;

const ::google::protobuf::EnumDescriptor* SrlCourse_Accessibility_descriptor();
inline const ::std::string& SrlCourse_Accessibility_Name(SrlCourse_Accessibility value) {
  return ::google::protobuf::internal::NameOfEnum(
    SrlCourse_Accessibility_descriptor(), value);
}
inline bool SrlCourse_Accessibility_Parse(
    const ::std::string& name, SrlCourse_Accessibility* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SrlCourse_Accessibility>(
    SrlCourse_Accessibility_descriptor(), name, value);
}
enum SrlAssignment_AssignmentType {
  SrlAssignment_AssignmentType_HOMEWORK = 1,
  SrlAssignment_AssignmentType_QUIZ = 2,
  SrlAssignment_AssignmentType_LAB = 3,
  SrlAssignment_AssignmentType_EXAM = 4,
  SrlAssignment_AssignmentType_SURVEY = 5,
  SrlAssignment_AssignmentType_OTHER = 6
};
bool SrlAssignment_AssignmentType_IsValid(int value);
const SrlAssignment_AssignmentType SrlAssignment_AssignmentType_AssignmentType_MIN = SrlAssignment_AssignmentType_HOMEWORK;
const SrlAssignment_AssignmentType SrlAssignment_AssignmentType_AssignmentType_MAX = SrlAssignment_AssignmentType_OTHER;
const int SrlAssignment_AssignmentType_AssignmentType_ARRAYSIZE = SrlAssignment_AssignmentType_AssignmentType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SrlAssignment_AssignmentType_descriptor();
inline const ::std::string& SrlAssignment_AssignmentType_Name(SrlAssignment_AssignmentType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SrlAssignment_AssignmentType_descriptor(), value);
}
inline bool SrlAssignment_AssignmentType_Parse(
    const ::std::string& name, SrlAssignment_AssignmentType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SrlAssignment_AssignmentType>(
    SrlAssignment_AssignmentType_descriptor(), name, value);
}
enum SrlAssignment_LatePolicy {
  SrlAssignment_LatePolicy_POLICY1 = 1,
  SrlAssignment_LatePolicy_POLICY2 = 2,
  SrlAssignment_LatePolicy_POLICY3 = 3
};
bool SrlAssignment_LatePolicy_IsValid(int value);
const SrlAssignment_LatePolicy SrlAssignment_LatePolicy_LatePolicy_MIN = SrlAssignment_LatePolicy_POLICY1;
const SrlAssignment_LatePolicy SrlAssignment_LatePolicy_LatePolicy_MAX = SrlAssignment_LatePolicy_POLICY3;
const int SrlAssignment_LatePolicy_LatePolicy_ARRAYSIZE = SrlAssignment_LatePolicy_LatePolicy_MAX + 1;

const ::google::protobuf::EnumDescriptor* SrlAssignment_LatePolicy_descriptor();
inline const ::std::string& SrlAssignment_LatePolicy_Name(SrlAssignment_LatePolicy value) {
  return ::google::protobuf::internal::NameOfEnum(
    SrlAssignment_LatePolicy_descriptor(), value);
}
inline bool SrlAssignment_LatePolicy_Parse(
    const ::std::string& name, SrlAssignment_LatePolicy* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SrlAssignment_LatePolicy>(
    SrlAssignment_LatePolicy_descriptor(), name, value);
}
enum problemBankProblem_QuestionType {
  problemBankProblem_QuestionType_SKETCH = 1,
  problemBankProblem_QuestionType_MULT_CHOICE = 2,
  problemBankProblem_QuestionType_FREE_RESP = 3,
  problemBankProblem_QuestionType_CHECK_BOX = 4
};
bool problemBankProblem_QuestionType_IsValid(int value);
const problemBankProblem_QuestionType problemBankProblem_QuestionType_QuestionType_MIN = problemBankProblem_QuestionType_SKETCH;
const problemBankProblem_QuestionType problemBankProblem_QuestionType_QuestionType_MAX = problemBankProblem_QuestionType_CHECK_BOX;
const int problemBankProblem_QuestionType_QuestionType_ARRAYSIZE = problemBankProblem_QuestionType_QuestionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* problemBankProblem_QuestionType_descriptor();
inline const ::std::string& problemBankProblem_QuestionType_Name(problemBankProblem_QuestionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    problemBankProblem_QuestionType_descriptor(), value);
}
inline bool problemBankProblem_QuestionType_Parse(
    const ::std::string& name, problemBankProblem_QuestionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<problemBankProblem_QuestionType>(
    problemBankProblem_QuestionType_descriptor(), name, value);
}
enum UserType {
  ADMIN = 1,
  INSTRUCTOR = 2,
  TEACHING_ASSISTANT = 3,
  STUDENT = 4,
  GUEST = 5
};
bool UserType_IsValid(int value);
const UserType UserType_MIN = ADMIN;
const UserType UserType_MAX = GUEST;
const int UserType_ARRAYSIZE = UserType_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserType_descriptor();
inline const ::std::string& UserType_Name(UserType value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserType_descriptor(), value);
}
inline bool UserType_Parse(
    const ::std::string& name, UserType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserType>(
    UserType_descriptor(), name, value);
}
// ===================================================================

class SrlSchool : public ::google::protobuf::Message {
 public:
  SrlSchool();
  virtual ~SrlSchool();

  SrlSchool(const SrlSchool& from);

  inline SrlSchool& operator=(const SrlSchool& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SrlSchool& default_instance();

  void Swap(SrlSchool* other);

  // implements Message ----------------------------------------------

  SrlSchool* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SrlSchool& from);
  void MergeFrom(const SrlSchool& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protobuf.srl.school.SrlCourse courses = 1;
  inline int courses_size() const;
  inline void clear_courses();
  static const int kCoursesFieldNumber = 1;
  inline const ::protobuf::srl::school::SrlCourse& courses(int index) const;
  inline ::protobuf::srl::school::SrlCourse* mutable_courses(int index);
  inline ::protobuf::srl::school::SrlCourse* add_courses();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlCourse >&
      courses() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlCourse >*
      mutable_courses();

  // repeated .protobuf.srl.school.SrlAssignment assignments = 2;
  inline int assignments_size() const;
  inline void clear_assignments();
  static const int kAssignmentsFieldNumber = 2;
  inline const ::protobuf::srl::school::SrlAssignment& assignments(int index) const;
  inline ::protobuf::srl::school::SrlAssignment* mutable_assignments(int index);
  inline ::protobuf::srl::school::SrlAssignment* add_assignments();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlAssignment >&
      assignments() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlAssignment >*
      mutable_assignments();

  // repeated .protobuf.srl.school.SrlProblem problems = 3;
  inline int problems_size() const;
  inline void clear_problems();
  static const int kProblemsFieldNumber = 3;
  inline const ::protobuf::srl::school::SrlProblem& problems(int index) const;
  inline ::protobuf::srl::school::SrlProblem* mutable_problems(int index);
  inline ::protobuf::srl::school::SrlProblem* add_problems();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlProblem >&
      problems() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlProblem >*
      mutable_problems();

  // @@protoc_insertion_point(class_scope:protobuf.srl.school.SrlSchool)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlCourse > courses_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlAssignment > assignments_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlProblem > problems_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_input_2fschool_2eproto();
  friend void protobuf_AssignDesc_input_2fschool_2eproto();
  friend void protobuf_ShutdownFile_input_2fschool_2eproto();

  void InitAsDefaultInstance();
  static SrlSchool* default_instance_;
};
// -------------------------------------------------------------------

class SrlCourse : public ::google::protobuf::Message {
 public:
  SrlCourse();
  virtual ~SrlCourse();

  SrlCourse(const SrlCourse& from);

  inline SrlCourse& operator=(const SrlCourse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SrlCourse& default_instance();

  void Swap(SrlCourse* other);

  // implements Message ----------------------------------------------

  SrlCourse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SrlCourse& from);
  void MergeFrom(const SrlCourse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SrlCourse_Accessibility Accessibility;
  static const Accessibility PUBLIC = SrlCourse_Accessibility_PUBLIC;
  static const Accessibility PROTECTED = SrlCourse_Accessibility_PROTECTED;
  static const Accessibility PROTECTED_NOSEARCH = SrlCourse_Accessibility_PROTECTED_NOSEARCH;
  static const Accessibility PRIVATE = SrlCourse_Accessibility_PRIVATE;
  static inline bool Accessibility_IsValid(int value) {
    return SrlCourse_Accessibility_IsValid(value);
  }
  static const Accessibility Accessibility_MIN =
    SrlCourse_Accessibility_Accessibility_MIN;
  static const Accessibility Accessibility_MAX =
    SrlCourse_Accessibility_Accessibility_MAX;
  static const int Accessibility_ARRAYSIZE =
    SrlCourse_Accessibility_Accessibility_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Accessibility_descriptor() {
    return SrlCourse_Accessibility_descriptor();
  }
  static inline const ::std::string& Accessibility_Name(Accessibility value) {
    return SrlCourse_Accessibility_Name(value);
  }
  static inline bool Accessibility_Parse(const ::std::string& name,
      Accessibility* value) {
    return SrlCourse_Accessibility_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .protobuf.srl.school.SrlPermission accessPermission = 3;
  inline bool has_accesspermission() const;
  inline void clear_accesspermission();
  static const int kAccessPermissionFieldNumber = 3;
  inline const ::protobuf::srl::school::SrlPermission& accesspermission() const;
  inline ::protobuf::srl::school::SrlPermission* mutable_accesspermission();
  inline ::protobuf::srl::school::SrlPermission* release_accesspermission();
  inline void set_allocated_accesspermission(::protobuf::srl::school::SrlPermission* accesspermission);

  // optional .protobuf.srl.school.SrlCourse.Accessibility access = 4 [default = PROTECTED];
  inline bool has_access() const;
  inline void clear_access();
  static const int kAccessFieldNumber = 4;
  inline ::protobuf::srl::school::SrlCourse_Accessibility access() const;
  inline void set_access(::protobuf::srl::school::SrlCourse_Accessibility value);

  // optional string description = 5;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 5;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // optional string semester = 6;
  inline bool has_semester() const;
  inline void clear_semester();
  static const int kSemesterFieldNumber = 6;
  inline const ::std::string& semester() const;
  inline void set_semester(const ::std::string& value);
  inline void set_semester(const char* value);
  inline void set_semester(const char* value, size_t size);
  inline ::std::string* mutable_semester();
  inline ::std::string* release_semester();
  inline void set_allocated_semester(::std::string* semester);

  // optional string imageUrl = 7;
  inline bool has_imageurl() const;
  inline void clear_imageurl();
  static const int kImageUrlFieldNumber = 7;
  inline const ::std::string& imageurl() const;
  inline void set_imageurl(const ::std::string& value);
  inline void set_imageurl(const char* value);
  inline void set_imageurl(const char* value, size_t size);
  inline ::std::string* mutable_imageurl();
  inline ::std::string* release_imageurl();
  inline void set_allocated_imageurl(::std::string* imageurl);

  // optional float grade = 8;
  inline bool has_grade() const;
  inline void clear_grade();
  static const int kGradeFieldNumber = 8;
  inline float grade() const;
  inline void set_grade(float value);

  // optional .protobuf.srl.school.DateTime accessDate = 9;
  inline bool has_accessdate() const;
  inline void clear_accessdate();
  static const int kAccessDateFieldNumber = 9;
  inline const ::protobuf::srl::school::DateTime& accessdate() const;
  inline ::protobuf::srl::school::DateTime* mutable_accessdate();
  inline ::protobuf::srl::school::DateTime* release_accessdate();
  inline void set_allocated_accessdate(::protobuf::srl::school::DateTime* accessdate);

  // optional .protobuf.srl.school.DateTime closeDate = 10;
  inline bool has_closedate() const;
  inline void clear_closedate();
  static const int kCloseDateFieldNumber = 10;
  inline const ::protobuf::srl::school::DateTime& closedate() const;
  inline ::protobuf::srl::school::DateTime* mutable_closedate();
  inline ::protobuf::srl::school::DateTime* release_closedate();
  inline void set_allocated_closedate(::protobuf::srl::school::DateTime* closedate);

  // optional .protobuf.srl.school.State state = 11;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 11;
  inline const ::protobuf::srl::school::State& state() const;
  inline ::protobuf::srl::school::State* mutable_state();
  inline ::protobuf::srl::school::State* release_state();
  inline void set_allocated_state(::protobuf::srl::school::State* state);

  // repeated string assignmentList = 12;
  inline int assignmentlist_size() const;
  inline void clear_assignmentlist();
  static const int kAssignmentListFieldNumber = 12;
  inline const ::std::string& assignmentlist(int index) const;
  inline ::std::string* mutable_assignmentlist(int index);
  inline void set_assignmentlist(int index, const ::std::string& value);
  inline void set_assignmentlist(int index, const char* value);
  inline void set_assignmentlist(int index, const char* value, size_t size);
  inline ::std::string* add_assignmentlist();
  inline void add_assignmentlist(const ::std::string& value);
  inline void add_assignmentlist(const char* value);
  inline void add_assignmentlist(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& assignmentlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_assignmentlist();

  // @@protoc_insertion_point(class_scope:protobuf.srl.school.SrlCourse)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_accesspermission();
  inline void clear_has_accesspermission();
  inline void set_has_access();
  inline void clear_has_access();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_semester();
  inline void clear_has_semester();
  inline void set_has_imageurl();
  inline void clear_has_imageurl();
  inline void set_has_grade();
  inline void clear_has_grade();
  inline void set_has_accessdate();
  inline void clear_has_accessdate();
  inline void set_has_closedate();
  inline void clear_has_closedate();
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* name_;
  ::protobuf::srl::school::SrlPermission* accesspermission_;
  ::std::string* description_;
  ::std::string* semester_;
  int access_;
  float grade_;
  ::std::string* imageurl_;
  ::protobuf::srl::school::DateTime* accessdate_;
  ::protobuf::srl::school::DateTime* closedate_;
  ::protobuf::srl::school::State* state_;
  ::google::protobuf::RepeatedPtrField< ::std::string> assignmentlist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_input_2fschool_2eproto();
  friend void protobuf_AssignDesc_input_2fschool_2eproto();
  friend void protobuf_ShutdownFile_input_2fschool_2eproto();

  void InitAsDefaultInstance();
  static SrlCourse* default_instance_;
};
// -------------------------------------------------------------------

class SrlAssignment : public ::google::protobuf::Message {
 public:
  SrlAssignment();
  virtual ~SrlAssignment();

  SrlAssignment(const SrlAssignment& from);

  inline SrlAssignment& operator=(const SrlAssignment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SrlAssignment& default_instance();

  void Swap(SrlAssignment* other);

  // implements Message ----------------------------------------------

  SrlAssignment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SrlAssignment& from);
  void MergeFrom(const SrlAssignment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SrlAssignment_AssignmentType AssignmentType;
  static const AssignmentType HOMEWORK = SrlAssignment_AssignmentType_HOMEWORK;
  static const AssignmentType QUIZ = SrlAssignment_AssignmentType_QUIZ;
  static const AssignmentType LAB = SrlAssignment_AssignmentType_LAB;
  static const AssignmentType EXAM = SrlAssignment_AssignmentType_EXAM;
  static const AssignmentType SURVEY = SrlAssignment_AssignmentType_SURVEY;
  static const AssignmentType OTHER = SrlAssignment_AssignmentType_OTHER;
  static inline bool AssignmentType_IsValid(int value) {
    return SrlAssignment_AssignmentType_IsValid(value);
  }
  static const AssignmentType AssignmentType_MIN =
    SrlAssignment_AssignmentType_AssignmentType_MIN;
  static const AssignmentType AssignmentType_MAX =
    SrlAssignment_AssignmentType_AssignmentType_MAX;
  static const int AssignmentType_ARRAYSIZE =
    SrlAssignment_AssignmentType_AssignmentType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  AssignmentType_descriptor() {
    return SrlAssignment_AssignmentType_descriptor();
  }
  static inline const ::std::string& AssignmentType_Name(AssignmentType value) {
    return SrlAssignment_AssignmentType_Name(value);
  }
  static inline bool AssignmentType_Parse(const ::std::string& name,
      AssignmentType* value) {
    return SrlAssignment_AssignmentType_Parse(name, value);
  }

  typedef SrlAssignment_LatePolicy LatePolicy;
  static const LatePolicy POLICY1 = SrlAssignment_LatePolicy_POLICY1;
  static const LatePolicy POLICY2 = SrlAssignment_LatePolicy_POLICY2;
  static const LatePolicy POLICY3 = SrlAssignment_LatePolicy_POLICY3;
  static inline bool LatePolicy_IsValid(int value) {
    return SrlAssignment_LatePolicy_IsValid(value);
  }
  static const LatePolicy LatePolicy_MIN =
    SrlAssignment_LatePolicy_LatePolicy_MIN;
  static const LatePolicy LatePolicy_MAX =
    SrlAssignment_LatePolicy_LatePolicy_MAX;
  static const int LatePolicy_ARRAYSIZE =
    SrlAssignment_LatePolicy_LatePolicy_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LatePolicy_descriptor() {
    return SrlAssignment_LatePolicy_descriptor();
  }
  static inline const ::std::string& LatePolicy_Name(LatePolicy value) {
    return SrlAssignment_LatePolicy_Name(value);
  }
  static inline bool LatePolicy_Parse(const ::std::string& name,
      LatePolicy* value) {
    return SrlAssignment_LatePolicy_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string courseId = 1;
  inline bool has_courseid() const;
  inline void clear_courseid();
  static const int kCourseIdFieldNumber = 1;
  inline const ::std::string& courseid() const;
  inline void set_courseid(const ::std::string& value);
  inline void set_courseid(const char* value);
  inline void set_courseid(const char* value, size_t size);
  inline ::std::string* mutable_courseid();
  inline ::std::string* release_courseid();
  inline void set_allocated_courseid(::std::string* courseid);

  // required string id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .protobuf.srl.school.SrlAssignment.AssignmentType type = 4 [default = HOMEWORK];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline ::protobuf::srl::school::SrlAssignment_AssignmentType type() const;
  inline void set_type(::protobuf::srl::school::SrlAssignment_AssignmentType value);

  // optional string other = 5;
  inline bool has_other() const;
  inline void clear_other();
  static const int kOtherFieldNumber = 5;
  inline const ::std::string& other() const;
  inline void set_other(const ::std::string& value);
  inline void set_other(const char* value);
  inline void set_other(const char* value, size_t size);
  inline ::std::string* mutable_other();
  inline ::std::string* release_other();
  inline void set_allocated_other(::std::string* other);

  // optional string description = 6;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 6;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // repeated string links = 7;
  inline int links_size() const;
  inline void clear_links();
  static const int kLinksFieldNumber = 7;
  inline const ::std::string& links(int index) const;
  inline ::std::string* mutable_links(int index);
  inline void set_links(int index, const ::std::string& value);
  inline void set_links(int index, const char* value);
  inline void set_links(int index, const char* value, size_t size);
  inline ::std::string* add_links();
  inline void add_links(const ::std::string& value);
  inline void add_links(const char* value);
  inline void add_links(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& links() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_links();

  // optional .protobuf.srl.school.SrlAssignment.LatePolicy latePolicy = 8 [default = POLICY1];
  inline bool has_latepolicy() const;
  inline void clear_latepolicy();
  static const int kLatePolicyFieldNumber = 8;
  inline ::protobuf::srl::school::SrlAssignment_LatePolicy latepolicy() const;
  inline void set_latepolicy(::protobuf::srl::school::SrlAssignment_LatePolicy value);

  // optional string gradeWeight = 9;
  inline bool has_gradeweight() const;
  inline void clear_gradeweight();
  static const int kGradeWeightFieldNumber = 9;
  inline const ::std::string& gradeweight() const;
  inline void set_gradeweight(const ::std::string& value);
  inline void set_gradeweight(const char* value);
  inline void set_gradeweight(const char* value, size_t size);
  inline ::std::string* mutable_gradeweight();
  inline ::std::string* release_gradeweight();
  inline void set_allocated_gradeweight(::std::string* gradeweight);

  // optional float grade = 10;
  inline bool has_grade() const;
  inline void clear_grade();
  static const int kGradeFieldNumber = 10;
  inline float grade() const;
  inline void set_grade(float value);

  // optional .protobuf.srl.school.DateTime accessDate = 11;
  inline bool has_accessdate() const;
  inline void clear_accessdate();
  static const int kAccessDateFieldNumber = 11;
  inline const ::protobuf::srl::school::DateTime& accessdate() const;
  inline ::protobuf::srl::school::DateTime* mutable_accessdate();
  inline ::protobuf::srl::school::DateTime* release_accessdate();
  inline void set_allocated_accessdate(::protobuf::srl::school::DateTime* accessdate);

  // optional .protobuf.srl.school.DateTime dueDate = 12;
  inline bool has_duedate() const;
  inline void clear_duedate();
  static const int kDueDateFieldNumber = 12;
  inline const ::protobuf::srl::school::DateTime& duedate() const;
  inline ::protobuf::srl::school::DateTime* mutable_duedate();
  inline ::protobuf::srl::school::DateTime* release_duedate();
  inline void set_allocated_duedate(::protobuf::srl::school::DateTime* duedate);

  // optional .protobuf.srl.school.DateTime closeDate = 13;
  inline bool has_closedate() const;
  inline void clear_closedate();
  static const int kCloseDateFieldNumber = 13;
  inline const ::protobuf::srl::school::DateTime& closedate() const;
  inline ::protobuf::srl::school::DateTime* mutable_closedate();
  inline ::protobuf::srl::school::DateTime* release_closedate();
  inline void set_allocated_closedate(::protobuf::srl::school::DateTime* closedate);

  // optional .protobuf.srl.school.State state = 14;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 14;
  inline const ::protobuf::srl::school::State& state() const;
  inline ::protobuf::srl::school::State* mutable_state();
  inline ::protobuf::srl::school::State* release_state();
  inline void set_allocated_state(::protobuf::srl::school::State* state);

  // optional string imageUrl = 15;
  inline bool has_imageurl() const;
  inline void clear_imageurl();
  static const int kImageUrlFieldNumber = 15;
  inline const ::std::string& imageurl() const;
  inline void set_imageurl(const ::std::string& value);
  inline void set_imageurl(const char* value);
  inline void set_imageurl(const char* value, size_t size);
  inline ::std::string* mutable_imageurl();
  inline ::std::string* release_imageurl();
  inline void set_allocated_imageurl(::std::string* imageurl);

  // repeated string problemList = 16;
  inline int problemlist_size() const;
  inline void clear_problemlist();
  static const int kProblemListFieldNumber = 16;
  inline const ::std::string& problemlist(int index) const;
  inline ::std::string* mutable_problemlist(int index);
  inline void set_problemlist(int index, const ::std::string& value);
  inline void set_problemlist(int index, const char* value);
  inline void set_problemlist(int index, const char* value, size_t size);
  inline ::std::string* add_problemlist();
  inline void add_problemlist(const ::std::string& value);
  inline void add_problemlist(const char* value);
  inline void add_problemlist(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& problemlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_problemlist();

  // optional .protobuf.srl.school.SrlPermission accessPermission = 17;
  inline bool has_accesspermission() const;
  inline void clear_accesspermission();
  static const int kAccessPermissionFieldNumber = 17;
  inline const ::protobuf::srl::school::SrlPermission& accesspermission() const;
  inline ::protobuf::srl::school::SrlPermission* mutable_accesspermission();
  inline ::protobuf::srl::school::SrlPermission* release_accesspermission();
  inline void set_allocated_accesspermission(::protobuf::srl::school::SrlPermission* accesspermission);

  // @@protoc_insertion_point(class_scope:protobuf.srl.school.SrlAssignment)
 private:
  inline void set_has_courseid();
  inline void clear_has_courseid();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_other();
  inline void clear_has_other();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_latepolicy();
  inline void clear_has_latepolicy();
  inline void set_has_gradeweight();
  inline void clear_has_gradeweight();
  inline void set_has_grade();
  inline void clear_has_grade();
  inline void set_has_accessdate();
  inline void clear_has_accessdate();
  inline void set_has_duedate();
  inline void clear_has_duedate();
  inline void set_has_closedate();
  inline void clear_has_closedate();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_imageurl();
  inline void clear_has_imageurl();
  inline void set_has_accesspermission();
  inline void clear_has_accesspermission();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* courseid_;
  ::std::string* id_;
  ::std::string* name_;
  ::std::string* other_;
  ::std::string* description_;
  int type_;
  int latepolicy_;
  ::google::protobuf::RepeatedPtrField< ::std::string> links_;
  ::std::string* gradeweight_;
  ::protobuf::srl::school::DateTime* accessdate_;
  ::protobuf::srl::school::DateTime* duedate_;
  ::protobuf::srl::school::DateTime* closedate_;
  ::protobuf::srl::school::State* state_;
  ::std::string* imageurl_;
  ::google::protobuf::RepeatedPtrField< ::std::string> problemlist_;
  ::protobuf::srl::school::SrlPermission* accesspermission_;
  float grade_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(17 + 31) / 32];

  friend void  protobuf_AddDesc_input_2fschool_2eproto();
  friend void protobuf_AssignDesc_input_2fschool_2eproto();
  friend void protobuf_ShutdownFile_input_2fschool_2eproto();

  void InitAsDefaultInstance();
  static SrlAssignment* default_instance_;
};
// -------------------------------------------------------------------

class SrlProblem : public ::google::protobuf::Message {
 public:
  SrlProblem();
  virtual ~SrlProblem();

  SrlProblem(const SrlProblem& from);

  inline SrlProblem& operator=(const SrlProblem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SrlProblem& default_instance();

  void Swap(SrlProblem* other);

  // implements Message ----------------------------------------------

  SrlProblem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SrlProblem& from);
  void MergeFrom(const SrlProblem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string courseId = 2;
  inline bool has_courseid() const;
  inline void clear_courseid();
  static const int kCourseIdFieldNumber = 2;
  inline const ::std::string& courseid() const;
  inline void set_courseid(const ::std::string& value);
  inline void set_courseid(const char* value);
  inline void set_courseid(const char* value, size_t size);
  inline ::std::string* mutable_courseid();
  inline ::std::string* release_courseid();
  inline void set_allocated_courseid(::std::string* courseid);

  // optional string assignmentId = 3;
  inline bool has_assignmentid() const;
  inline void clear_assignmentid();
  static const int kAssignmentIdFieldNumber = 3;
  inline const ::std::string& assignmentid() const;
  inline void set_assignmentid(const ::std::string& value);
  inline void set_assignmentid(const char* value);
  inline void set_assignmentid(const char* value, size_t size);
  inline ::std::string* mutable_assignmentid();
  inline ::std::string* release_assignmentid();
  inline void set_allocated_assignmentid(::std::string* assignmentid);

  // optional string problemBankId = 4;
  inline bool has_problembankid() const;
  inline void clear_problembankid();
  static const int kProblemBankIdFieldNumber = 4;
  inline const ::std::string& problembankid() const;
  inline void set_problembankid(const ::std::string& value);
  inline void set_problembankid(const char* value);
  inline void set_problembankid(const char* value, size_t size);
  inline ::std::string* mutable_problembankid();
  inline ::std::string* release_problembankid();
  inline void set_allocated_problembankid(::std::string* problembankid);

  // optional string name = 5;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 5;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string description = 6;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 6;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // optional .protobuf.srl.school.problemBankProblem problemInfo = 7;
  inline bool has_probleminfo() const;
  inline void clear_probleminfo();
  static const int kProblemInfoFieldNumber = 7;
  inline const ::protobuf::srl::school::problemBankProblem& probleminfo() const;
  inline ::protobuf::srl::school::problemBankProblem* mutable_probleminfo();
  inline ::protobuf::srl::school::problemBankProblem* release_probleminfo();
  inline void set_allocated_probleminfo(::protobuf::srl::school::problemBankProblem* probleminfo);

  // repeated .protobuf.srl.school.DomainInformation info = 8;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 8;
  inline const ::protobuf::srl::school::DomainInformation& info(int index) const;
  inline ::protobuf::srl::school::DomainInformation* mutable_info(int index);
  inline ::protobuf::srl::school::DomainInformation* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::DomainInformation >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::DomainInformation >*
      mutable_info();

  // optional string gradeWeight = 9;
  inline bool has_gradeweight() const;
  inline void clear_gradeweight();
  static const int kGradeWeightFieldNumber = 9;
  inline const ::std::string& gradeweight() const;
  inline void set_gradeweight(const ::std::string& value);
  inline void set_gradeweight(const char* value);
  inline void set_gradeweight(const char* value, size_t size);
  inline ::std::string* mutable_gradeweight();
  inline ::std::string* release_gradeweight();
  inline void set_allocated_gradeweight(::std::string* gradeweight);

  // optional float grade = 10;
  inline bool has_grade() const;
  inline void clear_grade();
  static const int kGradeFieldNumber = 10;
  inline float grade() const;
  inline void set_grade(float value);

  // optional .protobuf.srl.school.State state = 11;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 11;
  inline const ::protobuf::srl::school::State& state() const;
  inline ::protobuf::srl::school::State* mutable_state();
  inline ::protobuf::srl::school::State* release_state();
  inline void set_allocated_state(::protobuf::srl::school::State* state);

  // optional .protobuf.srl.school.SrlPermission accessPermission = 12;
  inline bool has_accesspermission() const;
  inline void clear_accesspermission();
  static const int kAccessPermissionFieldNumber = 12;
  inline const ::protobuf::srl::school::SrlPermission& accesspermission() const;
  inline ::protobuf::srl::school::SrlPermission* mutable_accesspermission();
  inline ::protobuf::srl::school::SrlPermission* release_accesspermission();
  inline void set_allocated_accesspermission(::protobuf::srl::school::SrlPermission* accesspermission);

  // @@protoc_insertion_point(class_scope:protobuf.srl.school.SrlProblem)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_courseid();
  inline void clear_has_courseid();
  inline void set_has_assignmentid();
  inline void clear_has_assignmentid();
  inline void set_has_problembankid();
  inline void clear_has_problembankid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_probleminfo();
  inline void clear_has_probleminfo();
  inline void set_has_gradeweight();
  inline void clear_has_gradeweight();
  inline void set_has_grade();
  inline void clear_has_grade();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_accesspermission();
  inline void clear_has_accesspermission();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* courseid_;
  ::std::string* assignmentid_;
  ::std::string* problembankid_;
  ::std::string* name_;
  ::std::string* description_;
  ::protobuf::srl::school::problemBankProblem* probleminfo_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::DomainInformation > info_;
  ::std::string* gradeweight_;
  ::protobuf::srl::school::State* state_;
  ::protobuf::srl::school::SrlPermission* accesspermission_;
  float grade_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_input_2fschool_2eproto();
  friend void protobuf_AssignDesc_input_2fschool_2eproto();
  friend void protobuf_ShutdownFile_input_2fschool_2eproto();

  void InitAsDefaultInstance();
  static SrlProblem* default_instance_;
};
// -------------------------------------------------------------------

class problemBankProblem : public ::google::protobuf::Message {
 public:
  problemBankProblem();
  virtual ~problemBankProblem();

  problemBankProblem(const problemBankProblem& from);

  inline problemBankProblem& operator=(const problemBankProblem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const problemBankProblem& default_instance();

  void Swap(problemBankProblem* other);

  // implements Message ----------------------------------------------

  problemBankProblem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const problemBankProblem& from);
  void MergeFrom(const problemBankProblem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef problemBankProblem_QuestionType QuestionType;
  static const QuestionType SKETCH = problemBankProblem_QuestionType_SKETCH;
  static const QuestionType MULT_CHOICE = problemBankProblem_QuestionType_MULT_CHOICE;
  static const QuestionType FREE_RESP = problemBankProblem_QuestionType_FREE_RESP;
  static const QuestionType CHECK_BOX = problemBankProblem_QuestionType_CHECK_BOX;
  static inline bool QuestionType_IsValid(int value) {
    return problemBankProblem_QuestionType_IsValid(value);
  }
  static const QuestionType QuestionType_MIN =
    problemBankProblem_QuestionType_QuestionType_MIN;
  static const QuestionType QuestionType_MAX =
    problemBankProblem_QuestionType_QuestionType_MAX;
  static const int QuestionType_ARRAYSIZE =
    problemBankProblem_QuestionType_QuestionType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  QuestionType_descriptor() {
    return problemBankProblem_QuestionType_descriptor();
  }
  static inline const ::std::string& QuestionType_Name(QuestionType value) {
    return problemBankProblem_QuestionType_Name(value);
  }
  static inline bool QuestionType_Parse(const ::std::string& name,
      QuestionType* value) {
    return problemBankProblem_QuestionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string questionText = 2;
  inline bool has_questiontext() const;
  inline void clear_questiontext();
  static const int kQuestionTextFieldNumber = 2;
  inline const ::std::string& questiontext() const;
  inline void set_questiontext(const ::std::string& value);
  inline void set_questiontext(const char* value);
  inline void set_questiontext(const char* value, size_t size);
  inline ::std::string* mutable_questiontext();
  inline ::std::string* release_questiontext();
  inline void set_allocated_questiontext(::std::string* questiontext);

  // optional .protobuf.srl.school.problemBankProblem.QuestionType questionType = 3 [default = SKETCH];
  inline bool has_questiontype() const;
  inline void clear_questiontype();
  static const int kQuestionTypeFieldNumber = 3;
  inline ::protobuf::srl::school::problemBankProblem_QuestionType questiontype() const;
  inline void set_questiontype(::protobuf::srl::school::problemBankProblem_QuestionType value);

  // optional bytes options = 4;
  inline bool has_options() const;
  inline void clear_options();
  static const int kOptionsFieldNumber = 4;
  inline const ::std::string& options() const;
  inline void set_options(const ::std::string& value);
  inline void set_options(const char* value);
  inline void set_options(const void* value, size_t size);
  inline ::std::string* mutable_options();
  inline ::std::string* release_options();
  inline void set_allocated_options(::std::string* options);

  // optional .protobuf.srl.school.SrlPermission accessPermission = 5;
  inline bool has_accesspermission() const;
  inline void clear_accesspermission();
  static const int kAccessPermissionFieldNumber = 5;
  inline const ::protobuf::srl::school::SrlPermission& accesspermission() const;
  inline ::protobuf::srl::school::SrlPermission* mutable_accesspermission();
  inline ::protobuf::srl::school::SrlPermission* release_accesspermission();
  inline void set_allocated_accesspermission(::protobuf::srl::school::SrlPermission* accesspermission);

  // @@protoc_insertion_point(class_scope:protobuf.srl.school.problemBankProblem)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_questiontext();
  inline void clear_has_questiontext();
  inline void set_has_questiontype();
  inline void clear_has_questiontype();
  inline void set_has_options();
  inline void clear_has_options();
  inline void set_has_accesspermission();
  inline void clear_has_accesspermission();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* questiontext_;
  ::std::string* options_;
  ::protobuf::srl::school::SrlPermission* accesspermission_;
  int questiontype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_input_2fschool_2eproto();
  friend void protobuf_AssignDesc_input_2fschool_2eproto();
  friend void protobuf_ShutdownFile_input_2fschool_2eproto();

  void InitAsDefaultInstance();
  static problemBankProblem* default_instance_;
};
// -------------------------------------------------------------------

class DateTime : public ::google::protobuf::Message {
 public:
  DateTime();
  virtual ~DateTime();

  DateTime(const DateTime& from);

  inline DateTime& operator=(const DateTime& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DateTime& default_instance();

  void Swap(DateTime* other);

  // implements Message ----------------------------------------------

  DateTime* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DateTime& from);
  void MergeFrom(const DateTime& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 year = 1;
  inline bool has_year() const;
  inline void clear_year();
  static const int kYearFieldNumber = 1;
  inline ::google::protobuf::int32 year() const;
  inline void set_year(::google::protobuf::int32 value);

  // optional int32 month = 2;
  inline bool has_month() const;
  inline void clear_month();
  static const int kMonthFieldNumber = 2;
  inline ::google::protobuf::int32 month() const;
  inline void set_month(::google::protobuf::int32 value);

  // optional int32 day = 3;
  inline bool has_day() const;
  inline void clear_day();
  static const int kDayFieldNumber = 3;
  inline ::google::protobuf::int32 day() const;
  inline void set_day(::google::protobuf::int32 value);

  // optional int32 hour = 4;
  inline bool has_hour() const;
  inline void clear_hour();
  static const int kHourFieldNumber = 4;
  inline ::google::protobuf::int32 hour() const;
  inline void set_hour(::google::protobuf::int32 value);

  // optional int32 minute = 5;
  inline bool has_minute() const;
  inline void clear_minute();
  static const int kMinuteFieldNumber = 5;
  inline ::google::protobuf::int32 minute() const;
  inline void set_minute(::google::protobuf::int32 value);

  // optional int32 second = 6;
  inline bool has_second() const;
  inline void clear_second();
  static const int kSecondFieldNumber = 6;
  inline ::google::protobuf::int32 second() const;
  inline void set_second(::google::protobuf::int32 value);

  // optional uint64 millisecond = 7;
  inline bool has_millisecond() const;
  inline void clear_millisecond();
  static const int kMillisecondFieldNumber = 7;
  inline ::google::protobuf::uint64 millisecond() const;
  inline void set_millisecond(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:protobuf.srl.school.DateTime)
 private:
  inline void set_has_year();
  inline void clear_has_year();
  inline void set_has_month();
  inline void clear_has_month();
  inline void set_has_day();
  inline void clear_has_day();
  inline void set_has_hour();
  inline void clear_has_hour();
  inline void set_has_minute();
  inline void clear_has_minute();
  inline void set_has_second();
  inline void clear_has_second();
  inline void set_has_millisecond();
  inline void clear_has_millisecond();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 year_;
  ::google::protobuf::int32 month_;
  ::google::protobuf::int32 day_;
  ::google::protobuf::int32 hour_;
  ::google::protobuf::int32 minute_;
  ::google::protobuf::int32 second_;
  ::google::protobuf::uint64 millisecond_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_input_2fschool_2eproto();
  friend void protobuf_AssignDesc_input_2fschool_2eproto();
  friend void protobuf_ShutdownFile_input_2fschool_2eproto();

  void InitAsDefaultInstance();
  static DateTime* default_instance_;
};
// -------------------------------------------------------------------

class DomainInformation : public ::google::protobuf::Message {
 public:
  DomainInformation();
  virtual ~DomainInformation();

  DomainInformation(const DomainInformation& from);

  inline DomainInformation& operator=(const DomainInformation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DomainInformation& default_instance();

  void Swap(DomainInformation* other);

  // implements Message ----------------------------------------------

  DomainInformation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DomainInformation& from);
  void MergeFrom(const DomainInformation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string stuff = 1;
  inline bool has_stuff() const;
  inline void clear_stuff();
  static const int kStuffFieldNumber = 1;
  inline const ::std::string& stuff() const;
  inline void set_stuff(const ::std::string& value);
  inline void set_stuff(const char* value);
  inline void set_stuff(const char* value, size_t size);
  inline ::std::string* mutable_stuff();
  inline ::std::string* release_stuff();
  inline void set_allocated_stuff(::std::string* stuff);

  // @@protoc_insertion_point(class_scope:protobuf.srl.school.DomainInformation)
 private:
  inline void set_has_stuff();
  inline void clear_has_stuff();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* stuff_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_input_2fschool_2eproto();
  friend void protobuf_AssignDesc_input_2fschool_2eproto();
  friend void protobuf_ShutdownFile_input_2fschool_2eproto();

  void InitAsDefaultInstance();
  static DomainInformation* default_instance_;
};
// -------------------------------------------------------------------

class State : public ::google::protobuf::Message {
 public:
  State();
  virtual ~State();

  State(const State& from);

  inline State& operator=(const State& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const State& default_instance();

  void Swap(State* other);

  // implements Message ----------------------------------------------

  State* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const State& from);
  void MergeFrom(const State& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool published = 1;
  inline bool has_published() const;
  inline void clear_published();
  static const int kPublishedFieldNumber = 1;
  inline bool published() const;
  inline void set_published(bool value);

  // optional bool accessible = 2;
  inline bool has_accessible() const;
  inline void clear_accessible();
  static const int kAccessibleFieldNumber = 2;
  inline bool accessible() const;
  inline void set_accessible(bool value);

  // optional bool pastDue = 3;
  inline bool has_pastdue() const;
  inline void clear_pastdue();
  static const int kPastDueFieldNumber = 3;
  inline bool pastdue() const;
  inline void set_pastdue(bool value);

  // optional bool started = 4;
  inline bool has_started() const;
  inline void clear_started();
  static const int kStartedFieldNumber = 4;
  inline bool started() const;
  inline void set_started(bool value);

  // optional bool completed = 5;
  inline bool has_completed() const;
  inline void clear_completed();
  static const int kCompletedFieldNumber = 5;
  inline bool completed() const;
  inline void set_completed(bool value);

  // @@protoc_insertion_point(class_scope:protobuf.srl.school.State)
 private:
  inline void set_has_published();
  inline void clear_has_published();
  inline void set_has_accessible();
  inline void clear_has_accessible();
  inline void set_has_pastdue();
  inline void clear_has_pastdue();
  inline void set_has_started();
  inline void clear_has_started();
  inline void set_has_completed();
  inline void clear_has_completed();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool published_;
  bool accessible_;
  bool pastdue_;
  bool started_;
  bool completed_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_input_2fschool_2eproto();
  friend void protobuf_AssignDesc_input_2fschool_2eproto();
  friend void protobuf_ShutdownFile_input_2fschool_2eproto();

  void InitAsDefaultInstance();
  static State* default_instance_;
};
// -------------------------------------------------------------------

class SrlUser : public ::google::protobuf::Message {
 public:
  SrlUser();
  virtual ~SrlUser();

  SrlUser(const SrlUser& from);

  inline SrlUser& operator=(const SrlUser& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SrlUser& default_instance();

  void Swap(SrlUser* other);

  // implements Message ----------------------------------------------

  SrlUser* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SrlUser& from);
  void MergeFrom(const SrlUser& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string username = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // optional .protobuf.srl.school.UserType userType = 2 [default = GUEST];
  inline bool has_usertype() const;
  inline void clear_usertype();
  static const int kUserTypeFieldNumber = 2;
  inline ::protobuf::srl::school::UserType usertype() const;
  inline void set_usertype(::protobuf::srl::school::UserType value);

  // optional string email = 3;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 3;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // @@protoc_insertion_point(class_scope:protobuf.srl.school.SrlUser)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_usertype();
  inline void clear_has_usertype();
  inline void set_has_email();
  inline void clear_has_email();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* username_;
  ::std::string* email_;
  int usertype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_input_2fschool_2eproto();
  friend void protobuf_AssignDesc_input_2fschool_2eproto();
  friend void protobuf_ShutdownFile_input_2fschool_2eproto();

  void InitAsDefaultInstance();
  static SrlUser* default_instance_;
};
// -------------------------------------------------------------------

class SrlGroup : public ::google::protobuf::Message {
 public:
  SrlGroup();
  virtual ~SrlGroup();

  SrlGroup(const SrlGroup& from);

  inline SrlGroup& operator=(const SrlGroup& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SrlGroup& default_instance();

  void Swap(SrlGroup* other);

  // implements Message ----------------------------------------------

  SrlGroup* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SrlGroup& from);
  void MergeFrom(const SrlGroup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string userId = 1;
  inline int userid_size() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 1;
  inline const ::std::string& userid(int index) const;
  inline ::std::string* mutable_userid(int index);
  inline void set_userid(int index, const ::std::string& value);
  inline void set_userid(int index, const char* value);
  inline void set_userid(int index, const char* value, size_t size);
  inline ::std::string* add_userid();
  inline void add_userid(const ::std::string& value);
  inline void add_userid(const char* value);
  inline void add_userid(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& userid() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_userid();

  // required string groupId = 2;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupIdFieldNumber = 2;
  inline const ::std::string& groupid() const;
  inline void set_groupid(const ::std::string& value);
  inline void set_groupid(const char* value);
  inline void set_groupid(const char* value, size_t size);
  inline ::std::string* mutable_groupid();
  inline ::std::string* release_groupid();
  inline void set_allocated_groupid(::std::string* groupid);

  // optional string groupName = 3;
  inline bool has_groupname() const;
  inline void clear_groupname();
  static const int kGroupNameFieldNumber = 3;
  inline const ::std::string& groupname() const;
  inline void set_groupname(const ::std::string& value);
  inline void set_groupname(const char* value);
  inline void set_groupname(const char* value, size_t size);
  inline ::std::string* mutable_groupname();
  inline ::std::string* release_groupname();
  inline void set_allocated_groupname(::std::string* groupname);

  // @@protoc_insertion_point(class_scope:protobuf.srl.school.SrlGroup)
 private:
  inline void set_has_groupid();
  inline void clear_has_groupid();
  inline void set_has_groupname();
  inline void clear_has_groupname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> userid_;
  ::std::string* groupid_;
  ::std::string* groupname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_input_2fschool_2eproto();
  friend void protobuf_AssignDesc_input_2fschool_2eproto();
  friend void protobuf_ShutdownFile_input_2fschool_2eproto();

  void InitAsDefaultInstance();
  static SrlGroup* default_instance_;
};
// -------------------------------------------------------------------

class SrlSchoolId : public ::google::protobuf::Message {
 public:
  SrlSchoolId();
  virtual ~SrlSchoolId();

  SrlSchoolId(const SrlSchoolId& from);

  inline SrlSchoolId& operator=(const SrlSchoolId& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SrlSchoolId& default_instance();

  void Swap(SrlSchoolId* other);

  // implements Message ----------------------------------------------

  SrlSchoolId* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SrlSchoolId& from);
  void MergeFrom(const SrlSchoolId& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string courseId = 1;
  inline bool has_courseid() const;
  inline void clear_courseid();
  static const int kCourseIdFieldNumber = 1;
  inline const ::std::string& courseid() const;
  inline void set_courseid(const ::std::string& value);
  inline void set_courseid(const char* value);
  inline void set_courseid(const char* value, size_t size);
  inline ::std::string* mutable_courseid();
  inline ::std::string* release_courseid();
  inline void set_allocated_courseid(::std::string* courseid);

  // optional string assignmentId = 2;
  inline bool has_assignmentid() const;
  inline void clear_assignmentid();
  static const int kAssignmentIdFieldNumber = 2;
  inline const ::std::string& assignmentid() const;
  inline void set_assignmentid(const ::std::string& value);
  inline void set_assignmentid(const char* value);
  inline void set_assignmentid(const char* value, size_t size);
  inline ::std::string* mutable_assignmentid();
  inline ::std::string* release_assignmentid();
  inline void set_allocated_assignmentid(::std::string* assignmentid);

  // optional string problemId = 3;
  inline bool has_problemid() const;
  inline void clear_problemid();
  static const int kProblemIdFieldNumber = 3;
  inline const ::std::string& problemid() const;
  inline void set_problemid(const ::std::string& value);
  inline void set_problemid(const char* value);
  inline void set_problemid(const char* value, size_t size);
  inline ::std::string* mutable_problemid();
  inline ::std::string* release_problemid();
  inline void set_allocated_problemid(::std::string* problemid);

  // @@protoc_insertion_point(class_scope:protobuf.srl.school.SrlSchoolId)
 private:
  inline void set_has_courseid();
  inline void clear_has_courseid();
  inline void set_has_assignmentid();
  inline void clear_has_assignmentid();
  inline void set_has_problemid();
  inline void clear_has_problemid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* courseid_;
  ::std::string* assignmentid_;
  ::std::string* problemid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_input_2fschool_2eproto();
  friend void protobuf_AssignDesc_input_2fschool_2eproto();
  friend void protobuf_ShutdownFile_input_2fschool_2eproto();

  void InitAsDefaultInstance();
  static SrlSchoolId* default_instance_;
};
// -------------------------------------------------------------------

class SrlPermission : public ::google::protobuf::Message {
 public:
  SrlPermission();
  virtual ~SrlPermission();

  SrlPermission(const SrlPermission& from);

  inline SrlPermission& operator=(const SrlPermission& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SrlPermission& default_instance();

  void Swap(SrlPermission* other);

  // implements Message ----------------------------------------------

  SrlPermission* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SrlPermission& from);
  void MergeFrom(const SrlPermission& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string adminPermission = 1;
  inline int adminpermission_size() const;
  inline void clear_adminpermission();
  static const int kAdminPermissionFieldNumber = 1;
  inline const ::std::string& adminpermission(int index) const;
  inline ::std::string* mutable_adminpermission(int index);
  inline void set_adminpermission(int index, const ::std::string& value);
  inline void set_adminpermission(int index, const char* value);
  inline void set_adminpermission(int index, const char* value, size_t size);
  inline ::std::string* add_adminpermission();
  inline void add_adminpermission(const ::std::string& value);
  inline void add_adminpermission(const char* value);
  inline void add_adminpermission(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& adminpermission() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_adminpermission();

  // repeated string moderatorPermission = 2;
  inline int moderatorpermission_size() const;
  inline void clear_moderatorpermission();
  static const int kModeratorPermissionFieldNumber = 2;
  inline const ::std::string& moderatorpermission(int index) const;
  inline ::std::string* mutable_moderatorpermission(int index);
  inline void set_moderatorpermission(int index, const ::std::string& value);
  inline void set_moderatorpermission(int index, const char* value);
  inline void set_moderatorpermission(int index, const char* value, size_t size);
  inline ::std::string* add_moderatorpermission();
  inline void add_moderatorpermission(const ::std::string& value);
  inline void add_moderatorpermission(const char* value);
  inline void add_moderatorpermission(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& moderatorpermission() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_moderatorpermission();

  // repeated string userPermission = 3;
  inline int userpermission_size() const;
  inline void clear_userpermission();
  static const int kUserPermissionFieldNumber = 3;
  inline const ::std::string& userpermission(int index) const;
  inline ::std::string* mutable_userpermission(int index);
  inline void set_userpermission(int index, const ::std::string& value);
  inline void set_userpermission(int index, const char* value);
  inline void set_userpermission(int index, const char* value, size_t size);
  inline ::std::string* add_userpermission();
  inline void add_userpermission(const ::std::string& value);
  inline void add_userpermission(const char* value);
  inline void add_userpermission(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& userpermission() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_userpermission();

  // @@protoc_insertion_point(class_scope:protobuf.srl.school.SrlPermission)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> adminpermission_;
  ::google::protobuf::RepeatedPtrField< ::std::string> moderatorpermission_;
  ::google::protobuf::RepeatedPtrField< ::std::string> userpermission_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_input_2fschool_2eproto();
  friend void protobuf_AssignDesc_input_2fschool_2eproto();
  friend void protobuf_ShutdownFile_input_2fschool_2eproto();

  void InitAsDefaultInstance();
  static SrlPermission* default_instance_;
};
// ===================================================================


// ===================================================================

// SrlSchool

// repeated .protobuf.srl.school.SrlCourse courses = 1;
inline int SrlSchool::courses_size() const {
  return courses_.size();
}
inline void SrlSchool::clear_courses() {
  courses_.Clear();
}
inline const ::protobuf::srl::school::SrlCourse& SrlSchool::courses(int index) const {
  return courses_.Get(index);
}
inline ::protobuf::srl::school::SrlCourse* SrlSchool::mutable_courses(int index) {
  return courses_.Mutable(index);
}
inline ::protobuf::srl::school::SrlCourse* SrlSchool::add_courses() {
  return courses_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlCourse >&
SrlSchool::courses() const {
  return courses_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlCourse >*
SrlSchool::mutable_courses() {
  return &courses_;
}

// repeated .protobuf.srl.school.SrlAssignment assignments = 2;
inline int SrlSchool::assignments_size() const {
  return assignments_.size();
}
inline void SrlSchool::clear_assignments() {
  assignments_.Clear();
}
inline const ::protobuf::srl::school::SrlAssignment& SrlSchool::assignments(int index) const {
  return assignments_.Get(index);
}
inline ::protobuf::srl::school::SrlAssignment* SrlSchool::mutable_assignments(int index) {
  return assignments_.Mutable(index);
}
inline ::protobuf::srl::school::SrlAssignment* SrlSchool::add_assignments() {
  return assignments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlAssignment >&
SrlSchool::assignments() const {
  return assignments_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlAssignment >*
SrlSchool::mutable_assignments() {
  return &assignments_;
}

// repeated .protobuf.srl.school.SrlProblem problems = 3;
inline int SrlSchool::problems_size() const {
  return problems_.size();
}
inline void SrlSchool::clear_problems() {
  problems_.Clear();
}
inline const ::protobuf::srl::school::SrlProblem& SrlSchool::problems(int index) const {
  return problems_.Get(index);
}
inline ::protobuf::srl::school::SrlProblem* SrlSchool::mutable_problems(int index) {
  return problems_.Mutable(index);
}
inline ::protobuf::srl::school::SrlProblem* SrlSchool::add_problems() {
  return problems_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlProblem >&
SrlSchool::problems() const {
  return problems_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlProblem >*
SrlSchool::mutable_problems() {
  return &problems_;
}

// -------------------------------------------------------------------

// SrlCourse

// required string id = 1;
inline bool SrlCourse::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SrlCourse::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SrlCourse::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SrlCourse::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& SrlCourse::id() const {
  return *id_;
}
inline void SrlCourse::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void SrlCourse::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void SrlCourse::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlCourse::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* SrlCourse::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlCourse::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 2;
inline bool SrlCourse::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SrlCourse::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SrlCourse::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SrlCourse::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& SrlCourse::name() const {
  return *name_;
}
inline void SrlCourse::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SrlCourse::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SrlCourse::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlCourse::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* SrlCourse::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlCourse::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .protobuf.srl.school.SrlPermission accessPermission = 3;
inline bool SrlCourse::has_accesspermission() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SrlCourse::set_has_accesspermission() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SrlCourse::clear_has_accesspermission() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SrlCourse::clear_accesspermission() {
  if (accesspermission_ != NULL) accesspermission_->::protobuf::srl::school::SrlPermission::Clear();
  clear_has_accesspermission();
}
inline const ::protobuf::srl::school::SrlPermission& SrlCourse::accesspermission() const {
  return accesspermission_ != NULL ? *accesspermission_ : *default_instance_->accesspermission_;
}
inline ::protobuf::srl::school::SrlPermission* SrlCourse::mutable_accesspermission() {
  set_has_accesspermission();
  if (accesspermission_ == NULL) accesspermission_ = new ::protobuf::srl::school::SrlPermission;
  return accesspermission_;
}
inline ::protobuf::srl::school::SrlPermission* SrlCourse::release_accesspermission() {
  clear_has_accesspermission();
  ::protobuf::srl::school::SrlPermission* temp = accesspermission_;
  accesspermission_ = NULL;
  return temp;
}
inline void SrlCourse::set_allocated_accesspermission(::protobuf::srl::school::SrlPermission* accesspermission) {
  delete accesspermission_;
  accesspermission_ = accesspermission;
  if (accesspermission) {
    set_has_accesspermission();
  } else {
    clear_has_accesspermission();
  }
}

// optional .protobuf.srl.school.SrlCourse.Accessibility access = 4 [default = PROTECTED];
inline bool SrlCourse::has_access() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SrlCourse::set_has_access() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SrlCourse::clear_has_access() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SrlCourse::clear_access() {
  access_ = 2;
  clear_has_access();
}
inline ::protobuf::srl::school::SrlCourse_Accessibility SrlCourse::access() const {
  return static_cast< ::protobuf::srl::school::SrlCourse_Accessibility >(access_);
}
inline void SrlCourse::set_access(::protobuf::srl::school::SrlCourse_Accessibility value) {
  assert(::protobuf::srl::school::SrlCourse_Accessibility_IsValid(value));
  set_has_access();
  access_ = value;
}

// optional string description = 5;
inline bool SrlCourse::has_description() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SrlCourse::set_has_description() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SrlCourse::clear_has_description() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SrlCourse::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& SrlCourse::description() const {
  return *description_;
}
inline void SrlCourse::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void SrlCourse::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void SrlCourse::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlCourse::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* SrlCourse::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlCourse::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string semester = 6;
inline bool SrlCourse::has_semester() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SrlCourse::set_has_semester() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SrlCourse::clear_has_semester() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SrlCourse::clear_semester() {
  if (semester_ != &::google::protobuf::internal::kEmptyString) {
    semester_->clear();
  }
  clear_has_semester();
}
inline const ::std::string& SrlCourse::semester() const {
  return *semester_;
}
inline void SrlCourse::set_semester(const ::std::string& value) {
  set_has_semester();
  if (semester_ == &::google::protobuf::internal::kEmptyString) {
    semester_ = new ::std::string;
  }
  semester_->assign(value);
}
inline void SrlCourse::set_semester(const char* value) {
  set_has_semester();
  if (semester_ == &::google::protobuf::internal::kEmptyString) {
    semester_ = new ::std::string;
  }
  semester_->assign(value);
}
inline void SrlCourse::set_semester(const char* value, size_t size) {
  set_has_semester();
  if (semester_ == &::google::protobuf::internal::kEmptyString) {
    semester_ = new ::std::string;
  }
  semester_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlCourse::mutable_semester() {
  set_has_semester();
  if (semester_ == &::google::protobuf::internal::kEmptyString) {
    semester_ = new ::std::string;
  }
  return semester_;
}
inline ::std::string* SrlCourse::release_semester() {
  clear_has_semester();
  if (semester_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = semester_;
    semester_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlCourse::set_allocated_semester(::std::string* semester) {
  if (semester_ != &::google::protobuf::internal::kEmptyString) {
    delete semester_;
  }
  if (semester) {
    set_has_semester();
    semester_ = semester;
  } else {
    clear_has_semester();
    semester_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string imageUrl = 7;
inline bool SrlCourse::has_imageurl() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SrlCourse::set_has_imageurl() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SrlCourse::clear_has_imageurl() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SrlCourse::clear_imageurl() {
  if (imageurl_ != &::google::protobuf::internal::kEmptyString) {
    imageurl_->clear();
  }
  clear_has_imageurl();
}
inline const ::std::string& SrlCourse::imageurl() const {
  return *imageurl_;
}
inline void SrlCourse::set_imageurl(const ::std::string& value) {
  set_has_imageurl();
  if (imageurl_ == &::google::protobuf::internal::kEmptyString) {
    imageurl_ = new ::std::string;
  }
  imageurl_->assign(value);
}
inline void SrlCourse::set_imageurl(const char* value) {
  set_has_imageurl();
  if (imageurl_ == &::google::protobuf::internal::kEmptyString) {
    imageurl_ = new ::std::string;
  }
  imageurl_->assign(value);
}
inline void SrlCourse::set_imageurl(const char* value, size_t size) {
  set_has_imageurl();
  if (imageurl_ == &::google::protobuf::internal::kEmptyString) {
    imageurl_ = new ::std::string;
  }
  imageurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlCourse::mutable_imageurl() {
  set_has_imageurl();
  if (imageurl_ == &::google::protobuf::internal::kEmptyString) {
    imageurl_ = new ::std::string;
  }
  return imageurl_;
}
inline ::std::string* SrlCourse::release_imageurl() {
  clear_has_imageurl();
  if (imageurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = imageurl_;
    imageurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlCourse::set_allocated_imageurl(::std::string* imageurl) {
  if (imageurl_ != &::google::protobuf::internal::kEmptyString) {
    delete imageurl_;
  }
  if (imageurl) {
    set_has_imageurl();
    imageurl_ = imageurl;
  } else {
    clear_has_imageurl();
    imageurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float grade = 8;
inline bool SrlCourse::has_grade() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SrlCourse::set_has_grade() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SrlCourse::clear_has_grade() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SrlCourse::clear_grade() {
  grade_ = 0;
  clear_has_grade();
}
inline float SrlCourse::grade() const {
  return grade_;
}
inline void SrlCourse::set_grade(float value) {
  set_has_grade();
  grade_ = value;
}

// optional .protobuf.srl.school.DateTime accessDate = 9;
inline bool SrlCourse::has_accessdate() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SrlCourse::set_has_accessdate() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SrlCourse::clear_has_accessdate() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SrlCourse::clear_accessdate() {
  if (accessdate_ != NULL) accessdate_->::protobuf::srl::school::DateTime::Clear();
  clear_has_accessdate();
}
inline const ::protobuf::srl::school::DateTime& SrlCourse::accessdate() const {
  return accessdate_ != NULL ? *accessdate_ : *default_instance_->accessdate_;
}
inline ::protobuf::srl::school::DateTime* SrlCourse::mutable_accessdate() {
  set_has_accessdate();
  if (accessdate_ == NULL) accessdate_ = new ::protobuf::srl::school::DateTime;
  return accessdate_;
}
inline ::protobuf::srl::school::DateTime* SrlCourse::release_accessdate() {
  clear_has_accessdate();
  ::protobuf::srl::school::DateTime* temp = accessdate_;
  accessdate_ = NULL;
  return temp;
}
inline void SrlCourse::set_allocated_accessdate(::protobuf::srl::school::DateTime* accessdate) {
  delete accessdate_;
  accessdate_ = accessdate;
  if (accessdate) {
    set_has_accessdate();
  } else {
    clear_has_accessdate();
  }
}

// optional .protobuf.srl.school.DateTime closeDate = 10;
inline bool SrlCourse::has_closedate() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SrlCourse::set_has_closedate() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SrlCourse::clear_has_closedate() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SrlCourse::clear_closedate() {
  if (closedate_ != NULL) closedate_->::protobuf::srl::school::DateTime::Clear();
  clear_has_closedate();
}
inline const ::protobuf::srl::school::DateTime& SrlCourse::closedate() const {
  return closedate_ != NULL ? *closedate_ : *default_instance_->closedate_;
}
inline ::protobuf::srl::school::DateTime* SrlCourse::mutable_closedate() {
  set_has_closedate();
  if (closedate_ == NULL) closedate_ = new ::protobuf::srl::school::DateTime;
  return closedate_;
}
inline ::protobuf::srl::school::DateTime* SrlCourse::release_closedate() {
  clear_has_closedate();
  ::protobuf::srl::school::DateTime* temp = closedate_;
  closedate_ = NULL;
  return temp;
}
inline void SrlCourse::set_allocated_closedate(::protobuf::srl::school::DateTime* closedate) {
  delete closedate_;
  closedate_ = closedate;
  if (closedate) {
    set_has_closedate();
  } else {
    clear_has_closedate();
  }
}

// optional .protobuf.srl.school.State state = 11;
inline bool SrlCourse::has_state() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SrlCourse::set_has_state() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SrlCourse::clear_has_state() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SrlCourse::clear_state() {
  if (state_ != NULL) state_->::protobuf::srl::school::State::Clear();
  clear_has_state();
}
inline const ::protobuf::srl::school::State& SrlCourse::state() const {
  return state_ != NULL ? *state_ : *default_instance_->state_;
}
inline ::protobuf::srl::school::State* SrlCourse::mutable_state() {
  set_has_state();
  if (state_ == NULL) state_ = new ::protobuf::srl::school::State;
  return state_;
}
inline ::protobuf::srl::school::State* SrlCourse::release_state() {
  clear_has_state();
  ::protobuf::srl::school::State* temp = state_;
  state_ = NULL;
  return temp;
}
inline void SrlCourse::set_allocated_state(::protobuf::srl::school::State* state) {
  delete state_;
  state_ = state;
  if (state) {
    set_has_state();
  } else {
    clear_has_state();
  }
}

// repeated string assignmentList = 12;
inline int SrlCourse::assignmentlist_size() const {
  return assignmentlist_.size();
}
inline void SrlCourse::clear_assignmentlist() {
  assignmentlist_.Clear();
}
inline const ::std::string& SrlCourse::assignmentlist(int index) const {
  return assignmentlist_.Get(index);
}
inline ::std::string* SrlCourse::mutable_assignmentlist(int index) {
  return assignmentlist_.Mutable(index);
}
inline void SrlCourse::set_assignmentlist(int index, const ::std::string& value) {
  assignmentlist_.Mutable(index)->assign(value);
}
inline void SrlCourse::set_assignmentlist(int index, const char* value) {
  assignmentlist_.Mutable(index)->assign(value);
}
inline void SrlCourse::set_assignmentlist(int index, const char* value, size_t size) {
  assignmentlist_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlCourse::add_assignmentlist() {
  return assignmentlist_.Add();
}
inline void SrlCourse::add_assignmentlist(const ::std::string& value) {
  assignmentlist_.Add()->assign(value);
}
inline void SrlCourse::add_assignmentlist(const char* value) {
  assignmentlist_.Add()->assign(value);
}
inline void SrlCourse::add_assignmentlist(const char* value, size_t size) {
  assignmentlist_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SrlCourse::assignmentlist() const {
  return assignmentlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SrlCourse::mutable_assignmentlist() {
  return &assignmentlist_;
}

// -------------------------------------------------------------------

// SrlAssignment

// required string courseId = 1;
inline bool SrlAssignment::has_courseid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SrlAssignment::set_has_courseid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SrlAssignment::clear_has_courseid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SrlAssignment::clear_courseid() {
  if (courseid_ != &::google::protobuf::internal::kEmptyString) {
    courseid_->clear();
  }
  clear_has_courseid();
}
inline const ::std::string& SrlAssignment::courseid() const {
  return *courseid_;
}
inline void SrlAssignment::set_courseid(const ::std::string& value) {
  set_has_courseid();
  if (courseid_ == &::google::protobuf::internal::kEmptyString) {
    courseid_ = new ::std::string;
  }
  courseid_->assign(value);
}
inline void SrlAssignment::set_courseid(const char* value) {
  set_has_courseid();
  if (courseid_ == &::google::protobuf::internal::kEmptyString) {
    courseid_ = new ::std::string;
  }
  courseid_->assign(value);
}
inline void SrlAssignment::set_courseid(const char* value, size_t size) {
  set_has_courseid();
  if (courseid_ == &::google::protobuf::internal::kEmptyString) {
    courseid_ = new ::std::string;
  }
  courseid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlAssignment::mutable_courseid() {
  set_has_courseid();
  if (courseid_ == &::google::protobuf::internal::kEmptyString) {
    courseid_ = new ::std::string;
  }
  return courseid_;
}
inline ::std::string* SrlAssignment::release_courseid() {
  clear_has_courseid();
  if (courseid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = courseid_;
    courseid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlAssignment::set_allocated_courseid(::std::string* courseid) {
  if (courseid_ != &::google::protobuf::internal::kEmptyString) {
    delete courseid_;
  }
  if (courseid) {
    set_has_courseid();
    courseid_ = courseid;
  } else {
    clear_has_courseid();
    courseid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string id = 2;
inline bool SrlAssignment::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SrlAssignment::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SrlAssignment::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SrlAssignment::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& SrlAssignment::id() const {
  return *id_;
}
inline void SrlAssignment::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void SrlAssignment::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void SrlAssignment::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlAssignment::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* SrlAssignment::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlAssignment::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 3;
inline bool SrlAssignment::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SrlAssignment::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SrlAssignment::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SrlAssignment::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& SrlAssignment::name() const {
  return *name_;
}
inline void SrlAssignment::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SrlAssignment::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SrlAssignment::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlAssignment::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* SrlAssignment::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlAssignment::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .protobuf.srl.school.SrlAssignment.AssignmentType type = 4 [default = HOMEWORK];
inline bool SrlAssignment::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SrlAssignment::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SrlAssignment::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SrlAssignment::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::protobuf::srl::school::SrlAssignment_AssignmentType SrlAssignment::type() const {
  return static_cast< ::protobuf::srl::school::SrlAssignment_AssignmentType >(type_);
}
inline void SrlAssignment::set_type(::protobuf::srl::school::SrlAssignment_AssignmentType value) {
  assert(::protobuf::srl::school::SrlAssignment_AssignmentType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string other = 5;
inline bool SrlAssignment::has_other() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SrlAssignment::set_has_other() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SrlAssignment::clear_has_other() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SrlAssignment::clear_other() {
  if (other_ != &::google::protobuf::internal::kEmptyString) {
    other_->clear();
  }
  clear_has_other();
}
inline const ::std::string& SrlAssignment::other() const {
  return *other_;
}
inline void SrlAssignment::set_other(const ::std::string& value) {
  set_has_other();
  if (other_ == &::google::protobuf::internal::kEmptyString) {
    other_ = new ::std::string;
  }
  other_->assign(value);
}
inline void SrlAssignment::set_other(const char* value) {
  set_has_other();
  if (other_ == &::google::protobuf::internal::kEmptyString) {
    other_ = new ::std::string;
  }
  other_->assign(value);
}
inline void SrlAssignment::set_other(const char* value, size_t size) {
  set_has_other();
  if (other_ == &::google::protobuf::internal::kEmptyString) {
    other_ = new ::std::string;
  }
  other_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlAssignment::mutable_other() {
  set_has_other();
  if (other_ == &::google::protobuf::internal::kEmptyString) {
    other_ = new ::std::string;
  }
  return other_;
}
inline ::std::string* SrlAssignment::release_other() {
  clear_has_other();
  if (other_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = other_;
    other_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlAssignment::set_allocated_other(::std::string* other) {
  if (other_ != &::google::protobuf::internal::kEmptyString) {
    delete other_;
  }
  if (other) {
    set_has_other();
    other_ = other;
  } else {
    clear_has_other();
    other_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string description = 6;
inline bool SrlAssignment::has_description() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SrlAssignment::set_has_description() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SrlAssignment::clear_has_description() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SrlAssignment::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& SrlAssignment::description() const {
  return *description_;
}
inline void SrlAssignment::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void SrlAssignment::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void SrlAssignment::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlAssignment::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* SrlAssignment::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlAssignment::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string links = 7;
inline int SrlAssignment::links_size() const {
  return links_.size();
}
inline void SrlAssignment::clear_links() {
  links_.Clear();
}
inline const ::std::string& SrlAssignment::links(int index) const {
  return links_.Get(index);
}
inline ::std::string* SrlAssignment::mutable_links(int index) {
  return links_.Mutable(index);
}
inline void SrlAssignment::set_links(int index, const ::std::string& value) {
  links_.Mutable(index)->assign(value);
}
inline void SrlAssignment::set_links(int index, const char* value) {
  links_.Mutable(index)->assign(value);
}
inline void SrlAssignment::set_links(int index, const char* value, size_t size) {
  links_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlAssignment::add_links() {
  return links_.Add();
}
inline void SrlAssignment::add_links(const ::std::string& value) {
  links_.Add()->assign(value);
}
inline void SrlAssignment::add_links(const char* value) {
  links_.Add()->assign(value);
}
inline void SrlAssignment::add_links(const char* value, size_t size) {
  links_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SrlAssignment::links() const {
  return links_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SrlAssignment::mutable_links() {
  return &links_;
}

// optional .protobuf.srl.school.SrlAssignment.LatePolicy latePolicy = 8 [default = POLICY1];
inline bool SrlAssignment::has_latepolicy() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SrlAssignment::set_has_latepolicy() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SrlAssignment::clear_has_latepolicy() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SrlAssignment::clear_latepolicy() {
  latepolicy_ = 1;
  clear_has_latepolicy();
}
inline ::protobuf::srl::school::SrlAssignment_LatePolicy SrlAssignment::latepolicy() const {
  return static_cast< ::protobuf::srl::school::SrlAssignment_LatePolicy >(latepolicy_);
}
inline void SrlAssignment::set_latepolicy(::protobuf::srl::school::SrlAssignment_LatePolicy value) {
  assert(::protobuf::srl::school::SrlAssignment_LatePolicy_IsValid(value));
  set_has_latepolicy();
  latepolicy_ = value;
}

// optional string gradeWeight = 9;
inline bool SrlAssignment::has_gradeweight() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SrlAssignment::set_has_gradeweight() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SrlAssignment::clear_has_gradeweight() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SrlAssignment::clear_gradeweight() {
  if (gradeweight_ != &::google::protobuf::internal::kEmptyString) {
    gradeweight_->clear();
  }
  clear_has_gradeweight();
}
inline const ::std::string& SrlAssignment::gradeweight() const {
  return *gradeweight_;
}
inline void SrlAssignment::set_gradeweight(const ::std::string& value) {
  set_has_gradeweight();
  if (gradeweight_ == &::google::protobuf::internal::kEmptyString) {
    gradeweight_ = new ::std::string;
  }
  gradeweight_->assign(value);
}
inline void SrlAssignment::set_gradeweight(const char* value) {
  set_has_gradeweight();
  if (gradeweight_ == &::google::protobuf::internal::kEmptyString) {
    gradeweight_ = new ::std::string;
  }
  gradeweight_->assign(value);
}
inline void SrlAssignment::set_gradeweight(const char* value, size_t size) {
  set_has_gradeweight();
  if (gradeweight_ == &::google::protobuf::internal::kEmptyString) {
    gradeweight_ = new ::std::string;
  }
  gradeweight_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlAssignment::mutable_gradeweight() {
  set_has_gradeweight();
  if (gradeweight_ == &::google::protobuf::internal::kEmptyString) {
    gradeweight_ = new ::std::string;
  }
  return gradeweight_;
}
inline ::std::string* SrlAssignment::release_gradeweight() {
  clear_has_gradeweight();
  if (gradeweight_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gradeweight_;
    gradeweight_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlAssignment::set_allocated_gradeweight(::std::string* gradeweight) {
  if (gradeweight_ != &::google::protobuf::internal::kEmptyString) {
    delete gradeweight_;
  }
  if (gradeweight) {
    set_has_gradeweight();
    gradeweight_ = gradeweight;
  } else {
    clear_has_gradeweight();
    gradeweight_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float grade = 10;
inline bool SrlAssignment::has_grade() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SrlAssignment::set_has_grade() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SrlAssignment::clear_has_grade() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SrlAssignment::clear_grade() {
  grade_ = 0;
  clear_has_grade();
}
inline float SrlAssignment::grade() const {
  return grade_;
}
inline void SrlAssignment::set_grade(float value) {
  set_has_grade();
  grade_ = value;
}

// optional .protobuf.srl.school.DateTime accessDate = 11;
inline bool SrlAssignment::has_accessdate() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SrlAssignment::set_has_accessdate() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SrlAssignment::clear_has_accessdate() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SrlAssignment::clear_accessdate() {
  if (accessdate_ != NULL) accessdate_->::protobuf::srl::school::DateTime::Clear();
  clear_has_accessdate();
}
inline const ::protobuf::srl::school::DateTime& SrlAssignment::accessdate() const {
  return accessdate_ != NULL ? *accessdate_ : *default_instance_->accessdate_;
}
inline ::protobuf::srl::school::DateTime* SrlAssignment::mutable_accessdate() {
  set_has_accessdate();
  if (accessdate_ == NULL) accessdate_ = new ::protobuf::srl::school::DateTime;
  return accessdate_;
}
inline ::protobuf::srl::school::DateTime* SrlAssignment::release_accessdate() {
  clear_has_accessdate();
  ::protobuf::srl::school::DateTime* temp = accessdate_;
  accessdate_ = NULL;
  return temp;
}
inline void SrlAssignment::set_allocated_accessdate(::protobuf::srl::school::DateTime* accessdate) {
  delete accessdate_;
  accessdate_ = accessdate;
  if (accessdate) {
    set_has_accessdate();
  } else {
    clear_has_accessdate();
  }
}

// optional .protobuf.srl.school.DateTime dueDate = 12;
inline bool SrlAssignment::has_duedate() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SrlAssignment::set_has_duedate() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SrlAssignment::clear_has_duedate() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SrlAssignment::clear_duedate() {
  if (duedate_ != NULL) duedate_->::protobuf::srl::school::DateTime::Clear();
  clear_has_duedate();
}
inline const ::protobuf::srl::school::DateTime& SrlAssignment::duedate() const {
  return duedate_ != NULL ? *duedate_ : *default_instance_->duedate_;
}
inline ::protobuf::srl::school::DateTime* SrlAssignment::mutable_duedate() {
  set_has_duedate();
  if (duedate_ == NULL) duedate_ = new ::protobuf::srl::school::DateTime;
  return duedate_;
}
inline ::protobuf::srl::school::DateTime* SrlAssignment::release_duedate() {
  clear_has_duedate();
  ::protobuf::srl::school::DateTime* temp = duedate_;
  duedate_ = NULL;
  return temp;
}
inline void SrlAssignment::set_allocated_duedate(::protobuf::srl::school::DateTime* duedate) {
  delete duedate_;
  duedate_ = duedate;
  if (duedate) {
    set_has_duedate();
  } else {
    clear_has_duedate();
  }
}

// optional .protobuf.srl.school.DateTime closeDate = 13;
inline bool SrlAssignment::has_closedate() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SrlAssignment::set_has_closedate() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SrlAssignment::clear_has_closedate() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SrlAssignment::clear_closedate() {
  if (closedate_ != NULL) closedate_->::protobuf::srl::school::DateTime::Clear();
  clear_has_closedate();
}
inline const ::protobuf::srl::school::DateTime& SrlAssignment::closedate() const {
  return closedate_ != NULL ? *closedate_ : *default_instance_->closedate_;
}
inline ::protobuf::srl::school::DateTime* SrlAssignment::mutable_closedate() {
  set_has_closedate();
  if (closedate_ == NULL) closedate_ = new ::protobuf::srl::school::DateTime;
  return closedate_;
}
inline ::protobuf::srl::school::DateTime* SrlAssignment::release_closedate() {
  clear_has_closedate();
  ::protobuf::srl::school::DateTime* temp = closedate_;
  closedate_ = NULL;
  return temp;
}
inline void SrlAssignment::set_allocated_closedate(::protobuf::srl::school::DateTime* closedate) {
  delete closedate_;
  closedate_ = closedate;
  if (closedate) {
    set_has_closedate();
  } else {
    clear_has_closedate();
  }
}

// optional .protobuf.srl.school.State state = 14;
inline bool SrlAssignment::has_state() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SrlAssignment::set_has_state() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SrlAssignment::clear_has_state() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SrlAssignment::clear_state() {
  if (state_ != NULL) state_->::protobuf::srl::school::State::Clear();
  clear_has_state();
}
inline const ::protobuf::srl::school::State& SrlAssignment::state() const {
  return state_ != NULL ? *state_ : *default_instance_->state_;
}
inline ::protobuf::srl::school::State* SrlAssignment::mutable_state() {
  set_has_state();
  if (state_ == NULL) state_ = new ::protobuf::srl::school::State;
  return state_;
}
inline ::protobuf::srl::school::State* SrlAssignment::release_state() {
  clear_has_state();
  ::protobuf::srl::school::State* temp = state_;
  state_ = NULL;
  return temp;
}
inline void SrlAssignment::set_allocated_state(::protobuf::srl::school::State* state) {
  delete state_;
  state_ = state;
  if (state) {
    set_has_state();
  } else {
    clear_has_state();
  }
}

// optional string imageUrl = 15;
inline bool SrlAssignment::has_imageurl() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SrlAssignment::set_has_imageurl() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SrlAssignment::clear_has_imageurl() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SrlAssignment::clear_imageurl() {
  if (imageurl_ != &::google::protobuf::internal::kEmptyString) {
    imageurl_->clear();
  }
  clear_has_imageurl();
}
inline const ::std::string& SrlAssignment::imageurl() const {
  return *imageurl_;
}
inline void SrlAssignment::set_imageurl(const ::std::string& value) {
  set_has_imageurl();
  if (imageurl_ == &::google::protobuf::internal::kEmptyString) {
    imageurl_ = new ::std::string;
  }
  imageurl_->assign(value);
}
inline void SrlAssignment::set_imageurl(const char* value) {
  set_has_imageurl();
  if (imageurl_ == &::google::protobuf::internal::kEmptyString) {
    imageurl_ = new ::std::string;
  }
  imageurl_->assign(value);
}
inline void SrlAssignment::set_imageurl(const char* value, size_t size) {
  set_has_imageurl();
  if (imageurl_ == &::google::protobuf::internal::kEmptyString) {
    imageurl_ = new ::std::string;
  }
  imageurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlAssignment::mutable_imageurl() {
  set_has_imageurl();
  if (imageurl_ == &::google::protobuf::internal::kEmptyString) {
    imageurl_ = new ::std::string;
  }
  return imageurl_;
}
inline ::std::string* SrlAssignment::release_imageurl() {
  clear_has_imageurl();
  if (imageurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = imageurl_;
    imageurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlAssignment::set_allocated_imageurl(::std::string* imageurl) {
  if (imageurl_ != &::google::protobuf::internal::kEmptyString) {
    delete imageurl_;
  }
  if (imageurl) {
    set_has_imageurl();
    imageurl_ = imageurl;
  } else {
    clear_has_imageurl();
    imageurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string problemList = 16;
inline int SrlAssignment::problemlist_size() const {
  return problemlist_.size();
}
inline void SrlAssignment::clear_problemlist() {
  problemlist_.Clear();
}
inline const ::std::string& SrlAssignment::problemlist(int index) const {
  return problemlist_.Get(index);
}
inline ::std::string* SrlAssignment::mutable_problemlist(int index) {
  return problemlist_.Mutable(index);
}
inline void SrlAssignment::set_problemlist(int index, const ::std::string& value) {
  problemlist_.Mutable(index)->assign(value);
}
inline void SrlAssignment::set_problemlist(int index, const char* value) {
  problemlist_.Mutable(index)->assign(value);
}
inline void SrlAssignment::set_problemlist(int index, const char* value, size_t size) {
  problemlist_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlAssignment::add_problemlist() {
  return problemlist_.Add();
}
inline void SrlAssignment::add_problemlist(const ::std::string& value) {
  problemlist_.Add()->assign(value);
}
inline void SrlAssignment::add_problemlist(const char* value) {
  problemlist_.Add()->assign(value);
}
inline void SrlAssignment::add_problemlist(const char* value, size_t size) {
  problemlist_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SrlAssignment::problemlist() const {
  return problemlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SrlAssignment::mutable_problemlist() {
  return &problemlist_;
}

// optional .protobuf.srl.school.SrlPermission accessPermission = 17;
inline bool SrlAssignment::has_accesspermission() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void SrlAssignment::set_has_accesspermission() {
  _has_bits_[0] |= 0x00010000u;
}
inline void SrlAssignment::clear_has_accesspermission() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void SrlAssignment::clear_accesspermission() {
  if (accesspermission_ != NULL) accesspermission_->::protobuf::srl::school::SrlPermission::Clear();
  clear_has_accesspermission();
}
inline const ::protobuf::srl::school::SrlPermission& SrlAssignment::accesspermission() const {
  return accesspermission_ != NULL ? *accesspermission_ : *default_instance_->accesspermission_;
}
inline ::protobuf::srl::school::SrlPermission* SrlAssignment::mutable_accesspermission() {
  set_has_accesspermission();
  if (accesspermission_ == NULL) accesspermission_ = new ::protobuf::srl::school::SrlPermission;
  return accesspermission_;
}
inline ::protobuf::srl::school::SrlPermission* SrlAssignment::release_accesspermission() {
  clear_has_accesspermission();
  ::protobuf::srl::school::SrlPermission* temp = accesspermission_;
  accesspermission_ = NULL;
  return temp;
}
inline void SrlAssignment::set_allocated_accesspermission(::protobuf::srl::school::SrlPermission* accesspermission) {
  delete accesspermission_;
  accesspermission_ = accesspermission;
  if (accesspermission) {
    set_has_accesspermission();
  } else {
    clear_has_accesspermission();
  }
}

// -------------------------------------------------------------------

// SrlProblem

// required string id = 1;
inline bool SrlProblem::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SrlProblem::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SrlProblem::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SrlProblem::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& SrlProblem::id() const {
  return *id_;
}
inline void SrlProblem::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void SrlProblem::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void SrlProblem::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlProblem::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* SrlProblem::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlProblem::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string courseId = 2;
inline bool SrlProblem::has_courseid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SrlProblem::set_has_courseid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SrlProblem::clear_has_courseid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SrlProblem::clear_courseid() {
  if (courseid_ != &::google::protobuf::internal::kEmptyString) {
    courseid_->clear();
  }
  clear_has_courseid();
}
inline const ::std::string& SrlProblem::courseid() const {
  return *courseid_;
}
inline void SrlProblem::set_courseid(const ::std::string& value) {
  set_has_courseid();
  if (courseid_ == &::google::protobuf::internal::kEmptyString) {
    courseid_ = new ::std::string;
  }
  courseid_->assign(value);
}
inline void SrlProblem::set_courseid(const char* value) {
  set_has_courseid();
  if (courseid_ == &::google::protobuf::internal::kEmptyString) {
    courseid_ = new ::std::string;
  }
  courseid_->assign(value);
}
inline void SrlProblem::set_courseid(const char* value, size_t size) {
  set_has_courseid();
  if (courseid_ == &::google::protobuf::internal::kEmptyString) {
    courseid_ = new ::std::string;
  }
  courseid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlProblem::mutable_courseid() {
  set_has_courseid();
  if (courseid_ == &::google::protobuf::internal::kEmptyString) {
    courseid_ = new ::std::string;
  }
  return courseid_;
}
inline ::std::string* SrlProblem::release_courseid() {
  clear_has_courseid();
  if (courseid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = courseid_;
    courseid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlProblem::set_allocated_courseid(::std::string* courseid) {
  if (courseid_ != &::google::protobuf::internal::kEmptyString) {
    delete courseid_;
  }
  if (courseid) {
    set_has_courseid();
    courseid_ = courseid;
  } else {
    clear_has_courseid();
    courseid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string assignmentId = 3;
inline bool SrlProblem::has_assignmentid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SrlProblem::set_has_assignmentid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SrlProblem::clear_has_assignmentid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SrlProblem::clear_assignmentid() {
  if (assignmentid_ != &::google::protobuf::internal::kEmptyString) {
    assignmentid_->clear();
  }
  clear_has_assignmentid();
}
inline const ::std::string& SrlProblem::assignmentid() const {
  return *assignmentid_;
}
inline void SrlProblem::set_assignmentid(const ::std::string& value) {
  set_has_assignmentid();
  if (assignmentid_ == &::google::protobuf::internal::kEmptyString) {
    assignmentid_ = new ::std::string;
  }
  assignmentid_->assign(value);
}
inline void SrlProblem::set_assignmentid(const char* value) {
  set_has_assignmentid();
  if (assignmentid_ == &::google::protobuf::internal::kEmptyString) {
    assignmentid_ = new ::std::string;
  }
  assignmentid_->assign(value);
}
inline void SrlProblem::set_assignmentid(const char* value, size_t size) {
  set_has_assignmentid();
  if (assignmentid_ == &::google::protobuf::internal::kEmptyString) {
    assignmentid_ = new ::std::string;
  }
  assignmentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlProblem::mutable_assignmentid() {
  set_has_assignmentid();
  if (assignmentid_ == &::google::protobuf::internal::kEmptyString) {
    assignmentid_ = new ::std::string;
  }
  return assignmentid_;
}
inline ::std::string* SrlProblem::release_assignmentid() {
  clear_has_assignmentid();
  if (assignmentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = assignmentid_;
    assignmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlProblem::set_allocated_assignmentid(::std::string* assignmentid) {
  if (assignmentid_ != &::google::protobuf::internal::kEmptyString) {
    delete assignmentid_;
  }
  if (assignmentid) {
    set_has_assignmentid();
    assignmentid_ = assignmentid;
  } else {
    clear_has_assignmentid();
    assignmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string problemBankId = 4;
inline bool SrlProblem::has_problembankid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SrlProblem::set_has_problembankid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SrlProblem::clear_has_problembankid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SrlProblem::clear_problembankid() {
  if (problembankid_ != &::google::protobuf::internal::kEmptyString) {
    problembankid_->clear();
  }
  clear_has_problembankid();
}
inline const ::std::string& SrlProblem::problembankid() const {
  return *problembankid_;
}
inline void SrlProblem::set_problembankid(const ::std::string& value) {
  set_has_problembankid();
  if (problembankid_ == &::google::protobuf::internal::kEmptyString) {
    problembankid_ = new ::std::string;
  }
  problembankid_->assign(value);
}
inline void SrlProblem::set_problembankid(const char* value) {
  set_has_problembankid();
  if (problembankid_ == &::google::protobuf::internal::kEmptyString) {
    problembankid_ = new ::std::string;
  }
  problembankid_->assign(value);
}
inline void SrlProblem::set_problembankid(const char* value, size_t size) {
  set_has_problembankid();
  if (problembankid_ == &::google::protobuf::internal::kEmptyString) {
    problembankid_ = new ::std::string;
  }
  problembankid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlProblem::mutable_problembankid() {
  set_has_problembankid();
  if (problembankid_ == &::google::protobuf::internal::kEmptyString) {
    problembankid_ = new ::std::string;
  }
  return problembankid_;
}
inline ::std::string* SrlProblem::release_problembankid() {
  clear_has_problembankid();
  if (problembankid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = problembankid_;
    problembankid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlProblem::set_allocated_problembankid(::std::string* problembankid) {
  if (problembankid_ != &::google::protobuf::internal::kEmptyString) {
    delete problembankid_;
  }
  if (problembankid) {
    set_has_problembankid();
    problembankid_ = problembankid;
  } else {
    clear_has_problembankid();
    problembankid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 5;
inline bool SrlProblem::has_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SrlProblem::set_has_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SrlProblem::clear_has_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SrlProblem::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& SrlProblem::name() const {
  return *name_;
}
inline void SrlProblem::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SrlProblem::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SrlProblem::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlProblem::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* SrlProblem::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlProblem::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string description = 6;
inline bool SrlProblem::has_description() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SrlProblem::set_has_description() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SrlProblem::clear_has_description() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SrlProblem::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& SrlProblem::description() const {
  return *description_;
}
inline void SrlProblem::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void SrlProblem::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void SrlProblem::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlProblem::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* SrlProblem::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlProblem::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .protobuf.srl.school.problemBankProblem problemInfo = 7;
inline bool SrlProblem::has_probleminfo() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SrlProblem::set_has_probleminfo() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SrlProblem::clear_has_probleminfo() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SrlProblem::clear_probleminfo() {
  if (probleminfo_ != NULL) probleminfo_->::protobuf::srl::school::problemBankProblem::Clear();
  clear_has_probleminfo();
}
inline const ::protobuf::srl::school::problemBankProblem& SrlProblem::probleminfo() const {
  return probleminfo_ != NULL ? *probleminfo_ : *default_instance_->probleminfo_;
}
inline ::protobuf::srl::school::problemBankProblem* SrlProblem::mutable_probleminfo() {
  set_has_probleminfo();
  if (probleminfo_ == NULL) probleminfo_ = new ::protobuf::srl::school::problemBankProblem;
  return probleminfo_;
}
inline ::protobuf::srl::school::problemBankProblem* SrlProblem::release_probleminfo() {
  clear_has_probleminfo();
  ::protobuf::srl::school::problemBankProblem* temp = probleminfo_;
  probleminfo_ = NULL;
  return temp;
}
inline void SrlProblem::set_allocated_probleminfo(::protobuf::srl::school::problemBankProblem* probleminfo) {
  delete probleminfo_;
  probleminfo_ = probleminfo;
  if (probleminfo) {
    set_has_probleminfo();
  } else {
    clear_has_probleminfo();
  }
}

// repeated .protobuf.srl.school.DomainInformation info = 8;
inline int SrlProblem::info_size() const {
  return info_.size();
}
inline void SrlProblem::clear_info() {
  info_.Clear();
}
inline const ::protobuf::srl::school::DomainInformation& SrlProblem::info(int index) const {
  return info_.Get(index);
}
inline ::protobuf::srl::school::DomainInformation* SrlProblem::mutable_info(int index) {
  return info_.Mutable(index);
}
inline ::protobuf::srl::school::DomainInformation* SrlProblem::add_info() {
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::DomainInformation >&
SrlProblem::info() const {
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::DomainInformation >*
SrlProblem::mutable_info() {
  return &info_;
}

// optional string gradeWeight = 9;
inline bool SrlProblem::has_gradeweight() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SrlProblem::set_has_gradeweight() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SrlProblem::clear_has_gradeweight() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SrlProblem::clear_gradeweight() {
  if (gradeweight_ != &::google::protobuf::internal::kEmptyString) {
    gradeweight_->clear();
  }
  clear_has_gradeweight();
}
inline const ::std::string& SrlProblem::gradeweight() const {
  return *gradeweight_;
}
inline void SrlProblem::set_gradeweight(const ::std::string& value) {
  set_has_gradeweight();
  if (gradeweight_ == &::google::protobuf::internal::kEmptyString) {
    gradeweight_ = new ::std::string;
  }
  gradeweight_->assign(value);
}
inline void SrlProblem::set_gradeweight(const char* value) {
  set_has_gradeweight();
  if (gradeweight_ == &::google::protobuf::internal::kEmptyString) {
    gradeweight_ = new ::std::string;
  }
  gradeweight_->assign(value);
}
inline void SrlProblem::set_gradeweight(const char* value, size_t size) {
  set_has_gradeweight();
  if (gradeweight_ == &::google::protobuf::internal::kEmptyString) {
    gradeweight_ = new ::std::string;
  }
  gradeweight_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlProblem::mutable_gradeweight() {
  set_has_gradeweight();
  if (gradeweight_ == &::google::protobuf::internal::kEmptyString) {
    gradeweight_ = new ::std::string;
  }
  return gradeweight_;
}
inline ::std::string* SrlProblem::release_gradeweight() {
  clear_has_gradeweight();
  if (gradeweight_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gradeweight_;
    gradeweight_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlProblem::set_allocated_gradeweight(::std::string* gradeweight) {
  if (gradeweight_ != &::google::protobuf::internal::kEmptyString) {
    delete gradeweight_;
  }
  if (gradeweight) {
    set_has_gradeweight();
    gradeweight_ = gradeweight;
  } else {
    clear_has_gradeweight();
    gradeweight_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float grade = 10;
inline bool SrlProblem::has_grade() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SrlProblem::set_has_grade() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SrlProblem::clear_has_grade() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SrlProblem::clear_grade() {
  grade_ = 0;
  clear_has_grade();
}
inline float SrlProblem::grade() const {
  return grade_;
}
inline void SrlProblem::set_grade(float value) {
  set_has_grade();
  grade_ = value;
}

// optional .protobuf.srl.school.State state = 11;
inline bool SrlProblem::has_state() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SrlProblem::set_has_state() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SrlProblem::clear_has_state() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SrlProblem::clear_state() {
  if (state_ != NULL) state_->::protobuf::srl::school::State::Clear();
  clear_has_state();
}
inline const ::protobuf::srl::school::State& SrlProblem::state() const {
  return state_ != NULL ? *state_ : *default_instance_->state_;
}
inline ::protobuf::srl::school::State* SrlProblem::mutable_state() {
  set_has_state();
  if (state_ == NULL) state_ = new ::protobuf::srl::school::State;
  return state_;
}
inline ::protobuf::srl::school::State* SrlProblem::release_state() {
  clear_has_state();
  ::protobuf::srl::school::State* temp = state_;
  state_ = NULL;
  return temp;
}
inline void SrlProblem::set_allocated_state(::protobuf::srl::school::State* state) {
  delete state_;
  state_ = state;
  if (state) {
    set_has_state();
  } else {
    clear_has_state();
  }
}

// optional .protobuf.srl.school.SrlPermission accessPermission = 12;
inline bool SrlProblem::has_accesspermission() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SrlProblem::set_has_accesspermission() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SrlProblem::clear_has_accesspermission() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SrlProblem::clear_accesspermission() {
  if (accesspermission_ != NULL) accesspermission_->::protobuf::srl::school::SrlPermission::Clear();
  clear_has_accesspermission();
}
inline const ::protobuf::srl::school::SrlPermission& SrlProblem::accesspermission() const {
  return accesspermission_ != NULL ? *accesspermission_ : *default_instance_->accesspermission_;
}
inline ::protobuf::srl::school::SrlPermission* SrlProblem::mutable_accesspermission() {
  set_has_accesspermission();
  if (accesspermission_ == NULL) accesspermission_ = new ::protobuf::srl::school::SrlPermission;
  return accesspermission_;
}
inline ::protobuf::srl::school::SrlPermission* SrlProblem::release_accesspermission() {
  clear_has_accesspermission();
  ::protobuf::srl::school::SrlPermission* temp = accesspermission_;
  accesspermission_ = NULL;
  return temp;
}
inline void SrlProblem::set_allocated_accesspermission(::protobuf::srl::school::SrlPermission* accesspermission) {
  delete accesspermission_;
  accesspermission_ = accesspermission;
  if (accesspermission) {
    set_has_accesspermission();
  } else {
    clear_has_accesspermission();
  }
}

// -------------------------------------------------------------------

// problemBankProblem

// required string id = 1;
inline bool problemBankProblem::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void problemBankProblem::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void problemBankProblem::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void problemBankProblem::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& problemBankProblem::id() const {
  return *id_;
}
inline void problemBankProblem::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void problemBankProblem::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void problemBankProblem::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* problemBankProblem::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* problemBankProblem::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void problemBankProblem::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string questionText = 2;
inline bool problemBankProblem::has_questiontext() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void problemBankProblem::set_has_questiontext() {
  _has_bits_[0] |= 0x00000002u;
}
inline void problemBankProblem::clear_has_questiontext() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void problemBankProblem::clear_questiontext() {
  if (questiontext_ != &::google::protobuf::internal::kEmptyString) {
    questiontext_->clear();
  }
  clear_has_questiontext();
}
inline const ::std::string& problemBankProblem::questiontext() const {
  return *questiontext_;
}
inline void problemBankProblem::set_questiontext(const ::std::string& value) {
  set_has_questiontext();
  if (questiontext_ == &::google::protobuf::internal::kEmptyString) {
    questiontext_ = new ::std::string;
  }
  questiontext_->assign(value);
}
inline void problemBankProblem::set_questiontext(const char* value) {
  set_has_questiontext();
  if (questiontext_ == &::google::protobuf::internal::kEmptyString) {
    questiontext_ = new ::std::string;
  }
  questiontext_->assign(value);
}
inline void problemBankProblem::set_questiontext(const char* value, size_t size) {
  set_has_questiontext();
  if (questiontext_ == &::google::protobuf::internal::kEmptyString) {
    questiontext_ = new ::std::string;
  }
  questiontext_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* problemBankProblem::mutable_questiontext() {
  set_has_questiontext();
  if (questiontext_ == &::google::protobuf::internal::kEmptyString) {
    questiontext_ = new ::std::string;
  }
  return questiontext_;
}
inline ::std::string* problemBankProblem::release_questiontext() {
  clear_has_questiontext();
  if (questiontext_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = questiontext_;
    questiontext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void problemBankProblem::set_allocated_questiontext(::std::string* questiontext) {
  if (questiontext_ != &::google::protobuf::internal::kEmptyString) {
    delete questiontext_;
  }
  if (questiontext) {
    set_has_questiontext();
    questiontext_ = questiontext;
  } else {
    clear_has_questiontext();
    questiontext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .protobuf.srl.school.problemBankProblem.QuestionType questionType = 3 [default = SKETCH];
inline bool problemBankProblem::has_questiontype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void problemBankProblem::set_has_questiontype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void problemBankProblem::clear_has_questiontype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void problemBankProblem::clear_questiontype() {
  questiontype_ = 1;
  clear_has_questiontype();
}
inline ::protobuf::srl::school::problemBankProblem_QuestionType problemBankProblem::questiontype() const {
  return static_cast< ::protobuf::srl::school::problemBankProblem_QuestionType >(questiontype_);
}
inline void problemBankProblem::set_questiontype(::protobuf::srl::school::problemBankProblem_QuestionType value) {
  assert(::protobuf::srl::school::problemBankProblem_QuestionType_IsValid(value));
  set_has_questiontype();
  questiontype_ = value;
}

// optional bytes options = 4;
inline bool problemBankProblem::has_options() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void problemBankProblem::set_has_options() {
  _has_bits_[0] |= 0x00000008u;
}
inline void problemBankProblem::clear_has_options() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void problemBankProblem::clear_options() {
  if (options_ != &::google::protobuf::internal::kEmptyString) {
    options_->clear();
  }
  clear_has_options();
}
inline const ::std::string& problemBankProblem::options() const {
  return *options_;
}
inline void problemBankProblem::set_options(const ::std::string& value) {
  set_has_options();
  if (options_ == &::google::protobuf::internal::kEmptyString) {
    options_ = new ::std::string;
  }
  options_->assign(value);
}
inline void problemBankProblem::set_options(const char* value) {
  set_has_options();
  if (options_ == &::google::protobuf::internal::kEmptyString) {
    options_ = new ::std::string;
  }
  options_->assign(value);
}
inline void problemBankProblem::set_options(const void* value, size_t size) {
  set_has_options();
  if (options_ == &::google::protobuf::internal::kEmptyString) {
    options_ = new ::std::string;
  }
  options_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* problemBankProblem::mutable_options() {
  set_has_options();
  if (options_ == &::google::protobuf::internal::kEmptyString) {
    options_ = new ::std::string;
  }
  return options_;
}
inline ::std::string* problemBankProblem::release_options() {
  clear_has_options();
  if (options_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = options_;
    options_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void problemBankProblem::set_allocated_options(::std::string* options) {
  if (options_ != &::google::protobuf::internal::kEmptyString) {
    delete options_;
  }
  if (options) {
    set_has_options();
    options_ = options;
  } else {
    clear_has_options();
    options_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .protobuf.srl.school.SrlPermission accessPermission = 5;
inline bool problemBankProblem::has_accesspermission() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void problemBankProblem::set_has_accesspermission() {
  _has_bits_[0] |= 0x00000010u;
}
inline void problemBankProblem::clear_has_accesspermission() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void problemBankProblem::clear_accesspermission() {
  if (accesspermission_ != NULL) accesspermission_->::protobuf::srl::school::SrlPermission::Clear();
  clear_has_accesspermission();
}
inline const ::protobuf::srl::school::SrlPermission& problemBankProblem::accesspermission() const {
  return accesspermission_ != NULL ? *accesspermission_ : *default_instance_->accesspermission_;
}
inline ::protobuf::srl::school::SrlPermission* problemBankProblem::mutable_accesspermission() {
  set_has_accesspermission();
  if (accesspermission_ == NULL) accesspermission_ = new ::protobuf::srl::school::SrlPermission;
  return accesspermission_;
}
inline ::protobuf::srl::school::SrlPermission* problemBankProblem::release_accesspermission() {
  clear_has_accesspermission();
  ::protobuf::srl::school::SrlPermission* temp = accesspermission_;
  accesspermission_ = NULL;
  return temp;
}
inline void problemBankProblem::set_allocated_accesspermission(::protobuf::srl::school::SrlPermission* accesspermission) {
  delete accesspermission_;
  accesspermission_ = accesspermission;
  if (accesspermission) {
    set_has_accesspermission();
  } else {
    clear_has_accesspermission();
  }
}

// -------------------------------------------------------------------

// DateTime

// optional int32 year = 1;
inline bool DateTime::has_year() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DateTime::set_has_year() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DateTime::clear_has_year() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DateTime::clear_year() {
  year_ = 0;
  clear_has_year();
}
inline ::google::protobuf::int32 DateTime::year() const {
  return year_;
}
inline void DateTime::set_year(::google::protobuf::int32 value) {
  set_has_year();
  year_ = value;
}

// optional int32 month = 2;
inline bool DateTime::has_month() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DateTime::set_has_month() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DateTime::clear_has_month() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DateTime::clear_month() {
  month_ = 0;
  clear_has_month();
}
inline ::google::protobuf::int32 DateTime::month() const {
  return month_;
}
inline void DateTime::set_month(::google::protobuf::int32 value) {
  set_has_month();
  month_ = value;
}

// optional int32 day = 3;
inline bool DateTime::has_day() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DateTime::set_has_day() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DateTime::clear_has_day() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DateTime::clear_day() {
  day_ = 0;
  clear_has_day();
}
inline ::google::protobuf::int32 DateTime::day() const {
  return day_;
}
inline void DateTime::set_day(::google::protobuf::int32 value) {
  set_has_day();
  day_ = value;
}

// optional int32 hour = 4;
inline bool DateTime::has_hour() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DateTime::set_has_hour() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DateTime::clear_has_hour() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DateTime::clear_hour() {
  hour_ = 0;
  clear_has_hour();
}
inline ::google::protobuf::int32 DateTime::hour() const {
  return hour_;
}
inline void DateTime::set_hour(::google::protobuf::int32 value) {
  set_has_hour();
  hour_ = value;
}

// optional int32 minute = 5;
inline bool DateTime::has_minute() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DateTime::set_has_minute() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DateTime::clear_has_minute() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DateTime::clear_minute() {
  minute_ = 0;
  clear_has_minute();
}
inline ::google::protobuf::int32 DateTime::minute() const {
  return minute_;
}
inline void DateTime::set_minute(::google::protobuf::int32 value) {
  set_has_minute();
  minute_ = value;
}

// optional int32 second = 6;
inline bool DateTime::has_second() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DateTime::set_has_second() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DateTime::clear_has_second() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DateTime::clear_second() {
  second_ = 0;
  clear_has_second();
}
inline ::google::protobuf::int32 DateTime::second() const {
  return second_;
}
inline void DateTime::set_second(::google::protobuf::int32 value) {
  set_has_second();
  second_ = value;
}

// optional uint64 millisecond = 7;
inline bool DateTime::has_millisecond() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DateTime::set_has_millisecond() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DateTime::clear_has_millisecond() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DateTime::clear_millisecond() {
  millisecond_ = GOOGLE_ULONGLONG(0);
  clear_has_millisecond();
}
inline ::google::protobuf::uint64 DateTime::millisecond() const {
  return millisecond_;
}
inline void DateTime::set_millisecond(::google::protobuf::uint64 value) {
  set_has_millisecond();
  millisecond_ = value;
}

// -------------------------------------------------------------------

// DomainInformation

// optional string stuff = 1;
inline bool DomainInformation::has_stuff() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DomainInformation::set_has_stuff() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DomainInformation::clear_has_stuff() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DomainInformation::clear_stuff() {
  if (stuff_ != &::google::protobuf::internal::kEmptyString) {
    stuff_->clear();
  }
  clear_has_stuff();
}
inline const ::std::string& DomainInformation::stuff() const {
  return *stuff_;
}
inline void DomainInformation::set_stuff(const ::std::string& value) {
  set_has_stuff();
  if (stuff_ == &::google::protobuf::internal::kEmptyString) {
    stuff_ = new ::std::string;
  }
  stuff_->assign(value);
}
inline void DomainInformation::set_stuff(const char* value) {
  set_has_stuff();
  if (stuff_ == &::google::protobuf::internal::kEmptyString) {
    stuff_ = new ::std::string;
  }
  stuff_->assign(value);
}
inline void DomainInformation::set_stuff(const char* value, size_t size) {
  set_has_stuff();
  if (stuff_ == &::google::protobuf::internal::kEmptyString) {
    stuff_ = new ::std::string;
  }
  stuff_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DomainInformation::mutable_stuff() {
  set_has_stuff();
  if (stuff_ == &::google::protobuf::internal::kEmptyString) {
    stuff_ = new ::std::string;
  }
  return stuff_;
}
inline ::std::string* DomainInformation::release_stuff() {
  clear_has_stuff();
  if (stuff_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stuff_;
    stuff_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DomainInformation::set_allocated_stuff(::std::string* stuff) {
  if (stuff_ != &::google::protobuf::internal::kEmptyString) {
    delete stuff_;
  }
  if (stuff) {
    set_has_stuff();
    stuff_ = stuff;
  } else {
    clear_has_stuff();
    stuff_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// State

// optional bool published = 1;
inline bool State::has_published() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void State::set_has_published() {
  _has_bits_[0] |= 0x00000001u;
}
inline void State::clear_has_published() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void State::clear_published() {
  published_ = false;
  clear_has_published();
}
inline bool State::published() const {
  return published_;
}
inline void State::set_published(bool value) {
  set_has_published();
  published_ = value;
}

// optional bool accessible = 2;
inline bool State::has_accessible() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void State::set_has_accessible() {
  _has_bits_[0] |= 0x00000002u;
}
inline void State::clear_has_accessible() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void State::clear_accessible() {
  accessible_ = false;
  clear_has_accessible();
}
inline bool State::accessible() const {
  return accessible_;
}
inline void State::set_accessible(bool value) {
  set_has_accessible();
  accessible_ = value;
}

// optional bool pastDue = 3;
inline bool State::has_pastdue() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void State::set_has_pastdue() {
  _has_bits_[0] |= 0x00000004u;
}
inline void State::clear_has_pastdue() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void State::clear_pastdue() {
  pastdue_ = false;
  clear_has_pastdue();
}
inline bool State::pastdue() const {
  return pastdue_;
}
inline void State::set_pastdue(bool value) {
  set_has_pastdue();
  pastdue_ = value;
}

// optional bool started = 4;
inline bool State::has_started() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void State::set_has_started() {
  _has_bits_[0] |= 0x00000008u;
}
inline void State::clear_has_started() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void State::clear_started() {
  started_ = false;
  clear_has_started();
}
inline bool State::started() const {
  return started_;
}
inline void State::set_started(bool value) {
  set_has_started();
  started_ = value;
}

// optional bool completed = 5;
inline bool State::has_completed() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void State::set_has_completed() {
  _has_bits_[0] |= 0x00000010u;
}
inline void State::clear_has_completed() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void State::clear_completed() {
  completed_ = false;
  clear_has_completed();
}
inline bool State::completed() const {
  return completed_;
}
inline void State::set_completed(bool value) {
  set_has_completed();
  completed_ = value;
}

// -------------------------------------------------------------------

// SrlUser

// required string username = 1;
inline bool SrlUser::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SrlUser::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SrlUser::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SrlUser::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& SrlUser::username() const {
  return *username_;
}
inline void SrlUser::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void SrlUser::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void SrlUser::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlUser::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* SrlUser::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlUser::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .protobuf.srl.school.UserType userType = 2 [default = GUEST];
inline bool SrlUser::has_usertype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SrlUser::set_has_usertype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SrlUser::clear_has_usertype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SrlUser::clear_usertype() {
  usertype_ = 5;
  clear_has_usertype();
}
inline ::protobuf::srl::school::UserType SrlUser::usertype() const {
  return static_cast< ::protobuf::srl::school::UserType >(usertype_);
}
inline void SrlUser::set_usertype(::protobuf::srl::school::UserType value) {
  assert(::protobuf::srl::school::UserType_IsValid(value));
  set_has_usertype();
  usertype_ = value;
}

// optional string email = 3;
inline bool SrlUser::has_email() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SrlUser::set_has_email() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SrlUser::clear_has_email() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SrlUser::clear_email() {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& SrlUser::email() const {
  return *email_;
}
inline void SrlUser::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void SrlUser::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void SrlUser::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlUser::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  return email_;
}
inline ::std::string* SrlUser::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlUser::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SrlGroup

// repeated string userId = 1;
inline int SrlGroup::userid_size() const {
  return userid_.size();
}
inline void SrlGroup::clear_userid() {
  userid_.Clear();
}
inline const ::std::string& SrlGroup::userid(int index) const {
  return userid_.Get(index);
}
inline ::std::string* SrlGroup::mutable_userid(int index) {
  return userid_.Mutable(index);
}
inline void SrlGroup::set_userid(int index, const ::std::string& value) {
  userid_.Mutable(index)->assign(value);
}
inline void SrlGroup::set_userid(int index, const char* value) {
  userid_.Mutable(index)->assign(value);
}
inline void SrlGroup::set_userid(int index, const char* value, size_t size) {
  userid_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlGroup::add_userid() {
  return userid_.Add();
}
inline void SrlGroup::add_userid(const ::std::string& value) {
  userid_.Add()->assign(value);
}
inline void SrlGroup::add_userid(const char* value) {
  userid_.Add()->assign(value);
}
inline void SrlGroup::add_userid(const char* value, size_t size) {
  userid_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SrlGroup::userid() const {
  return userid_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SrlGroup::mutable_userid() {
  return &userid_;
}

// required string groupId = 2;
inline bool SrlGroup::has_groupid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SrlGroup::set_has_groupid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SrlGroup::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SrlGroup::clear_groupid() {
  if (groupid_ != &::google::protobuf::internal::kEmptyString) {
    groupid_->clear();
  }
  clear_has_groupid();
}
inline const ::std::string& SrlGroup::groupid() const {
  return *groupid_;
}
inline void SrlGroup::set_groupid(const ::std::string& value) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(value);
}
inline void SrlGroup::set_groupid(const char* value) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(value);
}
inline void SrlGroup::set_groupid(const char* value, size_t size) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlGroup::mutable_groupid() {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  return groupid_;
}
inline ::std::string* SrlGroup::release_groupid() {
  clear_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = groupid_;
    groupid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlGroup::set_allocated_groupid(::std::string* groupid) {
  if (groupid_ != &::google::protobuf::internal::kEmptyString) {
    delete groupid_;
  }
  if (groupid) {
    set_has_groupid();
    groupid_ = groupid;
  } else {
    clear_has_groupid();
    groupid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string groupName = 3;
inline bool SrlGroup::has_groupname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SrlGroup::set_has_groupname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SrlGroup::clear_has_groupname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SrlGroup::clear_groupname() {
  if (groupname_ != &::google::protobuf::internal::kEmptyString) {
    groupname_->clear();
  }
  clear_has_groupname();
}
inline const ::std::string& SrlGroup::groupname() const {
  return *groupname_;
}
inline void SrlGroup::set_groupname(const ::std::string& value) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(value);
}
inline void SrlGroup::set_groupname(const char* value) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(value);
}
inline void SrlGroup::set_groupname(const char* value, size_t size) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlGroup::mutable_groupname() {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  return groupname_;
}
inline ::std::string* SrlGroup::release_groupname() {
  clear_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = groupname_;
    groupname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlGroup::set_allocated_groupname(::std::string* groupname) {
  if (groupname_ != &::google::protobuf::internal::kEmptyString) {
    delete groupname_;
  }
  if (groupname) {
    set_has_groupname();
    groupname_ = groupname;
  } else {
    clear_has_groupname();
    groupname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SrlSchoolId

// optional string courseId = 1;
inline bool SrlSchoolId::has_courseid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SrlSchoolId::set_has_courseid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SrlSchoolId::clear_has_courseid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SrlSchoolId::clear_courseid() {
  if (courseid_ != &::google::protobuf::internal::kEmptyString) {
    courseid_->clear();
  }
  clear_has_courseid();
}
inline const ::std::string& SrlSchoolId::courseid() const {
  return *courseid_;
}
inline void SrlSchoolId::set_courseid(const ::std::string& value) {
  set_has_courseid();
  if (courseid_ == &::google::protobuf::internal::kEmptyString) {
    courseid_ = new ::std::string;
  }
  courseid_->assign(value);
}
inline void SrlSchoolId::set_courseid(const char* value) {
  set_has_courseid();
  if (courseid_ == &::google::protobuf::internal::kEmptyString) {
    courseid_ = new ::std::string;
  }
  courseid_->assign(value);
}
inline void SrlSchoolId::set_courseid(const char* value, size_t size) {
  set_has_courseid();
  if (courseid_ == &::google::protobuf::internal::kEmptyString) {
    courseid_ = new ::std::string;
  }
  courseid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlSchoolId::mutable_courseid() {
  set_has_courseid();
  if (courseid_ == &::google::protobuf::internal::kEmptyString) {
    courseid_ = new ::std::string;
  }
  return courseid_;
}
inline ::std::string* SrlSchoolId::release_courseid() {
  clear_has_courseid();
  if (courseid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = courseid_;
    courseid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlSchoolId::set_allocated_courseid(::std::string* courseid) {
  if (courseid_ != &::google::protobuf::internal::kEmptyString) {
    delete courseid_;
  }
  if (courseid) {
    set_has_courseid();
    courseid_ = courseid;
  } else {
    clear_has_courseid();
    courseid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string assignmentId = 2;
inline bool SrlSchoolId::has_assignmentid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SrlSchoolId::set_has_assignmentid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SrlSchoolId::clear_has_assignmentid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SrlSchoolId::clear_assignmentid() {
  if (assignmentid_ != &::google::protobuf::internal::kEmptyString) {
    assignmentid_->clear();
  }
  clear_has_assignmentid();
}
inline const ::std::string& SrlSchoolId::assignmentid() const {
  return *assignmentid_;
}
inline void SrlSchoolId::set_assignmentid(const ::std::string& value) {
  set_has_assignmentid();
  if (assignmentid_ == &::google::protobuf::internal::kEmptyString) {
    assignmentid_ = new ::std::string;
  }
  assignmentid_->assign(value);
}
inline void SrlSchoolId::set_assignmentid(const char* value) {
  set_has_assignmentid();
  if (assignmentid_ == &::google::protobuf::internal::kEmptyString) {
    assignmentid_ = new ::std::string;
  }
  assignmentid_->assign(value);
}
inline void SrlSchoolId::set_assignmentid(const char* value, size_t size) {
  set_has_assignmentid();
  if (assignmentid_ == &::google::protobuf::internal::kEmptyString) {
    assignmentid_ = new ::std::string;
  }
  assignmentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlSchoolId::mutable_assignmentid() {
  set_has_assignmentid();
  if (assignmentid_ == &::google::protobuf::internal::kEmptyString) {
    assignmentid_ = new ::std::string;
  }
  return assignmentid_;
}
inline ::std::string* SrlSchoolId::release_assignmentid() {
  clear_has_assignmentid();
  if (assignmentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = assignmentid_;
    assignmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlSchoolId::set_allocated_assignmentid(::std::string* assignmentid) {
  if (assignmentid_ != &::google::protobuf::internal::kEmptyString) {
    delete assignmentid_;
  }
  if (assignmentid) {
    set_has_assignmentid();
    assignmentid_ = assignmentid;
  } else {
    clear_has_assignmentid();
    assignmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string problemId = 3;
inline bool SrlSchoolId::has_problemid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SrlSchoolId::set_has_problemid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SrlSchoolId::clear_has_problemid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SrlSchoolId::clear_problemid() {
  if (problemid_ != &::google::protobuf::internal::kEmptyString) {
    problemid_->clear();
  }
  clear_has_problemid();
}
inline const ::std::string& SrlSchoolId::problemid() const {
  return *problemid_;
}
inline void SrlSchoolId::set_problemid(const ::std::string& value) {
  set_has_problemid();
  if (problemid_ == &::google::protobuf::internal::kEmptyString) {
    problemid_ = new ::std::string;
  }
  problemid_->assign(value);
}
inline void SrlSchoolId::set_problemid(const char* value) {
  set_has_problemid();
  if (problemid_ == &::google::protobuf::internal::kEmptyString) {
    problemid_ = new ::std::string;
  }
  problemid_->assign(value);
}
inline void SrlSchoolId::set_problemid(const char* value, size_t size) {
  set_has_problemid();
  if (problemid_ == &::google::protobuf::internal::kEmptyString) {
    problemid_ = new ::std::string;
  }
  problemid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlSchoolId::mutable_problemid() {
  set_has_problemid();
  if (problemid_ == &::google::protobuf::internal::kEmptyString) {
    problemid_ = new ::std::string;
  }
  return problemid_;
}
inline ::std::string* SrlSchoolId::release_problemid() {
  clear_has_problemid();
  if (problemid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = problemid_;
    problemid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlSchoolId::set_allocated_problemid(::std::string* problemid) {
  if (problemid_ != &::google::protobuf::internal::kEmptyString) {
    delete problemid_;
  }
  if (problemid) {
    set_has_problemid();
    problemid_ = problemid;
  } else {
    clear_has_problemid();
    problemid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SrlPermission

// repeated string adminPermission = 1;
inline int SrlPermission::adminpermission_size() const {
  return adminpermission_.size();
}
inline void SrlPermission::clear_adminpermission() {
  adminpermission_.Clear();
}
inline const ::std::string& SrlPermission::adminpermission(int index) const {
  return adminpermission_.Get(index);
}
inline ::std::string* SrlPermission::mutable_adminpermission(int index) {
  return adminpermission_.Mutable(index);
}
inline void SrlPermission::set_adminpermission(int index, const ::std::string& value) {
  adminpermission_.Mutable(index)->assign(value);
}
inline void SrlPermission::set_adminpermission(int index, const char* value) {
  adminpermission_.Mutable(index)->assign(value);
}
inline void SrlPermission::set_adminpermission(int index, const char* value, size_t size) {
  adminpermission_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlPermission::add_adminpermission() {
  return adminpermission_.Add();
}
inline void SrlPermission::add_adminpermission(const ::std::string& value) {
  adminpermission_.Add()->assign(value);
}
inline void SrlPermission::add_adminpermission(const char* value) {
  adminpermission_.Add()->assign(value);
}
inline void SrlPermission::add_adminpermission(const char* value, size_t size) {
  adminpermission_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SrlPermission::adminpermission() const {
  return adminpermission_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SrlPermission::mutable_adminpermission() {
  return &adminpermission_;
}

// repeated string moderatorPermission = 2;
inline int SrlPermission::moderatorpermission_size() const {
  return moderatorpermission_.size();
}
inline void SrlPermission::clear_moderatorpermission() {
  moderatorpermission_.Clear();
}
inline const ::std::string& SrlPermission::moderatorpermission(int index) const {
  return moderatorpermission_.Get(index);
}
inline ::std::string* SrlPermission::mutable_moderatorpermission(int index) {
  return moderatorpermission_.Mutable(index);
}
inline void SrlPermission::set_moderatorpermission(int index, const ::std::string& value) {
  moderatorpermission_.Mutable(index)->assign(value);
}
inline void SrlPermission::set_moderatorpermission(int index, const char* value) {
  moderatorpermission_.Mutable(index)->assign(value);
}
inline void SrlPermission::set_moderatorpermission(int index, const char* value, size_t size) {
  moderatorpermission_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlPermission::add_moderatorpermission() {
  return moderatorpermission_.Add();
}
inline void SrlPermission::add_moderatorpermission(const ::std::string& value) {
  moderatorpermission_.Add()->assign(value);
}
inline void SrlPermission::add_moderatorpermission(const char* value) {
  moderatorpermission_.Add()->assign(value);
}
inline void SrlPermission::add_moderatorpermission(const char* value, size_t size) {
  moderatorpermission_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SrlPermission::moderatorpermission() const {
  return moderatorpermission_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SrlPermission::mutable_moderatorpermission() {
  return &moderatorpermission_;
}

// repeated string userPermission = 3;
inline int SrlPermission::userpermission_size() const {
  return userpermission_.size();
}
inline void SrlPermission::clear_userpermission() {
  userpermission_.Clear();
}
inline const ::std::string& SrlPermission::userpermission(int index) const {
  return userpermission_.Get(index);
}
inline ::std::string* SrlPermission::mutable_userpermission(int index) {
  return userpermission_.Mutable(index);
}
inline void SrlPermission::set_userpermission(int index, const ::std::string& value) {
  userpermission_.Mutable(index)->assign(value);
}
inline void SrlPermission::set_userpermission(int index, const char* value) {
  userpermission_.Mutable(index)->assign(value);
}
inline void SrlPermission::set_userpermission(int index, const char* value, size_t size) {
  userpermission_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlPermission::add_userpermission() {
  return userpermission_.Add();
}
inline void SrlPermission::add_userpermission(const ::std::string& value) {
  userpermission_.Add()->assign(value);
}
inline void SrlPermission::add_userpermission(const char* value) {
  userpermission_.Add()->assign(value);
}
inline void SrlPermission::add_userpermission(const char* value, size_t size) {
  userpermission_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SrlPermission::userpermission() const {
  return userpermission_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SrlPermission::mutable_userpermission() {
  return &userpermission_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace school
}  // namespace srl
}  // namespace protobuf

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protobuf::srl::school::SrlCourse_Accessibility>() {
  return ::protobuf::srl::school::SrlCourse_Accessibility_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protobuf::srl::school::SrlAssignment_AssignmentType>() {
  return ::protobuf::srl::school::SrlAssignment_AssignmentType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protobuf::srl::school::SrlAssignment_LatePolicy>() {
  return ::protobuf::srl::school::SrlAssignment_LatePolicy_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protobuf::srl::school::problemBankProblem_QuestionType>() {
  return ::protobuf::srl::school::problemBankProblem_QuestionType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protobuf::srl::school::UserType>() {
  return ::protobuf::srl::school::UserType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_input_2fschool_2eproto__INCLUDED
