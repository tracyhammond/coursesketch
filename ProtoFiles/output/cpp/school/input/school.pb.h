// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: input/school.proto

#ifndef PROTOBUF_input_2fschool_2eproto__INCLUDED
#define PROTOBUF_input_2fschool_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf {
namespace srl {
namespace school {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_input_2fschool_2eproto();
void protobuf_AssignDesc_input_2fschool_2eproto();
void protobuf_ShutdownFile_input_2fschool_2eproto();

class SRL_School;
class SRL_Course;
class SRL_Assignment;
class SRL_Problem;
class subproblemInformation;

enum subproblemInformation_QuestionType {
  subproblemInformation_QuestionType_SKETCH = 1,
  subproblemInformation_QuestionType_MULT_CHOICE = 2,
  subproblemInformation_QuestionType_FREE_RESP = 3,
  subproblemInformation_QuestionType_CHECK_BOX = 4
};
bool subproblemInformation_QuestionType_IsValid(int value);
const subproblemInformation_QuestionType subproblemInformation_QuestionType_QuestionType_MIN = subproblemInformation_QuestionType_SKETCH;
const subproblemInformation_QuestionType subproblemInformation_QuestionType_QuestionType_MAX = subproblemInformation_QuestionType_CHECK_BOX;
const int subproblemInformation_QuestionType_QuestionType_ARRAYSIZE = subproblemInformation_QuestionType_QuestionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* subproblemInformation_QuestionType_descriptor();
inline const ::std::string& subproblemInformation_QuestionType_Name(subproblemInformation_QuestionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    subproblemInformation_QuestionType_descriptor(), value);
}
inline bool subproblemInformation_QuestionType_Parse(
    const ::std::string& name, subproblemInformation_QuestionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<subproblemInformation_QuestionType>(
    subproblemInformation_QuestionType_descriptor(), name, value);
}
// ===================================================================

class SRL_School : public ::google::protobuf::Message {
 public:
  SRL_School();
  virtual ~SRL_School();

  SRL_School(const SRL_School& from);

  inline SRL_School& operator=(const SRL_School& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SRL_School& default_instance();

  void Swap(SRL_School* other);

  // implements Message ----------------------------------------------

  SRL_School* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SRL_School& from);
  void MergeFrom(const SRL_School& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protobuf.srl.school.SRL_Course courses = 1;
  inline int courses_size() const;
  inline void clear_courses();
  static const int kCoursesFieldNumber = 1;
  inline const ::protobuf::srl::school::SRL_Course& courses(int index) const;
  inline ::protobuf::srl::school::SRL_Course* mutable_courses(int index);
  inline ::protobuf::srl::school::SRL_Course* add_courses();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SRL_Course >&
      courses() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SRL_Course >*
      mutable_courses();

  // repeated .protobuf.srl.school.SRL_Assignment assignments = 2;
  inline int assignments_size() const;
  inline void clear_assignments();
  static const int kAssignmentsFieldNumber = 2;
  inline const ::protobuf::srl::school::SRL_Assignment& assignments(int index) const;
  inline ::protobuf::srl::school::SRL_Assignment* mutable_assignments(int index);
  inline ::protobuf::srl::school::SRL_Assignment* add_assignments();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SRL_Assignment >&
      assignments() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SRL_Assignment >*
      mutable_assignments();

  // repeated .protobuf.srl.school.SRL_Problem problems = 3;
  inline int problems_size() const;
  inline void clear_problems();
  static const int kProblemsFieldNumber = 3;
  inline const ::protobuf::srl::school::SRL_Problem& problems(int index) const;
  inline ::protobuf::srl::school::SRL_Problem* mutable_problems(int index);
  inline ::protobuf::srl::school::SRL_Problem* add_problems();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SRL_Problem >&
      problems() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SRL_Problem >*
      mutable_problems();

  // @@protoc_insertion_point(class_scope:protobuf.srl.school.SRL_School)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SRL_Course > courses_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SRL_Assignment > assignments_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SRL_Problem > problems_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_input_2fschool_2eproto();
  friend void protobuf_AssignDesc_input_2fschool_2eproto();
  friend void protobuf_ShutdownFile_input_2fschool_2eproto();

  void InitAsDefaultInstance();
  static SRL_School* default_instance_;
};
// -------------------------------------------------------------------

class SRL_Course : public ::google::protobuf::Message {
 public:
  SRL_Course();
  virtual ~SRL_Course();

  SRL_Course(const SRL_Course& from);

  inline SRL_Course& operator=(const SRL_Course& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SRL_Course& default_instance();

  void Swap(SRL_Course* other);

  // implements Message ----------------------------------------------

  SRL_Course* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SRL_Course& from);
  void MergeFrom(const SRL_Course& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string courseId = 1;
  inline bool has_courseid() const;
  inline void clear_courseid();
  static const int kCourseIdFieldNumber = 1;
  inline const ::std::string& courseid() const;
  inline void set_courseid(const ::std::string& value);
  inline void set_courseid(const char* value);
  inline void set_courseid(const char* value, size_t size);
  inline ::std::string* mutable_courseid();
  inline ::std::string* release_courseid();
  inline void set_allocated_courseid(::std::string* courseid);

  // optional string courseName = 2;
  inline bool has_coursename() const;
  inline void clear_coursename();
  static const int kCourseNameFieldNumber = 2;
  inline const ::std::string& coursename() const;
  inline void set_coursename(const ::std::string& value);
  inline void set_coursename(const char* value);
  inline void set_coursename(const char* value, size_t size);
  inline ::std::string* mutable_coursename();
  inline ::std::string* release_coursename();
  inline void set_allocated_coursename(::std::string* coursename);

  // @@protoc_insertion_point(class_scope:protobuf.srl.school.SRL_Course)
 private:
  inline void set_has_courseid();
  inline void clear_has_courseid();
  inline void set_has_coursename();
  inline void clear_has_coursename();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* courseid_;
  ::std::string* coursename_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_input_2fschool_2eproto();
  friend void protobuf_AssignDesc_input_2fschool_2eproto();
  friend void protobuf_ShutdownFile_input_2fschool_2eproto();

  void InitAsDefaultInstance();
  static SRL_Course* default_instance_;
};
// -------------------------------------------------------------------

class SRL_Assignment : public ::google::protobuf::Message {
 public:
  SRL_Assignment();
  virtual ~SRL_Assignment();

  SRL_Assignment(const SRL_Assignment& from);

  inline SRL_Assignment& operator=(const SRL_Assignment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SRL_Assignment& default_instance();

  void Swap(SRL_Assignment* other);

  // implements Message ----------------------------------------------

  SRL_Assignment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SRL_Assignment& from);
  void MergeFrom(const SRL_Assignment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 courseId = 1;
  inline bool has_courseid() const;
  inline void clear_courseid();
  static const int kCourseIdFieldNumber = 1;
  inline ::google::protobuf::uint64 courseid() const;
  inline void set_courseid(::google::protobuf::uint64 value);

  // required string assignmentId = 2;
  inline bool has_assignmentid() const;
  inline void clear_assignmentid();
  static const int kAssignmentIdFieldNumber = 2;
  inline const ::std::string& assignmentid() const;
  inline void set_assignmentid(const ::std::string& value);
  inline void set_assignmentid(const char* value);
  inline void set_assignmentid(const char* value, size_t size);
  inline ::std::string* mutable_assignmentid();
  inline ::std::string* release_assignmentid();
  inline void set_allocated_assignmentid(::std::string* assignmentid);

  // optional string assignmentName = 3;
  inline bool has_assignmentname() const;
  inline void clear_assignmentname();
  static const int kAssignmentNameFieldNumber = 3;
  inline const ::std::string& assignmentname() const;
  inline void set_assignmentname(const ::std::string& value);
  inline void set_assignmentname(const char* value);
  inline void set_assignmentname(const char* value, size_t size);
  inline ::std::string* mutable_assignmentname();
  inline ::std::string* release_assignmentname();
  inline void set_allocated_assignmentname(::std::string* assignmentname);

  // @@protoc_insertion_point(class_scope:protobuf.srl.school.SRL_Assignment)
 private:
  inline void set_has_courseid();
  inline void clear_has_courseid();
  inline void set_has_assignmentid();
  inline void clear_has_assignmentid();
  inline void set_has_assignmentname();
  inline void clear_has_assignmentname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 courseid_;
  ::std::string* assignmentid_;
  ::std::string* assignmentname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_input_2fschool_2eproto();
  friend void protobuf_AssignDesc_input_2fschool_2eproto();
  friend void protobuf_ShutdownFile_input_2fschool_2eproto();

  void InitAsDefaultInstance();
  static SRL_Assignment* default_instance_;
};
// -------------------------------------------------------------------

class SRL_Problem : public ::google::protobuf::Message {
 public:
  SRL_Problem();
  virtual ~SRL_Problem();

  SRL_Problem(const SRL_Problem& from);

  inline SRL_Problem& operator=(const SRL_Problem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SRL_Problem& default_instance();

  void Swap(SRL_Problem* other);

  // implements Message ----------------------------------------------

  SRL_Problem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SRL_Problem& from);
  void MergeFrom(const SRL_Problem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 courseId = 1;
  inline bool has_courseid() const;
  inline void clear_courseid();
  static const int kCourseIdFieldNumber = 1;
  inline ::google::protobuf::uint64 courseid() const;
  inline void set_courseid(::google::protobuf::uint64 value);

  // required uint64 assignmentId = 2;
  inline bool has_assignmentid() const;
  inline void clear_assignmentid();
  static const int kAssignmentIdFieldNumber = 2;
  inline ::google::protobuf::uint64 assignmentid() const;
  inline void set_assignmentid(::google::protobuf::uint64 value);

  // required string problemId = 3;
  inline bool has_problemid() const;
  inline void clear_problemid();
  static const int kProblemIdFieldNumber = 3;
  inline const ::std::string& problemid() const;
  inline void set_problemid(const ::std::string& value);
  inline void set_problemid(const char* value);
  inline void set_problemid(const char* value, size_t size);
  inline ::std::string* mutable_problemid();
  inline ::std::string* release_problemid();
  inline void set_allocated_problemid(::std::string* problemid);

  // optional string problemName = 4;
  inline bool has_problemname() const;
  inline void clear_problemname();
  static const int kProblemNameFieldNumber = 4;
  inline const ::std::string& problemname() const;
  inline void set_problemname(const ::std::string& value);
  inline void set_problemname(const char* value);
  inline void set_problemname(const char* value, size_t size);
  inline ::std::string* mutable_problemname();
  inline ::std::string* release_problemname();
  inline void set_allocated_problemname(::std::string* problemname);

  // optional .protobuf.srl.school.subproblemInformation mainProblem = 5;
  inline bool has_mainproblem() const;
  inline void clear_mainproblem();
  static const int kMainProblemFieldNumber = 5;
  inline const ::protobuf::srl::school::subproblemInformation& mainproblem() const;
  inline ::protobuf::srl::school::subproblemInformation* mutable_mainproblem();
  inline ::protobuf::srl::school::subproblemInformation* release_mainproblem();
  inline void set_allocated_mainproblem(::protobuf::srl::school::subproblemInformation* mainproblem);

  // repeated .protobuf.srl.school.subproblemInformation subProblems = 6;
  inline int subproblems_size() const;
  inline void clear_subproblems();
  static const int kSubProblemsFieldNumber = 6;
  inline const ::protobuf::srl::school::subproblemInformation& subproblems(int index) const;
  inline ::protobuf::srl::school::subproblemInformation* mutable_subproblems(int index);
  inline ::protobuf::srl::school::subproblemInformation* add_subproblems();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::subproblemInformation >&
      subproblems() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::subproblemInformation >*
      mutable_subproblems();

  // @@protoc_insertion_point(class_scope:protobuf.srl.school.SRL_Problem)
 private:
  inline void set_has_courseid();
  inline void clear_has_courseid();
  inline void set_has_assignmentid();
  inline void clear_has_assignmentid();
  inline void set_has_problemid();
  inline void clear_has_problemid();
  inline void set_has_problemname();
  inline void clear_has_problemname();
  inline void set_has_mainproblem();
  inline void clear_has_mainproblem();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 courseid_;
  ::google::protobuf::uint64 assignmentid_;
  ::std::string* problemid_;
  ::std::string* problemname_;
  ::protobuf::srl::school::subproblemInformation* mainproblem_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::subproblemInformation > subproblems_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_input_2fschool_2eproto();
  friend void protobuf_AssignDesc_input_2fschool_2eproto();
  friend void protobuf_ShutdownFile_input_2fschool_2eproto();

  void InitAsDefaultInstance();
  static SRL_Problem* default_instance_;
};
// -------------------------------------------------------------------

class subproblemInformation : public ::google::protobuf::Message {
 public:
  subproblemInformation();
  virtual ~subproblemInformation();

  subproblemInformation(const subproblemInformation& from);

  inline subproblemInformation& operator=(const subproblemInformation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const subproblemInformation& default_instance();

  void Swap(subproblemInformation* other);

  // implements Message ----------------------------------------------

  subproblemInformation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const subproblemInformation& from);
  void MergeFrom(const subproblemInformation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef subproblemInformation_QuestionType QuestionType;
  static const QuestionType SKETCH = subproblemInformation_QuestionType_SKETCH;
  static const QuestionType MULT_CHOICE = subproblemInformation_QuestionType_MULT_CHOICE;
  static const QuestionType FREE_RESP = subproblemInformation_QuestionType_FREE_RESP;
  static const QuestionType CHECK_BOX = subproblemInformation_QuestionType_CHECK_BOX;
  static inline bool QuestionType_IsValid(int value) {
    return subproblemInformation_QuestionType_IsValid(value);
  }
  static const QuestionType QuestionType_MIN =
    subproblemInformation_QuestionType_QuestionType_MIN;
  static const QuestionType QuestionType_MAX =
    subproblemInformation_QuestionType_QuestionType_MAX;
  static const int QuestionType_ARRAYSIZE =
    subproblemInformation_QuestionType_QuestionType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  QuestionType_descriptor() {
    return subproblemInformation_QuestionType_descriptor();
  }
  static inline const ::std::string& QuestionType_Name(QuestionType value) {
    return subproblemInformation_QuestionType_Name(value);
  }
  static inline bool QuestionType_Parse(const ::std::string& name,
      QuestionType* value) {
    return subproblemInformation_QuestionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string questionText = 1;
  inline bool has_questiontext() const;
  inline void clear_questiontext();
  static const int kQuestionTextFieldNumber = 1;
  inline const ::std::string& questiontext() const;
  inline void set_questiontext(const ::std::string& value);
  inline void set_questiontext(const char* value);
  inline void set_questiontext(const char* value, size_t size);
  inline ::std::string* mutable_questiontext();
  inline ::std::string* release_questiontext();
  inline void set_allocated_questiontext(::std::string* questiontext);

  // optional .protobuf.srl.school.subproblemInformation.QuestionType questionType = 2 [default = SKETCH];
  inline bool has_questiontype() const;
  inline void clear_questiontype();
  static const int kQuestionTypeFieldNumber = 2;
  inline ::protobuf::srl::school::subproblemInformation_QuestionType questiontype() const;
  inline void set_questiontype(::protobuf::srl::school::subproblemInformation_QuestionType value);

  // optional bytes options = 3;
  inline bool has_options() const;
  inline void clear_options();
  static const int kOptionsFieldNumber = 3;
  inline const ::std::string& options() const;
  inline void set_options(const ::std::string& value);
  inline void set_options(const char* value);
  inline void set_options(const void* value, size_t size);
  inline ::std::string* mutable_options();
  inline ::std::string* release_options();
  inline void set_allocated_options(::std::string* options);

  // @@protoc_insertion_point(class_scope:protobuf.srl.school.subproblemInformation)
 private:
  inline void set_has_questiontext();
  inline void clear_has_questiontext();
  inline void set_has_questiontype();
  inline void clear_has_questiontype();
  inline void set_has_options();
  inline void clear_has_options();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* questiontext_;
  ::std::string* options_;
  int questiontype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_input_2fschool_2eproto();
  friend void protobuf_AssignDesc_input_2fschool_2eproto();
  friend void protobuf_ShutdownFile_input_2fschool_2eproto();

  void InitAsDefaultInstance();
  static subproblemInformation* default_instance_;
};
// ===================================================================


// ===================================================================

// SRL_School

// repeated .protobuf.srl.school.SRL_Course courses = 1;
inline int SRL_School::courses_size() const {
  return courses_.size();
}
inline void SRL_School::clear_courses() {
  courses_.Clear();
}
inline const ::protobuf::srl::school::SRL_Course& SRL_School::courses(int index) const {
  return courses_.Get(index);
}
inline ::protobuf::srl::school::SRL_Course* SRL_School::mutable_courses(int index) {
  return courses_.Mutable(index);
}
inline ::protobuf::srl::school::SRL_Course* SRL_School::add_courses() {
  return courses_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SRL_Course >&
SRL_School::courses() const {
  return courses_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SRL_Course >*
SRL_School::mutable_courses() {
  return &courses_;
}

// repeated .protobuf.srl.school.SRL_Assignment assignments = 2;
inline int SRL_School::assignments_size() const {
  return assignments_.size();
}
inline void SRL_School::clear_assignments() {
  assignments_.Clear();
}
inline const ::protobuf::srl::school::SRL_Assignment& SRL_School::assignments(int index) const {
  return assignments_.Get(index);
}
inline ::protobuf::srl::school::SRL_Assignment* SRL_School::mutable_assignments(int index) {
  return assignments_.Mutable(index);
}
inline ::protobuf::srl::school::SRL_Assignment* SRL_School::add_assignments() {
  return assignments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SRL_Assignment >&
SRL_School::assignments() const {
  return assignments_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SRL_Assignment >*
SRL_School::mutable_assignments() {
  return &assignments_;
}

// repeated .protobuf.srl.school.SRL_Problem problems = 3;
inline int SRL_School::problems_size() const {
  return problems_.size();
}
inline void SRL_School::clear_problems() {
  problems_.Clear();
}
inline const ::protobuf::srl::school::SRL_Problem& SRL_School::problems(int index) const {
  return problems_.Get(index);
}
inline ::protobuf::srl::school::SRL_Problem* SRL_School::mutable_problems(int index) {
  return problems_.Mutable(index);
}
inline ::protobuf::srl::school::SRL_Problem* SRL_School::add_problems() {
  return problems_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SRL_Problem >&
SRL_School::problems() const {
  return problems_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SRL_Problem >*
SRL_School::mutable_problems() {
  return &problems_;
}

// -------------------------------------------------------------------

// SRL_Course

// required string courseId = 1;
inline bool SRL_Course::has_courseid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SRL_Course::set_has_courseid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SRL_Course::clear_has_courseid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SRL_Course::clear_courseid() {
  if (courseid_ != &::google::protobuf::internal::kEmptyString) {
    courseid_->clear();
  }
  clear_has_courseid();
}
inline const ::std::string& SRL_Course::courseid() const {
  return *courseid_;
}
inline void SRL_Course::set_courseid(const ::std::string& value) {
  set_has_courseid();
  if (courseid_ == &::google::protobuf::internal::kEmptyString) {
    courseid_ = new ::std::string;
  }
  courseid_->assign(value);
}
inline void SRL_Course::set_courseid(const char* value) {
  set_has_courseid();
  if (courseid_ == &::google::protobuf::internal::kEmptyString) {
    courseid_ = new ::std::string;
  }
  courseid_->assign(value);
}
inline void SRL_Course::set_courseid(const char* value, size_t size) {
  set_has_courseid();
  if (courseid_ == &::google::protobuf::internal::kEmptyString) {
    courseid_ = new ::std::string;
  }
  courseid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SRL_Course::mutable_courseid() {
  set_has_courseid();
  if (courseid_ == &::google::protobuf::internal::kEmptyString) {
    courseid_ = new ::std::string;
  }
  return courseid_;
}
inline ::std::string* SRL_Course::release_courseid() {
  clear_has_courseid();
  if (courseid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = courseid_;
    courseid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SRL_Course::set_allocated_courseid(::std::string* courseid) {
  if (courseid_ != &::google::protobuf::internal::kEmptyString) {
    delete courseid_;
  }
  if (courseid) {
    set_has_courseid();
    courseid_ = courseid;
  } else {
    clear_has_courseid();
    courseid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string courseName = 2;
inline bool SRL_Course::has_coursename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SRL_Course::set_has_coursename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SRL_Course::clear_has_coursename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SRL_Course::clear_coursename() {
  if (coursename_ != &::google::protobuf::internal::kEmptyString) {
    coursename_->clear();
  }
  clear_has_coursename();
}
inline const ::std::string& SRL_Course::coursename() const {
  return *coursename_;
}
inline void SRL_Course::set_coursename(const ::std::string& value) {
  set_has_coursename();
  if (coursename_ == &::google::protobuf::internal::kEmptyString) {
    coursename_ = new ::std::string;
  }
  coursename_->assign(value);
}
inline void SRL_Course::set_coursename(const char* value) {
  set_has_coursename();
  if (coursename_ == &::google::protobuf::internal::kEmptyString) {
    coursename_ = new ::std::string;
  }
  coursename_->assign(value);
}
inline void SRL_Course::set_coursename(const char* value, size_t size) {
  set_has_coursename();
  if (coursename_ == &::google::protobuf::internal::kEmptyString) {
    coursename_ = new ::std::string;
  }
  coursename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SRL_Course::mutable_coursename() {
  set_has_coursename();
  if (coursename_ == &::google::protobuf::internal::kEmptyString) {
    coursename_ = new ::std::string;
  }
  return coursename_;
}
inline ::std::string* SRL_Course::release_coursename() {
  clear_has_coursename();
  if (coursename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = coursename_;
    coursename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SRL_Course::set_allocated_coursename(::std::string* coursename) {
  if (coursename_ != &::google::protobuf::internal::kEmptyString) {
    delete coursename_;
  }
  if (coursename) {
    set_has_coursename();
    coursename_ = coursename;
  } else {
    clear_has_coursename();
    coursename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SRL_Assignment

// required uint64 courseId = 1;
inline bool SRL_Assignment::has_courseid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SRL_Assignment::set_has_courseid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SRL_Assignment::clear_has_courseid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SRL_Assignment::clear_courseid() {
  courseid_ = GOOGLE_ULONGLONG(0);
  clear_has_courseid();
}
inline ::google::protobuf::uint64 SRL_Assignment::courseid() const {
  return courseid_;
}
inline void SRL_Assignment::set_courseid(::google::protobuf::uint64 value) {
  set_has_courseid();
  courseid_ = value;
}

// required string assignmentId = 2;
inline bool SRL_Assignment::has_assignmentid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SRL_Assignment::set_has_assignmentid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SRL_Assignment::clear_has_assignmentid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SRL_Assignment::clear_assignmentid() {
  if (assignmentid_ != &::google::protobuf::internal::kEmptyString) {
    assignmentid_->clear();
  }
  clear_has_assignmentid();
}
inline const ::std::string& SRL_Assignment::assignmentid() const {
  return *assignmentid_;
}
inline void SRL_Assignment::set_assignmentid(const ::std::string& value) {
  set_has_assignmentid();
  if (assignmentid_ == &::google::protobuf::internal::kEmptyString) {
    assignmentid_ = new ::std::string;
  }
  assignmentid_->assign(value);
}
inline void SRL_Assignment::set_assignmentid(const char* value) {
  set_has_assignmentid();
  if (assignmentid_ == &::google::protobuf::internal::kEmptyString) {
    assignmentid_ = new ::std::string;
  }
  assignmentid_->assign(value);
}
inline void SRL_Assignment::set_assignmentid(const char* value, size_t size) {
  set_has_assignmentid();
  if (assignmentid_ == &::google::protobuf::internal::kEmptyString) {
    assignmentid_ = new ::std::string;
  }
  assignmentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SRL_Assignment::mutable_assignmentid() {
  set_has_assignmentid();
  if (assignmentid_ == &::google::protobuf::internal::kEmptyString) {
    assignmentid_ = new ::std::string;
  }
  return assignmentid_;
}
inline ::std::string* SRL_Assignment::release_assignmentid() {
  clear_has_assignmentid();
  if (assignmentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = assignmentid_;
    assignmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SRL_Assignment::set_allocated_assignmentid(::std::string* assignmentid) {
  if (assignmentid_ != &::google::protobuf::internal::kEmptyString) {
    delete assignmentid_;
  }
  if (assignmentid) {
    set_has_assignmentid();
    assignmentid_ = assignmentid;
  } else {
    clear_has_assignmentid();
    assignmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string assignmentName = 3;
inline bool SRL_Assignment::has_assignmentname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SRL_Assignment::set_has_assignmentname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SRL_Assignment::clear_has_assignmentname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SRL_Assignment::clear_assignmentname() {
  if (assignmentname_ != &::google::protobuf::internal::kEmptyString) {
    assignmentname_->clear();
  }
  clear_has_assignmentname();
}
inline const ::std::string& SRL_Assignment::assignmentname() const {
  return *assignmentname_;
}
inline void SRL_Assignment::set_assignmentname(const ::std::string& value) {
  set_has_assignmentname();
  if (assignmentname_ == &::google::protobuf::internal::kEmptyString) {
    assignmentname_ = new ::std::string;
  }
  assignmentname_->assign(value);
}
inline void SRL_Assignment::set_assignmentname(const char* value) {
  set_has_assignmentname();
  if (assignmentname_ == &::google::protobuf::internal::kEmptyString) {
    assignmentname_ = new ::std::string;
  }
  assignmentname_->assign(value);
}
inline void SRL_Assignment::set_assignmentname(const char* value, size_t size) {
  set_has_assignmentname();
  if (assignmentname_ == &::google::protobuf::internal::kEmptyString) {
    assignmentname_ = new ::std::string;
  }
  assignmentname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SRL_Assignment::mutable_assignmentname() {
  set_has_assignmentname();
  if (assignmentname_ == &::google::protobuf::internal::kEmptyString) {
    assignmentname_ = new ::std::string;
  }
  return assignmentname_;
}
inline ::std::string* SRL_Assignment::release_assignmentname() {
  clear_has_assignmentname();
  if (assignmentname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = assignmentname_;
    assignmentname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SRL_Assignment::set_allocated_assignmentname(::std::string* assignmentname) {
  if (assignmentname_ != &::google::protobuf::internal::kEmptyString) {
    delete assignmentname_;
  }
  if (assignmentname) {
    set_has_assignmentname();
    assignmentname_ = assignmentname;
  } else {
    clear_has_assignmentname();
    assignmentname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SRL_Problem

// required uint64 courseId = 1;
inline bool SRL_Problem::has_courseid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SRL_Problem::set_has_courseid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SRL_Problem::clear_has_courseid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SRL_Problem::clear_courseid() {
  courseid_ = GOOGLE_ULONGLONG(0);
  clear_has_courseid();
}
inline ::google::protobuf::uint64 SRL_Problem::courseid() const {
  return courseid_;
}
inline void SRL_Problem::set_courseid(::google::protobuf::uint64 value) {
  set_has_courseid();
  courseid_ = value;
}

// required uint64 assignmentId = 2;
inline bool SRL_Problem::has_assignmentid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SRL_Problem::set_has_assignmentid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SRL_Problem::clear_has_assignmentid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SRL_Problem::clear_assignmentid() {
  assignmentid_ = GOOGLE_ULONGLONG(0);
  clear_has_assignmentid();
}
inline ::google::protobuf::uint64 SRL_Problem::assignmentid() const {
  return assignmentid_;
}
inline void SRL_Problem::set_assignmentid(::google::protobuf::uint64 value) {
  set_has_assignmentid();
  assignmentid_ = value;
}

// required string problemId = 3;
inline bool SRL_Problem::has_problemid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SRL_Problem::set_has_problemid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SRL_Problem::clear_has_problemid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SRL_Problem::clear_problemid() {
  if (problemid_ != &::google::protobuf::internal::kEmptyString) {
    problemid_->clear();
  }
  clear_has_problemid();
}
inline const ::std::string& SRL_Problem::problemid() const {
  return *problemid_;
}
inline void SRL_Problem::set_problemid(const ::std::string& value) {
  set_has_problemid();
  if (problemid_ == &::google::protobuf::internal::kEmptyString) {
    problemid_ = new ::std::string;
  }
  problemid_->assign(value);
}
inline void SRL_Problem::set_problemid(const char* value) {
  set_has_problemid();
  if (problemid_ == &::google::protobuf::internal::kEmptyString) {
    problemid_ = new ::std::string;
  }
  problemid_->assign(value);
}
inline void SRL_Problem::set_problemid(const char* value, size_t size) {
  set_has_problemid();
  if (problemid_ == &::google::protobuf::internal::kEmptyString) {
    problemid_ = new ::std::string;
  }
  problemid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SRL_Problem::mutable_problemid() {
  set_has_problemid();
  if (problemid_ == &::google::protobuf::internal::kEmptyString) {
    problemid_ = new ::std::string;
  }
  return problemid_;
}
inline ::std::string* SRL_Problem::release_problemid() {
  clear_has_problemid();
  if (problemid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = problemid_;
    problemid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SRL_Problem::set_allocated_problemid(::std::string* problemid) {
  if (problemid_ != &::google::protobuf::internal::kEmptyString) {
    delete problemid_;
  }
  if (problemid) {
    set_has_problemid();
    problemid_ = problemid;
  } else {
    clear_has_problemid();
    problemid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string problemName = 4;
inline bool SRL_Problem::has_problemname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SRL_Problem::set_has_problemname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SRL_Problem::clear_has_problemname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SRL_Problem::clear_problemname() {
  if (problemname_ != &::google::protobuf::internal::kEmptyString) {
    problemname_->clear();
  }
  clear_has_problemname();
}
inline const ::std::string& SRL_Problem::problemname() const {
  return *problemname_;
}
inline void SRL_Problem::set_problemname(const ::std::string& value) {
  set_has_problemname();
  if (problemname_ == &::google::protobuf::internal::kEmptyString) {
    problemname_ = new ::std::string;
  }
  problemname_->assign(value);
}
inline void SRL_Problem::set_problemname(const char* value) {
  set_has_problemname();
  if (problemname_ == &::google::protobuf::internal::kEmptyString) {
    problemname_ = new ::std::string;
  }
  problemname_->assign(value);
}
inline void SRL_Problem::set_problemname(const char* value, size_t size) {
  set_has_problemname();
  if (problemname_ == &::google::protobuf::internal::kEmptyString) {
    problemname_ = new ::std::string;
  }
  problemname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SRL_Problem::mutable_problemname() {
  set_has_problemname();
  if (problemname_ == &::google::protobuf::internal::kEmptyString) {
    problemname_ = new ::std::string;
  }
  return problemname_;
}
inline ::std::string* SRL_Problem::release_problemname() {
  clear_has_problemname();
  if (problemname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = problemname_;
    problemname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SRL_Problem::set_allocated_problemname(::std::string* problemname) {
  if (problemname_ != &::google::protobuf::internal::kEmptyString) {
    delete problemname_;
  }
  if (problemname) {
    set_has_problemname();
    problemname_ = problemname;
  } else {
    clear_has_problemname();
    problemname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .protobuf.srl.school.subproblemInformation mainProblem = 5;
inline bool SRL_Problem::has_mainproblem() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SRL_Problem::set_has_mainproblem() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SRL_Problem::clear_has_mainproblem() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SRL_Problem::clear_mainproblem() {
  if (mainproblem_ != NULL) mainproblem_->::protobuf::srl::school::subproblemInformation::Clear();
  clear_has_mainproblem();
}
inline const ::protobuf::srl::school::subproblemInformation& SRL_Problem::mainproblem() const {
  return mainproblem_ != NULL ? *mainproblem_ : *default_instance_->mainproblem_;
}
inline ::protobuf::srl::school::subproblemInformation* SRL_Problem::mutable_mainproblem() {
  set_has_mainproblem();
  if (mainproblem_ == NULL) mainproblem_ = new ::protobuf::srl::school::subproblemInformation;
  return mainproblem_;
}
inline ::protobuf::srl::school::subproblemInformation* SRL_Problem::release_mainproblem() {
  clear_has_mainproblem();
  ::protobuf::srl::school::subproblemInformation* temp = mainproblem_;
  mainproblem_ = NULL;
  return temp;
}
inline void SRL_Problem::set_allocated_mainproblem(::protobuf::srl::school::subproblemInformation* mainproblem) {
  delete mainproblem_;
  mainproblem_ = mainproblem;
  if (mainproblem) {
    set_has_mainproblem();
  } else {
    clear_has_mainproblem();
  }
}

// repeated .protobuf.srl.school.subproblemInformation subProblems = 6;
inline int SRL_Problem::subproblems_size() const {
  return subproblems_.size();
}
inline void SRL_Problem::clear_subproblems() {
  subproblems_.Clear();
}
inline const ::protobuf::srl::school::subproblemInformation& SRL_Problem::subproblems(int index) const {
  return subproblems_.Get(index);
}
inline ::protobuf::srl::school::subproblemInformation* SRL_Problem::mutable_subproblems(int index) {
  return subproblems_.Mutable(index);
}
inline ::protobuf::srl::school::subproblemInformation* SRL_Problem::add_subproblems() {
  return subproblems_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::subproblemInformation >&
SRL_Problem::subproblems() const {
  return subproblems_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::subproblemInformation >*
SRL_Problem::mutable_subproblems() {
  return &subproblems_;
}

// -------------------------------------------------------------------

// subproblemInformation

// optional string questionText = 1;
inline bool subproblemInformation::has_questiontext() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void subproblemInformation::set_has_questiontext() {
  _has_bits_[0] |= 0x00000001u;
}
inline void subproblemInformation::clear_has_questiontext() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void subproblemInformation::clear_questiontext() {
  if (questiontext_ != &::google::protobuf::internal::kEmptyString) {
    questiontext_->clear();
  }
  clear_has_questiontext();
}
inline const ::std::string& subproblemInformation::questiontext() const {
  return *questiontext_;
}
inline void subproblemInformation::set_questiontext(const ::std::string& value) {
  set_has_questiontext();
  if (questiontext_ == &::google::protobuf::internal::kEmptyString) {
    questiontext_ = new ::std::string;
  }
  questiontext_->assign(value);
}
inline void subproblemInformation::set_questiontext(const char* value) {
  set_has_questiontext();
  if (questiontext_ == &::google::protobuf::internal::kEmptyString) {
    questiontext_ = new ::std::string;
  }
  questiontext_->assign(value);
}
inline void subproblemInformation::set_questiontext(const char* value, size_t size) {
  set_has_questiontext();
  if (questiontext_ == &::google::protobuf::internal::kEmptyString) {
    questiontext_ = new ::std::string;
  }
  questiontext_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* subproblemInformation::mutable_questiontext() {
  set_has_questiontext();
  if (questiontext_ == &::google::protobuf::internal::kEmptyString) {
    questiontext_ = new ::std::string;
  }
  return questiontext_;
}
inline ::std::string* subproblemInformation::release_questiontext() {
  clear_has_questiontext();
  if (questiontext_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = questiontext_;
    questiontext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void subproblemInformation::set_allocated_questiontext(::std::string* questiontext) {
  if (questiontext_ != &::google::protobuf::internal::kEmptyString) {
    delete questiontext_;
  }
  if (questiontext) {
    set_has_questiontext();
    questiontext_ = questiontext;
  } else {
    clear_has_questiontext();
    questiontext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .protobuf.srl.school.subproblemInformation.QuestionType questionType = 2 [default = SKETCH];
inline bool subproblemInformation::has_questiontype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void subproblemInformation::set_has_questiontype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void subproblemInformation::clear_has_questiontype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void subproblemInformation::clear_questiontype() {
  questiontype_ = 1;
  clear_has_questiontype();
}
inline ::protobuf::srl::school::subproblemInformation_QuestionType subproblemInformation::questiontype() const {
  return static_cast< ::protobuf::srl::school::subproblemInformation_QuestionType >(questiontype_);
}
inline void subproblemInformation::set_questiontype(::protobuf::srl::school::subproblemInformation_QuestionType value) {
  assert(::protobuf::srl::school::subproblemInformation_QuestionType_IsValid(value));
  set_has_questiontype();
  questiontype_ = value;
}

// optional bytes options = 3;
inline bool subproblemInformation::has_options() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void subproblemInformation::set_has_options() {
  _has_bits_[0] |= 0x00000004u;
}
inline void subproblemInformation::clear_has_options() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void subproblemInformation::clear_options() {
  if (options_ != &::google::protobuf::internal::kEmptyString) {
    options_->clear();
  }
  clear_has_options();
}
inline const ::std::string& subproblemInformation::options() const {
  return *options_;
}
inline void subproblemInformation::set_options(const ::std::string& value) {
  set_has_options();
  if (options_ == &::google::protobuf::internal::kEmptyString) {
    options_ = new ::std::string;
  }
  options_->assign(value);
}
inline void subproblemInformation::set_options(const char* value) {
  set_has_options();
  if (options_ == &::google::protobuf::internal::kEmptyString) {
    options_ = new ::std::string;
  }
  options_->assign(value);
}
inline void subproblemInformation::set_options(const void* value, size_t size) {
  set_has_options();
  if (options_ == &::google::protobuf::internal::kEmptyString) {
    options_ = new ::std::string;
  }
  options_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* subproblemInformation::mutable_options() {
  set_has_options();
  if (options_ == &::google::protobuf::internal::kEmptyString) {
    options_ = new ::std::string;
  }
  return options_;
}
inline ::std::string* subproblemInformation::release_options() {
  clear_has_options();
  if (options_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = options_;
    options_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void subproblemInformation::set_allocated_options(::std::string* options) {
  if (options_ != &::google::protobuf::internal::kEmptyString) {
    delete options_;
  }
  if (options) {
    set_has_options();
    options_ = options;
  } else {
    clear_has_options();
    options_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace school
}  // namespace srl
}  // namespace protobuf

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protobuf::srl::school::subproblemInformation_QuestionType>() {
  return ::protobuf::srl::school::subproblemInformation_QuestionType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_input_2fschool_2eproto__INCLUDED
