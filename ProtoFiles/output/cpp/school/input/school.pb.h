// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: input/school.proto

#ifndef PROTOBUF_input_2fschool_2eproto__INCLUDED
#define PROTOBUF_input_2fschool_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf {
namespace srl {
namespace school {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_input_2fschool_2eproto();
void protobuf_AssignDesc_input_2fschool_2eproto();
void protobuf_ShutdownFile_input_2fschool_2eproto();

class SrlSchool;
class SrlCourse;
class SrlAssignment;
class SrlAssignment_LatePolicy;
class SrlProblem;
class SrlBankProblem;
class SrlGrade;
class DateTime;
class DomainInformation;
class State;
class SrlUser;
class SrlGroup;
class SrlPermission;

enum SrlCourse_Accessibility {
  SrlCourse_Accessibility_SUPER_PUBLIC = 0,
  SrlCourse_Accessibility_PUBLIC = 1,
  SrlCourse_Accessibility_PROTECTED = 2,
  SrlCourse_Accessibility_PROTECTED_NOSEARCH = 3,
  SrlCourse_Accessibility_PRIVATE = 4
};
bool SrlCourse_Accessibility_IsValid(int value);
const SrlCourse_Accessibility SrlCourse_Accessibility_Accessibility_MIN = SrlCourse_Accessibility_SUPER_PUBLIC;
const SrlCourse_Accessibility SrlCourse_Accessibility_Accessibility_MAX = SrlCourse_Accessibility_PRIVATE;
const int SrlCourse_Accessibility_Accessibility_ARRAYSIZE = SrlCourse_Accessibility_Accessibility_MAX + 1;

const ::google::protobuf::EnumDescriptor* SrlCourse_Accessibility_descriptor();
inline const ::std::string& SrlCourse_Accessibility_Name(SrlCourse_Accessibility value) {
  return ::google::protobuf::internal::NameOfEnum(
    SrlCourse_Accessibility_descriptor(), value);
}
inline bool SrlCourse_Accessibility_Parse(
    const ::std::string& name, SrlCourse_Accessibility* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SrlCourse_Accessibility>(
    SrlCourse_Accessibility_descriptor(), name, value);
}
enum SrlAssignment_LatePolicy_FunctionType {
  SrlAssignment_LatePolicy_FunctionType_WINDOW_FUNCTION = 1,
  SrlAssignment_LatePolicy_FunctionType_LINE = 2,
  SrlAssignment_LatePolicy_FunctionType_EXPONENTIAL = 3
};
bool SrlAssignment_LatePolicy_FunctionType_IsValid(int value);
const SrlAssignment_LatePolicy_FunctionType SrlAssignment_LatePolicy_FunctionType_FunctionType_MIN = SrlAssignment_LatePolicy_FunctionType_WINDOW_FUNCTION;
const SrlAssignment_LatePolicy_FunctionType SrlAssignment_LatePolicy_FunctionType_FunctionType_MAX = SrlAssignment_LatePolicy_FunctionType_EXPONENTIAL;
const int SrlAssignment_LatePolicy_FunctionType_FunctionType_ARRAYSIZE = SrlAssignment_LatePolicy_FunctionType_FunctionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SrlAssignment_LatePolicy_FunctionType_descriptor();
inline const ::std::string& SrlAssignment_LatePolicy_FunctionType_Name(SrlAssignment_LatePolicy_FunctionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SrlAssignment_LatePolicy_FunctionType_descriptor(), value);
}
inline bool SrlAssignment_LatePolicy_FunctionType_Parse(
    const ::std::string& name, SrlAssignment_LatePolicy_FunctionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SrlAssignment_LatePolicy_FunctionType>(
    SrlAssignment_LatePolicy_FunctionType_descriptor(), name, value);
}
enum SrlAssignment_LatePolicy_TimeFrame {
  SrlAssignment_LatePolicy_TimeFrame_DAY = 1,
  SrlAssignment_LatePolicy_TimeFrame_HOUR = 2,
  SrlAssignment_LatePolicy_TimeFrame_MINUTE = 3
};
bool SrlAssignment_LatePolicy_TimeFrame_IsValid(int value);
const SrlAssignment_LatePolicy_TimeFrame SrlAssignment_LatePolicy_TimeFrame_TimeFrame_MIN = SrlAssignment_LatePolicy_TimeFrame_DAY;
const SrlAssignment_LatePolicy_TimeFrame SrlAssignment_LatePolicy_TimeFrame_TimeFrame_MAX = SrlAssignment_LatePolicy_TimeFrame_MINUTE;
const int SrlAssignment_LatePolicy_TimeFrame_TimeFrame_ARRAYSIZE = SrlAssignment_LatePolicy_TimeFrame_TimeFrame_MAX + 1;

const ::google::protobuf::EnumDescriptor* SrlAssignment_LatePolicy_TimeFrame_descriptor();
inline const ::std::string& SrlAssignment_LatePolicy_TimeFrame_Name(SrlAssignment_LatePolicy_TimeFrame value) {
  return ::google::protobuf::internal::NameOfEnum(
    SrlAssignment_LatePolicy_TimeFrame_descriptor(), value);
}
inline bool SrlAssignment_LatePolicy_TimeFrame_Parse(
    const ::std::string& name, SrlAssignment_LatePolicy_TimeFrame* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SrlAssignment_LatePolicy_TimeFrame>(
    SrlAssignment_LatePolicy_TimeFrame_descriptor(), name, value);
}
enum SrlAssignment_AssignmentType {
  SrlAssignment_AssignmentType_HOMEWORK = 1,
  SrlAssignment_AssignmentType_QUIZ = 2,
  SrlAssignment_AssignmentType_LAB = 3,
  SrlAssignment_AssignmentType_EXAM = 4,
  SrlAssignment_AssignmentType_SURVEY = 5,
  SrlAssignment_AssignmentType_OTHER = 6
};
bool SrlAssignment_AssignmentType_IsValid(int value);
const SrlAssignment_AssignmentType SrlAssignment_AssignmentType_AssignmentType_MIN = SrlAssignment_AssignmentType_HOMEWORK;
const SrlAssignment_AssignmentType SrlAssignment_AssignmentType_AssignmentType_MAX = SrlAssignment_AssignmentType_OTHER;
const int SrlAssignment_AssignmentType_AssignmentType_ARRAYSIZE = SrlAssignment_AssignmentType_AssignmentType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SrlAssignment_AssignmentType_descriptor();
inline const ::std::string& SrlAssignment_AssignmentType_Name(SrlAssignment_AssignmentType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SrlAssignment_AssignmentType_descriptor(), value);
}
inline bool SrlAssignment_AssignmentType_Parse(
    const ::std::string& name, SrlAssignment_AssignmentType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SrlAssignment_AssignmentType>(
    SrlAssignment_AssignmentType_descriptor(), name, value);
}
enum SrlBankProblem_QuestionType {
  SrlBankProblem_QuestionType_SKETCH = 1,
  SrlBankProblem_QuestionType_MULT_CHOICE = 2,
  SrlBankProblem_QuestionType_FREE_RESP = 3,
  SrlBankProblem_QuestionType_CHECK_BOX = 4
};
bool SrlBankProblem_QuestionType_IsValid(int value);
const SrlBankProblem_QuestionType SrlBankProblem_QuestionType_QuestionType_MIN = SrlBankProblem_QuestionType_SKETCH;
const SrlBankProblem_QuestionType SrlBankProblem_QuestionType_QuestionType_MAX = SrlBankProblem_QuestionType_CHECK_BOX;
const int SrlBankProblem_QuestionType_QuestionType_ARRAYSIZE = SrlBankProblem_QuestionType_QuestionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SrlBankProblem_QuestionType_descriptor();
inline const ::std::string& SrlBankProblem_QuestionType_Name(SrlBankProblem_QuestionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SrlBankProblem_QuestionType_descriptor(), value);
}
inline bool SrlBankProblem_QuestionType_Parse(
    const ::std::string& name, SrlBankProblem_QuestionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SrlBankProblem_QuestionType>(
    SrlBankProblem_QuestionType_descriptor(), name, value);
}
enum UserType {
  ADMIN = 1,
  INSTRUCTOR = 2,
  TEACHING_ASSISTANT = 3,
  STUDENT = 4,
  GUEST = 5
};
bool UserType_IsValid(int value);
const UserType UserType_MIN = ADMIN;
const UserType UserType_MAX = GUEST;
const int UserType_ARRAYSIZE = UserType_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserType_descriptor();
inline const ::std::string& UserType_Name(UserType value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserType_descriptor(), value);
}
inline bool UserType_Parse(
    const ::std::string& name, UserType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserType>(
    UserType_descriptor(), name, value);
}
// ===================================================================

class SrlSchool : public ::google::protobuf::Message {
 public:
  SrlSchool();
  virtual ~SrlSchool();

  SrlSchool(const SrlSchool& from);

  inline SrlSchool& operator=(const SrlSchool& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SrlSchool& default_instance();

  void Swap(SrlSchool* other);

  // implements Message ----------------------------------------------

  SrlSchool* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SrlSchool& from);
  void MergeFrom(const SrlSchool& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protobuf.srl.school.SrlCourse courses = 1;
  inline int courses_size() const;
  inline void clear_courses();
  static const int kCoursesFieldNumber = 1;
  inline const ::protobuf::srl::school::SrlCourse& courses(int index) const;
  inline ::protobuf::srl::school::SrlCourse* mutable_courses(int index);
  inline ::protobuf::srl::school::SrlCourse* add_courses();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlCourse >&
      courses() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlCourse >*
      mutable_courses();

  // repeated .protobuf.srl.school.SrlAssignment assignments = 2;
  inline int assignments_size() const;
  inline void clear_assignments();
  static const int kAssignmentsFieldNumber = 2;
  inline const ::protobuf::srl::school::SrlAssignment& assignments(int index) const;
  inline ::protobuf::srl::school::SrlAssignment* mutable_assignments(int index);
  inline ::protobuf::srl::school::SrlAssignment* add_assignments();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlAssignment >&
      assignments() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlAssignment >*
      mutable_assignments();

  // repeated .protobuf.srl.school.SrlProblem problems = 3;
  inline int problems_size() const;
  inline void clear_problems();
  static const int kProblemsFieldNumber = 3;
  inline const ::protobuf::srl::school::SrlProblem& problems(int index) const;
  inline ::protobuf::srl::school::SrlProblem* mutable_problems(int index);
  inline ::protobuf::srl::school::SrlProblem* add_problems();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlProblem >&
      problems() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlProblem >*
      mutable_problems();

  // repeated .protobuf.srl.school.SrlBankProblem bankProblems = 4;
  inline int bankproblems_size() const;
  inline void clear_bankproblems();
  static const int kBankProblemsFieldNumber = 4;
  inline const ::protobuf::srl::school::SrlBankProblem& bankproblems(int index) const;
  inline ::protobuf::srl::school::SrlBankProblem* mutable_bankproblems(int index);
  inline ::protobuf::srl::school::SrlBankProblem* add_bankproblems();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlBankProblem >&
      bankproblems() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlBankProblem >*
      mutable_bankproblems();

  // repeated .protobuf.srl.school.SrlGrade grades = 5;
  inline int grades_size() const;
  inline void clear_grades();
  static const int kGradesFieldNumber = 5;
  inline const ::protobuf::srl::school::SrlGrade& grades(int index) const;
  inline ::protobuf::srl::school::SrlGrade* mutable_grades(int index);
  inline ::protobuf::srl::school::SrlGrade* add_grades();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlGrade >&
      grades() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlGrade >*
      mutable_grades();

  // @@protoc_insertion_point(class_scope:protobuf.srl.school.SrlSchool)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlCourse > courses_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlAssignment > assignments_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlProblem > problems_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlBankProblem > bankproblems_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlGrade > grades_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_input_2fschool_2eproto();
  friend void protobuf_AssignDesc_input_2fschool_2eproto();
  friend void protobuf_ShutdownFile_input_2fschool_2eproto();

  void InitAsDefaultInstance();
  static SrlSchool* default_instance_;
};
// -------------------------------------------------------------------

class SrlCourse : public ::google::protobuf::Message {
 public:
  SrlCourse();
  virtual ~SrlCourse();

  SrlCourse(const SrlCourse& from);

  inline SrlCourse& operator=(const SrlCourse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SrlCourse& default_instance();

  void Swap(SrlCourse* other);

  // implements Message ----------------------------------------------

  SrlCourse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SrlCourse& from);
  void MergeFrom(const SrlCourse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SrlCourse_Accessibility Accessibility;
  static const Accessibility SUPER_PUBLIC = SrlCourse_Accessibility_SUPER_PUBLIC;
  static const Accessibility PUBLIC = SrlCourse_Accessibility_PUBLIC;
  static const Accessibility PROTECTED = SrlCourse_Accessibility_PROTECTED;
  static const Accessibility PROTECTED_NOSEARCH = SrlCourse_Accessibility_PROTECTED_NOSEARCH;
  static const Accessibility PRIVATE = SrlCourse_Accessibility_PRIVATE;
  static inline bool Accessibility_IsValid(int value) {
    return SrlCourse_Accessibility_IsValid(value);
  }
  static const Accessibility Accessibility_MIN =
    SrlCourse_Accessibility_Accessibility_MIN;
  static const Accessibility Accessibility_MAX =
    SrlCourse_Accessibility_Accessibility_MAX;
  static const int Accessibility_ARRAYSIZE =
    SrlCourse_Accessibility_Accessibility_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Accessibility_descriptor() {
    return SrlCourse_Accessibility_descriptor();
  }
  static inline const ::std::string& Accessibility_Name(Accessibility value) {
    return SrlCourse_Accessibility_Name(value);
  }
  static inline bool Accessibility_Parse(const ::std::string& name,
      Accessibility* value) {
    return SrlCourse_Accessibility_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .protobuf.srl.school.SrlPermission accessPermission = 3;
  inline bool has_accesspermission() const;
  inline void clear_accesspermission();
  static const int kAccessPermissionFieldNumber = 3;
  inline const ::protobuf::srl::school::SrlPermission& accesspermission() const;
  inline ::protobuf::srl::school::SrlPermission* mutable_accesspermission();
  inline ::protobuf::srl::school::SrlPermission* release_accesspermission();
  inline void set_allocated_accesspermission(::protobuf::srl::school::SrlPermission* accesspermission);

  // optional .protobuf.srl.school.SrlCourse.Accessibility access = 4 [default = PROTECTED];
  inline bool has_access() const;
  inline void clear_access();
  static const int kAccessFieldNumber = 4;
  inline ::protobuf::srl::school::SrlCourse_Accessibility access() const;
  inline void set_access(::protobuf::srl::school::SrlCourse_Accessibility value);

  // optional string description = 5;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 5;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // optional string semester = 6;
  inline bool has_semester() const;
  inline void clear_semester();
  static const int kSemesterFieldNumber = 6;
  inline const ::std::string& semester() const;
  inline void set_semester(const ::std::string& value);
  inline void set_semester(const char* value);
  inline void set_semester(const char* value, size_t size);
  inline ::std::string* mutable_semester();
  inline ::std::string* release_semester();
  inline void set_allocated_semester(::std::string* semester);

  // optional string imageUrl = 7;
  inline bool has_imageurl() const;
  inline void clear_imageurl();
  static const int kImageUrlFieldNumber = 7;
  inline const ::std::string& imageurl() const;
  inline void set_imageurl(const ::std::string& value);
  inline void set_imageurl(const char* value);
  inline void set_imageurl(const char* value, size_t size);
  inline ::std::string* mutable_imageurl();
  inline ::std::string* release_imageurl();
  inline void set_allocated_imageurl(::std::string* imageurl);

  // optional float grade = 8;
  inline bool has_grade() const;
  inline void clear_grade();
  static const int kGradeFieldNumber = 8;
  inline float grade() const;
  inline void set_grade(float value);

  // optional .protobuf.srl.school.DateTime accessDate = 9;
  inline bool has_accessdate() const;
  inline void clear_accessdate();
  static const int kAccessDateFieldNumber = 9;
  inline const ::protobuf::srl::school::DateTime& accessdate() const;
  inline ::protobuf::srl::school::DateTime* mutable_accessdate();
  inline ::protobuf::srl::school::DateTime* release_accessdate();
  inline void set_allocated_accessdate(::protobuf::srl::school::DateTime* accessdate);

  // optional .protobuf.srl.school.DateTime closeDate = 10;
  inline bool has_closedate() const;
  inline void clear_closedate();
  static const int kCloseDateFieldNumber = 10;
  inline const ::protobuf::srl::school::DateTime& closedate() const;
  inline ::protobuf::srl::school::DateTime* mutable_closedate();
  inline ::protobuf::srl::school::DateTime* release_closedate();
  inline void set_allocated_closedate(::protobuf::srl::school::DateTime* closedate);

  // optional .protobuf.srl.school.State state = 11;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 11;
  inline const ::protobuf::srl::school::State& state() const;
  inline ::protobuf::srl::school::State* mutable_state();
  inline ::protobuf::srl::school::State* release_state();
  inline void set_allocated_state(::protobuf::srl::school::State* state);

  // repeated string assignmentList = 12;
  inline int assignmentlist_size() const;
  inline void clear_assignmentlist();
  static const int kAssignmentListFieldNumber = 12;
  inline const ::std::string& assignmentlist(int index) const;
  inline ::std::string* mutable_assignmentlist(int index);
  inline void set_assignmentlist(int index, const ::std::string& value);
  inline void set_assignmentlist(int index, const char* value);
  inline void set_assignmentlist(int index, const char* value, size_t size);
  inline ::std::string* add_assignmentlist();
  inline void add_assignmentlist(const ::std::string& value);
  inline void add_assignmentlist(const char* value);
  inline void add_assignmentlist(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& assignmentlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_assignmentlist();

  // @@protoc_insertion_point(class_scope:protobuf.srl.school.SrlCourse)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_accesspermission();
  inline void clear_has_accesspermission();
  inline void set_has_access();
  inline void clear_has_access();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_semester();
  inline void clear_has_semester();
  inline void set_has_imageurl();
  inline void clear_has_imageurl();
  inline void set_has_grade();
  inline void clear_has_grade();
  inline void set_has_accessdate();
  inline void clear_has_accessdate();
  inline void set_has_closedate();
  inline void clear_has_closedate();
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* name_;
  ::protobuf::srl::school::SrlPermission* accesspermission_;
  ::std::string* description_;
  ::std::string* semester_;
  int access_;
  float grade_;
  ::std::string* imageurl_;
  ::protobuf::srl::school::DateTime* accessdate_;
  ::protobuf::srl::school::DateTime* closedate_;
  ::protobuf::srl::school::State* state_;
  ::google::protobuf::RepeatedPtrField< ::std::string> assignmentlist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_input_2fschool_2eproto();
  friend void protobuf_AssignDesc_input_2fschool_2eproto();
  friend void protobuf_ShutdownFile_input_2fschool_2eproto();

  void InitAsDefaultInstance();
  static SrlCourse* default_instance_;
};
// -------------------------------------------------------------------

class SrlAssignment_LatePolicy : public ::google::protobuf::Message {
 public:
  SrlAssignment_LatePolicy();
  virtual ~SrlAssignment_LatePolicy();

  SrlAssignment_LatePolicy(const SrlAssignment_LatePolicy& from);

  inline SrlAssignment_LatePolicy& operator=(const SrlAssignment_LatePolicy& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SrlAssignment_LatePolicy& default_instance();

  void Swap(SrlAssignment_LatePolicy* other);

  // implements Message ----------------------------------------------

  SrlAssignment_LatePolicy* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SrlAssignment_LatePolicy& from);
  void MergeFrom(const SrlAssignment_LatePolicy& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SrlAssignment_LatePolicy_FunctionType FunctionType;
  static const FunctionType WINDOW_FUNCTION = SrlAssignment_LatePolicy_FunctionType_WINDOW_FUNCTION;
  static const FunctionType LINE = SrlAssignment_LatePolicy_FunctionType_LINE;
  static const FunctionType EXPONENTIAL = SrlAssignment_LatePolicy_FunctionType_EXPONENTIAL;
  static inline bool FunctionType_IsValid(int value) {
    return SrlAssignment_LatePolicy_FunctionType_IsValid(value);
  }
  static const FunctionType FunctionType_MIN =
    SrlAssignment_LatePolicy_FunctionType_FunctionType_MIN;
  static const FunctionType FunctionType_MAX =
    SrlAssignment_LatePolicy_FunctionType_FunctionType_MAX;
  static const int FunctionType_ARRAYSIZE =
    SrlAssignment_LatePolicy_FunctionType_FunctionType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FunctionType_descriptor() {
    return SrlAssignment_LatePolicy_FunctionType_descriptor();
  }
  static inline const ::std::string& FunctionType_Name(FunctionType value) {
    return SrlAssignment_LatePolicy_FunctionType_Name(value);
  }
  static inline bool FunctionType_Parse(const ::std::string& name,
      FunctionType* value) {
    return SrlAssignment_LatePolicy_FunctionType_Parse(name, value);
  }

  typedef SrlAssignment_LatePolicy_TimeFrame TimeFrame;
  static const TimeFrame DAY = SrlAssignment_LatePolicy_TimeFrame_DAY;
  static const TimeFrame HOUR = SrlAssignment_LatePolicy_TimeFrame_HOUR;
  static const TimeFrame MINUTE = SrlAssignment_LatePolicy_TimeFrame_MINUTE;
  static inline bool TimeFrame_IsValid(int value) {
    return SrlAssignment_LatePolicy_TimeFrame_IsValid(value);
  }
  static const TimeFrame TimeFrame_MIN =
    SrlAssignment_LatePolicy_TimeFrame_TimeFrame_MIN;
  static const TimeFrame TimeFrame_MAX =
    SrlAssignment_LatePolicy_TimeFrame_TimeFrame_MAX;
  static const int TimeFrame_ARRAYSIZE =
    SrlAssignment_LatePolicy_TimeFrame_TimeFrame_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TimeFrame_descriptor() {
    return SrlAssignment_LatePolicy_TimeFrame_descriptor();
  }
  static inline const ::std::string& TimeFrame_Name(TimeFrame value) {
    return SrlAssignment_LatePolicy_TimeFrame_Name(value);
  }
  static inline bool TimeFrame_Parse(const ::std::string& name,
      TimeFrame* value) {
    return SrlAssignment_LatePolicy_TimeFrame_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .protobuf.srl.school.SrlAssignment.LatePolicy.FunctionType functionType = 1 [default = WINDOW_FUNCTION];
  inline bool has_functiontype() const;
  inline void clear_functiontype();
  static const int kFunctionTypeFieldNumber = 1;
  inline ::protobuf::srl::school::SrlAssignment_LatePolicy_FunctionType functiontype() const;
  inline void set_functiontype(::protobuf::srl::school::SrlAssignment_LatePolicy_FunctionType value);

  // optional .protobuf.srl.school.SrlAssignment.LatePolicy.TimeFrame timeFrameType = 2 [default = DAY];
  inline bool has_timeframetype() const;
  inline void clear_timeframetype();
  static const int kTimeFrameTypeFieldNumber = 2;
  inline ::protobuf::srl::school::SrlAssignment_LatePolicy_TimeFrame timeframetype() const;
  inline void set_timeframetype(::protobuf::srl::school::SrlAssignment_LatePolicy_TimeFrame value);

  // optional float rate = 3;
  inline bool has_rate() const;
  inline void clear_rate();
  static const int kRateFieldNumber = 3;
  inline float rate() const;
  inline void set_rate(float value);

  // optional bool subtractionType = 4;
  inline bool has_subtractiontype() const;
  inline void clear_subtractiontype();
  static const int kSubtractionTypeFieldNumber = 4;
  inline bool subtractiontype() const;
  inline void set_subtractiontype(bool value);

  // @@protoc_insertion_point(class_scope:protobuf.srl.school.SrlAssignment.LatePolicy)
 private:
  inline void set_has_functiontype();
  inline void clear_has_functiontype();
  inline void set_has_timeframetype();
  inline void clear_has_timeframetype();
  inline void set_has_rate();
  inline void clear_has_rate();
  inline void set_has_subtractiontype();
  inline void clear_has_subtractiontype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int functiontype_;
  int timeframetype_;
  float rate_;
  bool subtractiontype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_input_2fschool_2eproto();
  friend void protobuf_AssignDesc_input_2fschool_2eproto();
  friend void protobuf_ShutdownFile_input_2fschool_2eproto();

  void InitAsDefaultInstance();
  static SrlAssignment_LatePolicy* default_instance_;
};
// -------------------------------------------------------------------

class SrlAssignment : public ::google::protobuf::Message {
 public:
  SrlAssignment();
  virtual ~SrlAssignment();

  SrlAssignment(const SrlAssignment& from);

  inline SrlAssignment& operator=(const SrlAssignment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SrlAssignment& default_instance();

  void Swap(SrlAssignment* other);

  // implements Message ----------------------------------------------

  SrlAssignment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SrlAssignment& from);
  void MergeFrom(const SrlAssignment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SrlAssignment_LatePolicy LatePolicy;

  typedef SrlAssignment_AssignmentType AssignmentType;
  static const AssignmentType HOMEWORK = SrlAssignment_AssignmentType_HOMEWORK;
  static const AssignmentType QUIZ = SrlAssignment_AssignmentType_QUIZ;
  static const AssignmentType LAB = SrlAssignment_AssignmentType_LAB;
  static const AssignmentType EXAM = SrlAssignment_AssignmentType_EXAM;
  static const AssignmentType SURVEY = SrlAssignment_AssignmentType_SURVEY;
  static const AssignmentType OTHER = SrlAssignment_AssignmentType_OTHER;
  static inline bool AssignmentType_IsValid(int value) {
    return SrlAssignment_AssignmentType_IsValid(value);
  }
  static const AssignmentType AssignmentType_MIN =
    SrlAssignment_AssignmentType_AssignmentType_MIN;
  static const AssignmentType AssignmentType_MAX =
    SrlAssignment_AssignmentType_AssignmentType_MAX;
  static const int AssignmentType_ARRAYSIZE =
    SrlAssignment_AssignmentType_AssignmentType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  AssignmentType_descriptor() {
    return SrlAssignment_AssignmentType_descriptor();
  }
  static inline const ::std::string& AssignmentType_Name(AssignmentType value) {
    return SrlAssignment_AssignmentType_Name(value);
  }
  static inline bool AssignmentType_Parse(const ::std::string& name,
      AssignmentType* value) {
    return SrlAssignment_AssignmentType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string courseId = 1;
  inline bool has_courseid() const;
  inline void clear_courseid();
  static const int kCourseIdFieldNumber = 1;
  inline const ::std::string& courseid() const;
  inline void set_courseid(const ::std::string& value);
  inline void set_courseid(const char* value);
  inline void set_courseid(const char* value, size_t size);
  inline ::std::string* mutable_courseid();
  inline ::std::string* release_courseid();
  inline void set_allocated_courseid(::std::string* courseid);

  // required string id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .protobuf.srl.school.SrlAssignment.AssignmentType type = 4 [default = HOMEWORK];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline ::protobuf::srl::school::SrlAssignment_AssignmentType type() const;
  inline void set_type(::protobuf::srl::school::SrlAssignment_AssignmentType value);

  // optional string other = 5;
  inline bool has_other() const;
  inline void clear_other();
  static const int kOtherFieldNumber = 5;
  inline const ::std::string& other() const;
  inline void set_other(const ::std::string& value);
  inline void set_other(const char* value);
  inline void set_other(const char* value, size_t size);
  inline ::std::string* mutable_other();
  inline ::std::string* release_other();
  inline void set_allocated_other(::std::string* other);

  // optional string description = 6;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 6;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // repeated string links = 7;
  inline int links_size() const;
  inline void clear_links();
  static const int kLinksFieldNumber = 7;
  inline const ::std::string& links(int index) const;
  inline ::std::string* mutable_links(int index);
  inline void set_links(int index, const ::std::string& value);
  inline void set_links(int index, const char* value);
  inline void set_links(int index, const char* value, size_t size);
  inline ::std::string* add_links();
  inline void add_links(const ::std::string& value);
  inline void add_links(const char* value);
  inline void add_links(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& links() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_links();

  // optional .protobuf.srl.school.SrlAssignment.LatePolicy latePolicy = 8;
  inline bool has_latepolicy() const;
  inline void clear_latepolicy();
  static const int kLatePolicyFieldNumber = 8;
  inline const ::protobuf::srl::school::SrlAssignment_LatePolicy& latepolicy() const;
  inline ::protobuf::srl::school::SrlAssignment_LatePolicy* mutable_latepolicy();
  inline ::protobuf::srl::school::SrlAssignment_LatePolicy* release_latepolicy();
  inline void set_allocated_latepolicy(::protobuf::srl::school::SrlAssignment_LatePolicy* latepolicy);

  // optional string gradeWeight = 9;
  inline bool has_gradeweight() const;
  inline void clear_gradeweight();
  static const int kGradeWeightFieldNumber = 9;
  inline const ::std::string& gradeweight() const;
  inline void set_gradeweight(const ::std::string& value);
  inline void set_gradeweight(const char* value);
  inline void set_gradeweight(const char* value, size_t size);
  inline ::std::string* mutable_gradeweight();
  inline ::std::string* release_gradeweight();
  inline void set_allocated_gradeweight(::std::string* gradeweight);

  // optional float grade = 10;
  inline bool has_grade() const;
  inline void clear_grade();
  static const int kGradeFieldNumber = 10;
  inline float grade() const;
  inline void set_grade(float value);

  // optional .protobuf.srl.school.DateTime accessDate = 11;
  inline bool has_accessdate() const;
  inline void clear_accessdate();
  static const int kAccessDateFieldNumber = 11;
  inline const ::protobuf::srl::school::DateTime& accessdate() const;
  inline ::protobuf::srl::school::DateTime* mutable_accessdate();
  inline ::protobuf::srl::school::DateTime* release_accessdate();
  inline void set_allocated_accessdate(::protobuf::srl::school::DateTime* accessdate);

  // optional .protobuf.srl.school.DateTime dueDate = 12;
  inline bool has_duedate() const;
  inline void clear_duedate();
  static const int kDueDateFieldNumber = 12;
  inline const ::protobuf::srl::school::DateTime& duedate() const;
  inline ::protobuf::srl::school::DateTime* mutable_duedate();
  inline ::protobuf::srl::school::DateTime* release_duedate();
  inline void set_allocated_duedate(::protobuf::srl::school::DateTime* duedate);

  // optional .protobuf.srl.school.DateTime closeDate = 13;
  inline bool has_closedate() const;
  inline void clear_closedate();
  static const int kCloseDateFieldNumber = 13;
  inline const ::protobuf::srl::school::DateTime& closedate() const;
  inline ::protobuf::srl::school::DateTime* mutable_closedate();
  inline ::protobuf::srl::school::DateTime* release_closedate();
  inline void set_allocated_closedate(::protobuf::srl::school::DateTime* closedate);

  // optional .protobuf.srl.school.State state = 14;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 14;
  inline const ::protobuf::srl::school::State& state() const;
  inline ::protobuf::srl::school::State* mutable_state();
  inline ::protobuf::srl::school::State* release_state();
  inline void set_allocated_state(::protobuf::srl::school::State* state);

  // optional string imageUrl = 15;
  inline bool has_imageurl() const;
  inline void clear_imageurl();
  static const int kImageUrlFieldNumber = 15;
  inline const ::std::string& imageurl() const;
  inline void set_imageurl(const ::std::string& value);
  inline void set_imageurl(const char* value);
  inline void set_imageurl(const char* value, size_t size);
  inline ::std::string* mutable_imageurl();
  inline ::std::string* release_imageurl();
  inline void set_allocated_imageurl(::std::string* imageurl);

  // repeated string problemList = 16;
  inline int problemlist_size() const;
  inline void clear_problemlist();
  static const int kProblemListFieldNumber = 16;
  inline const ::std::string& problemlist(int index) const;
  inline ::std::string* mutable_problemlist(int index);
  inline void set_problemlist(int index, const ::std::string& value);
  inline void set_problemlist(int index, const char* value);
  inline void set_problemlist(int index, const char* value, size_t size);
  inline ::std::string* add_problemlist();
  inline void add_problemlist(const ::std::string& value);
  inline void add_problemlist(const char* value);
  inline void add_problemlist(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& problemlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_problemlist();

  // optional .protobuf.srl.school.SrlPermission accessPermission = 17;
  inline bool has_accesspermission() const;
  inline void clear_accesspermission();
  static const int kAccessPermissionFieldNumber = 17;
  inline const ::protobuf::srl::school::SrlPermission& accesspermission() const;
  inline ::protobuf::srl::school::SrlPermission* mutable_accesspermission();
  inline ::protobuf::srl::school::SrlPermission* release_accesspermission();
  inline void set_allocated_accesspermission(::protobuf::srl::school::SrlPermission* accesspermission);

  // @@protoc_insertion_point(class_scope:protobuf.srl.school.SrlAssignment)
 private:
  inline void set_has_courseid();
  inline void clear_has_courseid();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_other();
  inline void clear_has_other();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_latepolicy();
  inline void clear_has_latepolicy();
  inline void set_has_gradeweight();
  inline void clear_has_gradeweight();
  inline void set_has_grade();
  inline void clear_has_grade();
  inline void set_has_accessdate();
  inline void clear_has_accessdate();
  inline void set_has_duedate();
  inline void clear_has_duedate();
  inline void set_has_closedate();
  inline void clear_has_closedate();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_imageurl();
  inline void clear_has_imageurl();
  inline void set_has_accesspermission();
  inline void clear_has_accesspermission();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* courseid_;
  ::std::string* id_;
  ::std::string* name_;
  ::std::string* other_;
  ::std::string* description_;
  ::google::protobuf::RepeatedPtrField< ::std::string> links_;
  int type_;
  float grade_;
  ::protobuf::srl::school::SrlAssignment_LatePolicy* latepolicy_;
  ::std::string* gradeweight_;
  ::protobuf::srl::school::DateTime* accessdate_;
  ::protobuf::srl::school::DateTime* duedate_;
  ::protobuf::srl::school::DateTime* closedate_;
  ::protobuf::srl::school::State* state_;
  ::std::string* imageurl_;
  ::google::protobuf::RepeatedPtrField< ::std::string> problemlist_;
  ::protobuf::srl::school::SrlPermission* accesspermission_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(17 + 31) / 32];

  friend void  protobuf_AddDesc_input_2fschool_2eproto();
  friend void protobuf_AssignDesc_input_2fschool_2eproto();
  friend void protobuf_ShutdownFile_input_2fschool_2eproto();

  void InitAsDefaultInstance();
  static SrlAssignment* default_instance_;
};
// -------------------------------------------------------------------

class SrlProblem : public ::google::protobuf::Message {
 public:
  SrlProblem();
  virtual ~SrlProblem();

  SrlProblem(const SrlProblem& from);

  inline SrlProblem& operator=(const SrlProblem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SrlProblem& default_instance();

  void Swap(SrlProblem* other);

  // implements Message ----------------------------------------------

  SrlProblem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SrlProblem& from);
  void MergeFrom(const SrlProblem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string courseId = 2;
  inline bool has_courseid() const;
  inline void clear_courseid();
  static const int kCourseIdFieldNumber = 2;
  inline const ::std::string& courseid() const;
  inline void set_courseid(const ::std::string& value);
  inline void set_courseid(const char* value);
  inline void set_courseid(const char* value, size_t size);
  inline ::std::string* mutable_courseid();
  inline ::std::string* release_courseid();
  inline void set_allocated_courseid(::std::string* courseid);

  // optional string assignmentId = 3;
  inline bool has_assignmentid() const;
  inline void clear_assignmentid();
  static const int kAssignmentIdFieldNumber = 3;
  inline const ::std::string& assignmentid() const;
  inline void set_assignmentid(const ::std::string& value);
  inline void set_assignmentid(const char* value);
  inline void set_assignmentid(const char* value, size_t size);
  inline ::std::string* mutable_assignmentid();
  inline ::std::string* release_assignmentid();
  inline void set_allocated_assignmentid(::std::string* assignmentid);

  // optional string problemBankId = 4;
  inline bool has_problembankid() const;
  inline void clear_problembankid();
  static const int kProblemBankIdFieldNumber = 4;
  inline const ::std::string& problembankid() const;
  inline void set_problembankid(const ::std::string& value);
  inline void set_problembankid(const char* value);
  inline void set_problembankid(const char* value, size_t size);
  inline ::std::string* mutable_problembankid();
  inline ::std::string* release_problembankid();
  inline void set_allocated_problembankid(::std::string* problembankid);

  // optional string name = 5;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 5;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string description = 6;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 6;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // optional .protobuf.srl.school.SrlBankProblem problemInfo = 7;
  inline bool has_probleminfo() const;
  inline void clear_probleminfo();
  static const int kProblemInfoFieldNumber = 7;
  inline const ::protobuf::srl::school::SrlBankProblem& probleminfo() const;
  inline ::protobuf::srl::school::SrlBankProblem* mutable_probleminfo();
  inline ::protobuf::srl::school::SrlBankProblem* release_probleminfo();
  inline void set_allocated_probleminfo(::protobuf::srl::school::SrlBankProblem* probleminfo);

  // optional string gradeWeight = 8;
  inline bool has_gradeweight() const;
  inline void clear_gradeweight();
  static const int kGradeWeightFieldNumber = 8;
  inline const ::std::string& gradeweight() const;
  inline void set_gradeweight(const ::std::string& value);
  inline void set_gradeweight(const char* value);
  inline void set_gradeweight(const char* value, size_t size);
  inline ::std::string* mutable_gradeweight();
  inline ::std::string* release_gradeweight();
  inline void set_allocated_gradeweight(::std::string* gradeweight);

  // optional float grade = 9;
  inline bool has_grade() const;
  inline void clear_grade();
  static const int kGradeFieldNumber = 9;
  inline float grade() const;
  inline void set_grade(float value);

  // optional .protobuf.srl.school.State state = 10;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 10;
  inline const ::protobuf::srl::school::State& state() const;
  inline ::protobuf::srl::school::State* mutable_state();
  inline ::protobuf::srl::school::State* release_state();
  inline void set_allocated_state(::protobuf::srl::school::State* state);

  // optional .protobuf.srl.school.SrlPermission accessPermission = 11;
  inline bool has_accesspermission() const;
  inline void clear_accesspermission();
  static const int kAccessPermissionFieldNumber = 11;
  inline const ::protobuf::srl::school::SrlPermission& accesspermission() const;
  inline ::protobuf::srl::school::SrlPermission* mutable_accesspermission();
  inline ::protobuf::srl::school::SrlPermission* release_accesspermission();
  inline void set_allocated_accesspermission(::protobuf::srl::school::SrlPermission* accesspermission);

  // optional int32 problemNumber = 12;
  inline bool has_problemnumber() const;
  inline void clear_problemnumber();
  static const int kProblemNumberFieldNumber = 12;
  inline ::google::protobuf::int32 problemnumber() const;
  inline void set_problemnumber(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protobuf.srl.school.SrlProblem)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_courseid();
  inline void clear_has_courseid();
  inline void set_has_assignmentid();
  inline void clear_has_assignmentid();
  inline void set_has_problembankid();
  inline void clear_has_problembankid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_probleminfo();
  inline void clear_has_probleminfo();
  inline void set_has_gradeweight();
  inline void clear_has_gradeweight();
  inline void set_has_grade();
  inline void clear_has_grade();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_accesspermission();
  inline void clear_has_accesspermission();
  inline void set_has_problemnumber();
  inline void clear_has_problemnumber();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* courseid_;
  ::std::string* assignmentid_;
  ::std::string* problembankid_;
  ::std::string* name_;
  ::std::string* description_;
  ::protobuf::srl::school::SrlBankProblem* probleminfo_;
  ::std::string* gradeweight_;
  ::protobuf::srl::school::State* state_;
  float grade_;
  ::google::protobuf::int32 problemnumber_;
  ::protobuf::srl::school::SrlPermission* accesspermission_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_input_2fschool_2eproto();
  friend void protobuf_AssignDesc_input_2fschool_2eproto();
  friend void protobuf_ShutdownFile_input_2fschool_2eproto();

  void InitAsDefaultInstance();
  static SrlProblem* default_instance_;
};
// -------------------------------------------------------------------

class SrlBankProblem : public ::google::protobuf::Message {
 public:
  SrlBankProblem();
  virtual ~SrlBankProblem();

  SrlBankProblem(const SrlBankProblem& from);

  inline SrlBankProblem& operator=(const SrlBankProblem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SrlBankProblem& default_instance();

  void Swap(SrlBankProblem* other);

  // implements Message ----------------------------------------------

  SrlBankProblem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SrlBankProblem& from);
  void MergeFrom(const SrlBankProblem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SrlBankProblem_QuestionType QuestionType;
  static const QuestionType SKETCH = SrlBankProblem_QuestionType_SKETCH;
  static const QuestionType MULT_CHOICE = SrlBankProblem_QuestionType_MULT_CHOICE;
  static const QuestionType FREE_RESP = SrlBankProblem_QuestionType_FREE_RESP;
  static const QuestionType CHECK_BOX = SrlBankProblem_QuestionType_CHECK_BOX;
  static inline bool QuestionType_IsValid(int value) {
    return SrlBankProblem_QuestionType_IsValid(value);
  }
  static const QuestionType QuestionType_MIN =
    SrlBankProblem_QuestionType_QuestionType_MIN;
  static const QuestionType QuestionType_MAX =
    SrlBankProblem_QuestionType_QuestionType_MAX;
  static const int QuestionType_ARRAYSIZE =
    SrlBankProblem_QuestionType_QuestionType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  QuestionType_descriptor() {
    return SrlBankProblem_QuestionType_descriptor();
  }
  static inline const ::std::string& QuestionType_Name(QuestionType value) {
    return SrlBankProblem_QuestionType_Name(value);
  }
  static inline bool QuestionType_Parse(const ::std::string& name,
      QuestionType* value) {
    return SrlBankProblem_QuestionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string questionText = 2;
  inline bool has_questiontext() const;
  inline void clear_questiontext();
  static const int kQuestionTextFieldNumber = 2;
  inline const ::std::string& questiontext() const;
  inline void set_questiontext(const ::std::string& value);
  inline void set_questiontext(const char* value);
  inline void set_questiontext(const char* value, size_t size);
  inline ::std::string* mutable_questiontext();
  inline ::std::string* release_questiontext();
  inline void set_allocated_questiontext(::std::string* questiontext);

  // optional .protobuf.srl.school.SrlBankProblem.QuestionType questionType = 3 [default = SKETCH];
  inline bool has_questiontype() const;
  inline void clear_questiontype();
  static const int kQuestionTypeFieldNumber = 3;
  inline ::protobuf::srl::school::SrlBankProblem_QuestionType questiontype() const;
  inline void set_questiontype(::protobuf::srl::school::SrlBankProblem_QuestionType value);

  // optional string image = 4;
  inline bool has_image() const;
  inline void clear_image();
  static const int kImageFieldNumber = 4;
  inline const ::std::string& image() const;
  inline void set_image(const ::std::string& value);
  inline void set_image(const char* value);
  inline void set_image(const char* value, size_t size);
  inline ::std::string* mutable_image();
  inline ::std::string* release_image();
  inline void set_allocated_image(::std::string* image);

  // optional string solutionId = 5;
  inline bool has_solutionid() const;
  inline void clear_solutionid();
  static const int kSolutionIdFieldNumber = 5;
  inline const ::std::string& solutionid() const;
  inline void set_solutionid(const ::std::string& value);
  inline void set_solutionid(const char* value);
  inline void set_solutionid(const char* value, size_t size);
  inline ::std::string* mutable_solutionid();
  inline ::std::string* release_solutionid();
  inline void set_allocated_solutionid(::std::string* solutionid);

  // optional string courseTopic = 6;
  inline bool has_coursetopic() const;
  inline void clear_coursetopic();
  static const int kCourseTopicFieldNumber = 6;
  inline const ::std::string& coursetopic() const;
  inline void set_coursetopic(const ::std::string& value);
  inline void set_coursetopic(const char* value);
  inline void set_coursetopic(const char* value, size_t size);
  inline ::std::string* mutable_coursetopic();
  inline ::std::string* release_coursetopic();
  inline void set_allocated_coursetopic(::std::string* coursetopic);

  // optional string subTopic = 7;
  inline bool has_subtopic() const;
  inline void clear_subtopic();
  static const int kSubTopicFieldNumber = 7;
  inline const ::std::string& subtopic() const;
  inline void set_subtopic(const ::std::string& value);
  inline void set_subtopic(const char* value);
  inline void set_subtopic(const char* value, size_t size);
  inline ::std::string* mutable_subtopic();
  inline ::std::string* release_subtopic();
  inline void set_allocated_subtopic(::std::string* subtopic);

  // optional string source = 8;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 8;
  inline const ::std::string& source() const;
  inline void set_source(const ::std::string& value);
  inline void set_source(const char* value);
  inline void set_source(const char* value, size_t size);
  inline ::std::string* mutable_source();
  inline ::std::string* release_source();
  inline void set_allocated_source(::std::string* source);

  // repeated string otherKeywords = 9;
  inline int otherkeywords_size() const;
  inline void clear_otherkeywords();
  static const int kOtherKeywordsFieldNumber = 9;
  inline const ::std::string& otherkeywords(int index) const;
  inline ::std::string* mutable_otherkeywords(int index);
  inline void set_otherkeywords(int index, const ::std::string& value);
  inline void set_otherkeywords(int index, const char* value);
  inline void set_otherkeywords(int index, const char* value, size_t size);
  inline ::std::string* add_otherkeywords();
  inline void add_otherkeywords(const ::std::string& value);
  inline void add_otherkeywords(const char* value);
  inline void add_otherkeywords(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& otherkeywords() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_otherkeywords();

  // optional .protobuf.srl.school.SrlPermission accessPermission = 10;
  inline bool has_accesspermission() const;
  inline void clear_accesspermission();
  static const int kAccessPermissionFieldNumber = 10;
  inline const ::protobuf::srl::school::SrlPermission& accesspermission() const;
  inline ::protobuf::srl::school::SrlPermission* mutable_accesspermission();
  inline ::protobuf::srl::school::SrlPermission* release_accesspermission();
  inline void set_allocated_accesspermission(::protobuf::srl::school::SrlPermission* accesspermission);

  // @@protoc_insertion_point(class_scope:protobuf.srl.school.SrlBankProblem)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_questiontext();
  inline void clear_has_questiontext();
  inline void set_has_questiontype();
  inline void clear_has_questiontype();
  inline void set_has_image();
  inline void clear_has_image();
  inline void set_has_solutionid();
  inline void clear_has_solutionid();
  inline void set_has_coursetopic();
  inline void clear_has_coursetopic();
  inline void set_has_subtopic();
  inline void clear_has_subtopic();
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_accesspermission();
  inline void clear_has_accesspermission();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* questiontext_;
  ::std::string* image_;
  ::std::string* solutionid_;
  ::std::string* coursetopic_;
  ::std::string* subtopic_;
  ::std::string* source_;
  ::google::protobuf::RepeatedPtrField< ::std::string> otherkeywords_;
  ::protobuf::srl::school::SrlPermission* accesspermission_;
  int questiontype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_input_2fschool_2eproto();
  friend void protobuf_AssignDesc_input_2fschool_2eproto();
  friend void protobuf_ShutdownFile_input_2fschool_2eproto();

  void InitAsDefaultInstance();
  static SrlBankProblem* default_instance_;
};
// -------------------------------------------------------------------

class SrlGrade : public ::google::protobuf::Message {
 public:
  SrlGrade();
  virtual ~SrlGrade();

  SrlGrade(const SrlGrade& from);

  inline SrlGrade& operator=(const SrlGrade& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SrlGrade& default_instance();

  void Swap(SrlGrade* other);

  // implements Message ----------------------------------------------

  SrlGrade* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SrlGrade& from);
  void MergeFrom(const SrlGrade& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required string problemId = 2;
  inline bool has_problemid() const;
  inline void clear_problemid();
  static const int kProblemIdFieldNumber = 2;
  inline const ::std::string& problemid() const;
  inline void set_problemid(const ::std::string& value);
  inline void set_problemid(const char* value);
  inline void set_problemid(const char* value, size_t size);
  inline ::std::string* mutable_problemid();
  inline ::std::string* release_problemid();
  inline void set_allocated_problemid(::std::string* problemid);

  // required float grade = 3;
  inline bool has_grade() const;
  inline void clear_grade();
  static const int kGradeFieldNumber = 3;
  inline float grade() const;
  inline void set_grade(float value);

  // optional string comment = 4;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 4;
  inline const ::std::string& comment() const;
  inline void set_comment(const ::std::string& value);
  inline void set_comment(const char* value);
  inline void set_comment(const char* value, size_t size);
  inline ::std::string* mutable_comment();
  inline ::std::string* release_comment();
  inline void set_allocated_comment(::std::string* comment);

  // @@protoc_insertion_point(class_scope:protobuf.srl.school.SrlGrade)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_problemid();
  inline void clear_has_problemid();
  inline void set_has_grade();
  inline void clear_has_grade();
  inline void set_has_comment();
  inline void clear_has_comment();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* problemid_;
  ::std::string* comment_;
  float grade_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_input_2fschool_2eproto();
  friend void protobuf_AssignDesc_input_2fschool_2eproto();
  friend void protobuf_ShutdownFile_input_2fschool_2eproto();

  void InitAsDefaultInstance();
  static SrlGrade* default_instance_;
};
// -------------------------------------------------------------------

class DateTime : public ::google::protobuf::Message {
 public:
  DateTime();
  virtual ~DateTime();

  DateTime(const DateTime& from);

  inline DateTime& operator=(const DateTime& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DateTime& default_instance();

  void Swap(DateTime* other);

  // implements Message ----------------------------------------------

  DateTime* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DateTime& from);
  void MergeFrom(const DateTime& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 year = 1;
  inline bool has_year() const;
  inline void clear_year();
  static const int kYearFieldNumber = 1;
  inline ::google::protobuf::int32 year() const;
  inline void set_year(::google::protobuf::int32 value);

  // optional int32 month = 2;
  inline bool has_month() const;
  inline void clear_month();
  static const int kMonthFieldNumber = 2;
  inline ::google::protobuf::int32 month() const;
  inline void set_month(::google::protobuf::int32 value);

  // optional int32 day = 3;
  inline bool has_day() const;
  inline void clear_day();
  static const int kDayFieldNumber = 3;
  inline ::google::protobuf::int32 day() const;
  inline void set_day(::google::protobuf::int32 value);

  // optional int32 hour = 4;
  inline bool has_hour() const;
  inline void clear_hour();
  static const int kHourFieldNumber = 4;
  inline ::google::protobuf::int32 hour() const;
  inline void set_hour(::google::protobuf::int32 value);

  // optional int32 minute = 5;
  inline bool has_minute() const;
  inline void clear_minute();
  static const int kMinuteFieldNumber = 5;
  inline ::google::protobuf::int32 minute() const;
  inline void set_minute(::google::protobuf::int32 value);

  // optional int32 second = 6;
  inline bool has_second() const;
  inline void clear_second();
  static const int kSecondFieldNumber = 6;
  inline ::google::protobuf::int32 second() const;
  inline void set_second(::google::protobuf::int32 value);

  // optional uint64 millisecond = 7;
  inline bool has_millisecond() const;
  inline void clear_millisecond();
  static const int kMillisecondFieldNumber = 7;
  inline ::google::protobuf::uint64 millisecond() const;
  inline void set_millisecond(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:protobuf.srl.school.DateTime)
 private:
  inline void set_has_year();
  inline void clear_has_year();
  inline void set_has_month();
  inline void clear_has_month();
  inline void set_has_day();
  inline void clear_has_day();
  inline void set_has_hour();
  inline void clear_has_hour();
  inline void set_has_minute();
  inline void clear_has_minute();
  inline void set_has_second();
  inline void clear_has_second();
  inline void set_has_millisecond();
  inline void clear_has_millisecond();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 year_;
  ::google::protobuf::int32 month_;
  ::google::protobuf::int32 day_;
  ::google::protobuf::int32 hour_;
  ::google::protobuf::int32 minute_;
  ::google::protobuf::int32 second_;
  ::google::protobuf::uint64 millisecond_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_input_2fschool_2eproto();
  friend void protobuf_AssignDesc_input_2fschool_2eproto();
  friend void protobuf_ShutdownFile_input_2fschool_2eproto();

  void InitAsDefaultInstance();
  static DateTime* default_instance_;
};
// -------------------------------------------------------------------

class DomainInformation : public ::google::protobuf::Message {
 public:
  DomainInformation();
  virtual ~DomainInformation();

  DomainInformation(const DomainInformation& from);

  inline DomainInformation& operator=(const DomainInformation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DomainInformation& default_instance();

  void Swap(DomainInformation* other);

  // implements Message ----------------------------------------------

  DomainInformation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DomainInformation& from);
  void MergeFrom(const DomainInformation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string stuff = 1;
  inline bool has_stuff() const;
  inline void clear_stuff();
  static const int kStuffFieldNumber = 1;
  inline const ::std::string& stuff() const;
  inline void set_stuff(const ::std::string& value);
  inline void set_stuff(const char* value);
  inline void set_stuff(const char* value, size_t size);
  inline ::std::string* mutable_stuff();
  inline ::std::string* release_stuff();
  inline void set_allocated_stuff(::std::string* stuff);

  // @@protoc_insertion_point(class_scope:protobuf.srl.school.DomainInformation)
 private:
  inline void set_has_stuff();
  inline void clear_has_stuff();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* stuff_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_input_2fschool_2eproto();
  friend void protobuf_AssignDesc_input_2fschool_2eproto();
  friend void protobuf_ShutdownFile_input_2fschool_2eproto();

  void InitAsDefaultInstance();
  static DomainInformation* default_instance_;
};
// -------------------------------------------------------------------

class State : public ::google::protobuf::Message {
 public:
  State();
  virtual ~State();

  State(const State& from);

  inline State& operator=(const State& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const State& default_instance();

  void Swap(State* other);

  // implements Message ----------------------------------------------

  State* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const State& from);
  void MergeFrom(const State& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool published = 1;
  inline bool has_published() const;
  inline void clear_published();
  static const int kPublishedFieldNumber = 1;
  inline bool published() const;
  inline void set_published(bool value);

  // optional bool accessible = 2;
  inline bool has_accessible() const;
  inline void clear_accessible();
  static const int kAccessibleFieldNumber = 2;
  inline bool accessible() const;
  inline void set_accessible(bool value);

  // optional bool pastDue = 3;
  inline bool has_pastdue() const;
  inline void clear_pastdue();
  static const int kPastDueFieldNumber = 3;
  inline bool pastdue() const;
  inline void set_pastdue(bool value);

  // optional bool started = 4;
  inline bool has_started() const;
  inline void clear_started();
  static const int kStartedFieldNumber = 4;
  inline bool started() const;
  inline void set_started(bool value);

  // optional bool completed = 5;
  inline bool has_completed() const;
  inline void clear_completed();
  static const int kCompletedFieldNumber = 5;
  inline bool completed() const;
  inline void set_completed(bool value);

  // optional bool graded = 6;
  inline bool has_graded() const;
  inline void clear_graded();
  static const int kGradedFieldNumber = 6;
  inline bool graded() const;
  inline void set_graded(bool value);

  // @@protoc_insertion_point(class_scope:protobuf.srl.school.State)
 private:
  inline void set_has_published();
  inline void clear_has_published();
  inline void set_has_accessible();
  inline void clear_has_accessible();
  inline void set_has_pastdue();
  inline void clear_has_pastdue();
  inline void set_has_started();
  inline void clear_has_started();
  inline void set_has_completed();
  inline void clear_has_completed();
  inline void set_has_graded();
  inline void clear_has_graded();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool published_;
  bool accessible_;
  bool pastdue_;
  bool started_;
  bool completed_;
  bool graded_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_input_2fschool_2eproto();
  friend void protobuf_AssignDesc_input_2fschool_2eproto();
  friend void protobuf_ShutdownFile_input_2fschool_2eproto();

  void InitAsDefaultInstance();
  static State* default_instance_;
};
// -------------------------------------------------------------------

class SrlUser : public ::google::protobuf::Message {
 public:
  SrlUser();
  virtual ~SrlUser();

  SrlUser(const SrlUser& from);

  inline SrlUser& operator=(const SrlUser& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SrlUser& default_instance();

  void Swap(SrlUser* other);

  // implements Message ----------------------------------------------

  SrlUser* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SrlUser& from);
  void MergeFrom(const SrlUser& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string username = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // optional string email = 2;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 2;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // repeated string courseList = 3;
  inline int courselist_size() const;
  inline void clear_courselist();
  static const int kCourseListFieldNumber = 3;
  inline const ::std::string& courselist(int index) const;
  inline ::std::string* mutable_courselist(int index);
  inline void set_courselist(int index, const ::std::string& value);
  inline void set_courselist(int index, const char* value);
  inline void set_courselist(int index, const char* value, size_t size);
  inline ::std::string* add_courselist();
  inline void add_courselist(const ::std::string& value);
  inline void add_courselist(const char* value);
  inline void add_courselist(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& courselist() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_courselist();

  // optional string schoolIdentity = 4;
  inline bool has_schoolidentity() const;
  inline void clear_schoolidentity();
  static const int kSchoolIdentityFieldNumber = 4;
  inline const ::std::string& schoolidentity() const;
  inline void set_schoolidentity(const ::std::string& value);
  inline void set_schoolidentity(const char* value);
  inline void set_schoolidentity(const char* value, size_t size);
  inline ::std::string* mutable_schoolidentity();
  inline ::std::string* release_schoolidentity();
  inline void set_allocated_schoolidentity(::std::string* schoolidentity);

  // optional string firstName = 5;
  inline bool has_firstname() const;
  inline void clear_firstname();
  static const int kFirstNameFieldNumber = 5;
  inline const ::std::string& firstname() const;
  inline void set_firstname(const ::std::string& value);
  inline void set_firstname(const char* value);
  inline void set_firstname(const char* value, size_t size);
  inline ::std::string* mutable_firstname();
  inline ::std::string* release_firstname();
  inline void set_allocated_firstname(::std::string* firstname);

  // optional string lastName = 6;
  inline bool has_lastname() const;
  inline void clear_lastname();
  static const int kLastNameFieldNumber = 6;
  inline const ::std::string& lastname() const;
  inline void set_lastname(const ::std::string& value);
  inline void set_lastname(const char* value);
  inline void set_lastname(const char* value, size_t size);
  inline ::std::string* mutable_lastname();
  inline ::std::string* release_lastname();
  inline void set_allocated_lastname(::std::string* lastname);

  // optional string password = 7;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 7;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:protobuf.srl.school.SrlUser)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_schoolidentity();
  inline void clear_has_schoolidentity();
  inline void set_has_firstname();
  inline void clear_has_firstname();
  inline void set_has_lastname();
  inline void clear_has_lastname();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* username_;
  ::std::string* email_;
  ::google::protobuf::RepeatedPtrField< ::std::string> courselist_;
  ::std::string* schoolidentity_;
  ::std::string* firstname_;
  ::std::string* lastname_;
  ::std::string* password_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_input_2fschool_2eproto();
  friend void protobuf_AssignDesc_input_2fschool_2eproto();
  friend void protobuf_ShutdownFile_input_2fschool_2eproto();

  void InitAsDefaultInstance();
  static SrlUser* default_instance_;
};
// -------------------------------------------------------------------

class SrlGroup : public ::google::protobuf::Message {
 public:
  SrlGroup();
  virtual ~SrlGroup();

  SrlGroup(const SrlGroup& from);

  inline SrlGroup& operator=(const SrlGroup& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SrlGroup& default_instance();

  void Swap(SrlGroup* other);

  // implements Message ----------------------------------------------

  SrlGroup* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SrlGroup& from);
  void MergeFrom(const SrlGroup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string userId = 1;
  inline int userid_size() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 1;
  inline const ::std::string& userid(int index) const;
  inline ::std::string* mutable_userid(int index);
  inline void set_userid(int index, const ::std::string& value);
  inline void set_userid(int index, const char* value);
  inline void set_userid(int index, const char* value, size_t size);
  inline ::std::string* add_userid();
  inline void add_userid(const ::std::string& value);
  inline void add_userid(const char* value);
  inline void add_userid(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& userid() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_userid();

  // required string groupId = 2;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupIdFieldNumber = 2;
  inline const ::std::string& groupid() const;
  inline void set_groupid(const ::std::string& value);
  inline void set_groupid(const char* value);
  inline void set_groupid(const char* value, size_t size);
  inline ::std::string* mutable_groupid();
  inline ::std::string* release_groupid();
  inline void set_allocated_groupid(::std::string* groupid);

  // optional string groupName = 3;
  inline bool has_groupname() const;
  inline void clear_groupname();
  static const int kGroupNameFieldNumber = 3;
  inline const ::std::string& groupname() const;
  inline void set_groupname(const ::std::string& value);
  inline void set_groupname(const char* value);
  inline void set_groupname(const char* value, size_t size);
  inline ::std::string* mutable_groupname();
  inline ::std::string* release_groupname();
  inline void set_allocated_groupname(::std::string* groupname);

  // repeated string admin = 4;
  inline int admin_size() const;
  inline void clear_admin();
  static const int kAdminFieldNumber = 4;
  inline const ::std::string& admin(int index) const;
  inline ::std::string* mutable_admin(int index);
  inline void set_admin(int index, const ::std::string& value);
  inline void set_admin(int index, const char* value);
  inline void set_admin(int index, const char* value, size_t size);
  inline ::std::string* add_admin();
  inline void add_admin(const ::std::string& value);
  inline void add_admin(const char* value);
  inline void add_admin(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& admin() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_admin();

  // @@protoc_insertion_point(class_scope:protobuf.srl.school.SrlGroup)
 private:
  inline void set_has_groupid();
  inline void clear_has_groupid();
  inline void set_has_groupname();
  inline void clear_has_groupname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> userid_;
  ::std::string* groupid_;
  ::std::string* groupname_;
  ::google::protobuf::RepeatedPtrField< ::std::string> admin_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_input_2fschool_2eproto();
  friend void protobuf_AssignDesc_input_2fschool_2eproto();
  friend void protobuf_ShutdownFile_input_2fschool_2eproto();

  void InitAsDefaultInstance();
  static SrlGroup* default_instance_;
};
// -------------------------------------------------------------------

class SrlPermission : public ::google::protobuf::Message {
 public:
  SrlPermission();
  virtual ~SrlPermission();

  SrlPermission(const SrlPermission& from);

  inline SrlPermission& operator=(const SrlPermission& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SrlPermission& default_instance();

  void Swap(SrlPermission* other);

  // implements Message ----------------------------------------------

  SrlPermission* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SrlPermission& from);
  void MergeFrom(const SrlPermission& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string adminPermission = 1;
  inline int adminpermission_size() const;
  inline void clear_adminpermission();
  static const int kAdminPermissionFieldNumber = 1;
  inline const ::std::string& adminpermission(int index) const;
  inline ::std::string* mutable_adminpermission(int index);
  inline void set_adminpermission(int index, const ::std::string& value);
  inline void set_adminpermission(int index, const char* value);
  inline void set_adminpermission(int index, const char* value, size_t size);
  inline ::std::string* add_adminpermission();
  inline void add_adminpermission(const ::std::string& value);
  inline void add_adminpermission(const char* value);
  inline void add_adminpermission(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& adminpermission() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_adminpermission();

  // repeated string moderatorPermission = 2;
  inline int moderatorpermission_size() const;
  inline void clear_moderatorpermission();
  static const int kModeratorPermissionFieldNumber = 2;
  inline const ::std::string& moderatorpermission(int index) const;
  inline ::std::string* mutable_moderatorpermission(int index);
  inline void set_moderatorpermission(int index, const ::std::string& value);
  inline void set_moderatorpermission(int index, const char* value);
  inline void set_moderatorpermission(int index, const char* value, size_t size);
  inline ::std::string* add_moderatorpermission();
  inline void add_moderatorpermission(const ::std::string& value);
  inline void add_moderatorpermission(const char* value);
  inline void add_moderatorpermission(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& moderatorpermission() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_moderatorpermission();

  // repeated string userPermission = 3;
  inline int userpermission_size() const;
  inline void clear_userpermission();
  static const int kUserPermissionFieldNumber = 3;
  inline const ::std::string& userpermission(int index) const;
  inline ::std::string* mutable_userpermission(int index);
  inline void set_userpermission(int index, const ::std::string& value);
  inline void set_userpermission(int index, const char* value);
  inline void set_userpermission(int index, const char* value, size_t size);
  inline ::std::string* add_userpermission();
  inline void add_userpermission(const ::std::string& value);
  inline void add_userpermission(const char* value);
  inline void add_userpermission(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& userpermission() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_userpermission();

  // @@protoc_insertion_point(class_scope:protobuf.srl.school.SrlPermission)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> adminpermission_;
  ::google::protobuf::RepeatedPtrField< ::std::string> moderatorpermission_;
  ::google::protobuf::RepeatedPtrField< ::std::string> userpermission_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_input_2fschool_2eproto();
  friend void protobuf_AssignDesc_input_2fschool_2eproto();
  friend void protobuf_ShutdownFile_input_2fschool_2eproto();

  void InitAsDefaultInstance();
  static SrlPermission* default_instance_;
};
// ===================================================================


// ===================================================================

// SrlSchool

// repeated .protobuf.srl.school.SrlCourse courses = 1;
inline int SrlSchool::courses_size() const {
  return courses_.size();
}
inline void SrlSchool::clear_courses() {
  courses_.Clear();
}
inline const ::protobuf::srl::school::SrlCourse& SrlSchool::courses(int index) const {
  return courses_.Get(index);
}
inline ::protobuf::srl::school::SrlCourse* SrlSchool::mutable_courses(int index) {
  return courses_.Mutable(index);
}
inline ::protobuf::srl::school::SrlCourse* SrlSchool::add_courses() {
  return courses_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlCourse >&
SrlSchool::courses() const {
  return courses_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlCourse >*
SrlSchool::mutable_courses() {
  return &courses_;
}

// repeated .protobuf.srl.school.SrlAssignment assignments = 2;
inline int SrlSchool::assignments_size() const {
  return assignments_.size();
}
inline void SrlSchool::clear_assignments() {
  assignments_.Clear();
}
inline const ::protobuf::srl::school::SrlAssignment& SrlSchool::assignments(int index) const {
  return assignments_.Get(index);
}
inline ::protobuf::srl::school::SrlAssignment* SrlSchool::mutable_assignments(int index) {
  return assignments_.Mutable(index);
}
inline ::protobuf::srl::school::SrlAssignment* SrlSchool::add_assignments() {
  return assignments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlAssignment >&
SrlSchool::assignments() const {
  return assignments_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlAssignment >*
SrlSchool::mutable_assignments() {
  return &assignments_;
}

// repeated .protobuf.srl.school.SrlProblem problems = 3;
inline int SrlSchool::problems_size() const {
  return problems_.size();
}
inline void SrlSchool::clear_problems() {
  problems_.Clear();
}
inline const ::protobuf::srl::school::SrlProblem& SrlSchool::problems(int index) const {
  return problems_.Get(index);
}
inline ::protobuf::srl::school::SrlProblem* SrlSchool::mutable_problems(int index) {
  return problems_.Mutable(index);
}
inline ::protobuf::srl::school::SrlProblem* SrlSchool::add_problems() {
  return problems_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlProblem >&
SrlSchool::problems() const {
  return problems_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlProblem >*
SrlSchool::mutable_problems() {
  return &problems_;
}

// repeated .protobuf.srl.school.SrlBankProblem bankProblems = 4;
inline int SrlSchool::bankproblems_size() const {
  return bankproblems_.size();
}
inline void SrlSchool::clear_bankproblems() {
  bankproblems_.Clear();
}
inline const ::protobuf::srl::school::SrlBankProblem& SrlSchool::bankproblems(int index) const {
  return bankproblems_.Get(index);
}
inline ::protobuf::srl::school::SrlBankProblem* SrlSchool::mutable_bankproblems(int index) {
  return bankproblems_.Mutable(index);
}
inline ::protobuf::srl::school::SrlBankProblem* SrlSchool::add_bankproblems() {
  return bankproblems_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlBankProblem >&
SrlSchool::bankproblems() const {
  return bankproblems_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlBankProblem >*
SrlSchool::mutable_bankproblems() {
  return &bankproblems_;
}

// repeated .protobuf.srl.school.SrlGrade grades = 5;
inline int SrlSchool::grades_size() const {
  return grades_.size();
}
inline void SrlSchool::clear_grades() {
  grades_.Clear();
}
inline const ::protobuf::srl::school::SrlGrade& SrlSchool::grades(int index) const {
  return grades_.Get(index);
}
inline ::protobuf::srl::school::SrlGrade* SrlSchool::mutable_grades(int index) {
  return grades_.Mutable(index);
}
inline ::protobuf::srl::school::SrlGrade* SrlSchool::add_grades() {
  return grades_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlGrade >&
SrlSchool::grades() const {
  return grades_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::srl::school::SrlGrade >*
SrlSchool::mutable_grades() {
  return &grades_;
}

// -------------------------------------------------------------------

// SrlCourse

// required string id = 1;
inline bool SrlCourse::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SrlCourse::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SrlCourse::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SrlCourse::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& SrlCourse::id() const {
  return *id_;
}
inline void SrlCourse::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void SrlCourse::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void SrlCourse::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlCourse::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* SrlCourse::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlCourse::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 2;
inline bool SrlCourse::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SrlCourse::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SrlCourse::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SrlCourse::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& SrlCourse::name() const {
  return *name_;
}
inline void SrlCourse::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SrlCourse::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SrlCourse::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlCourse::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* SrlCourse::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlCourse::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .protobuf.srl.school.SrlPermission accessPermission = 3;
inline bool SrlCourse::has_accesspermission() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SrlCourse::set_has_accesspermission() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SrlCourse::clear_has_accesspermission() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SrlCourse::clear_accesspermission() {
  if (accesspermission_ != NULL) accesspermission_->::protobuf::srl::school::SrlPermission::Clear();
  clear_has_accesspermission();
}
inline const ::protobuf::srl::school::SrlPermission& SrlCourse::accesspermission() const {
  return accesspermission_ != NULL ? *accesspermission_ : *default_instance_->accesspermission_;
}
inline ::protobuf::srl::school::SrlPermission* SrlCourse::mutable_accesspermission() {
  set_has_accesspermission();
  if (accesspermission_ == NULL) accesspermission_ = new ::protobuf::srl::school::SrlPermission;
  return accesspermission_;
}
inline ::protobuf::srl::school::SrlPermission* SrlCourse::release_accesspermission() {
  clear_has_accesspermission();
  ::protobuf::srl::school::SrlPermission* temp = accesspermission_;
  accesspermission_ = NULL;
  return temp;
}
inline void SrlCourse::set_allocated_accesspermission(::protobuf::srl::school::SrlPermission* accesspermission) {
  delete accesspermission_;
  accesspermission_ = accesspermission;
  if (accesspermission) {
    set_has_accesspermission();
  } else {
    clear_has_accesspermission();
  }
}

// optional .protobuf.srl.school.SrlCourse.Accessibility access = 4 [default = PROTECTED];
inline bool SrlCourse::has_access() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SrlCourse::set_has_access() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SrlCourse::clear_has_access() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SrlCourse::clear_access() {
  access_ = 2;
  clear_has_access();
}
inline ::protobuf::srl::school::SrlCourse_Accessibility SrlCourse::access() const {
  return static_cast< ::protobuf::srl::school::SrlCourse_Accessibility >(access_);
}
inline void SrlCourse::set_access(::protobuf::srl::school::SrlCourse_Accessibility value) {
  assert(::protobuf::srl::school::SrlCourse_Accessibility_IsValid(value));
  set_has_access();
  access_ = value;
}

// optional string description = 5;
inline bool SrlCourse::has_description() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SrlCourse::set_has_description() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SrlCourse::clear_has_description() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SrlCourse::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& SrlCourse::description() const {
  return *description_;
}
inline void SrlCourse::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void SrlCourse::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void SrlCourse::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlCourse::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* SrlCourse::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlCourse::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string semester = 6;
inline bool SrlCourse::has_semester() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SrlCourse::set_has_semester() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SrlCourse::clear_has_semester() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SrlCourse::clear_semester() {
  if (semester_ != &::google::protobuf::internal::kEmptyString) {
    semester_->clear();
  }
  clear_has_semester();
}
inline const ::std::string& SrlCourse::semester() const {
  return *semester_;
}
inline void SrlCourse::set_semester(const ::std::string& value) {
  set_has_semester();
  if (semester_ == &::google::protobuf::internal::kEmptyString) {
    semester_ = new ::std::string;
  }
  semester_->assign(value);
}
inline void SrlCourse::set_semester(const char* value) {
  set_has_semester();
  if (semester_ == &::google::protobuf::internal::kEmptyString) {
    semester_ = new ::std::string;
  }
  semester_->assign(value);
}
inline void SrlCourse::set_semester(const char* value, size_t size) {
  set_has_semester();
  if (semester_ == &::google::protobuf::internal::kEmptyString) {
    semester_ = new ::std::string;
  }
  semester_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlCourse::mutable_semester() {
  set_has_semester();
  if (semester_ == &::google::protobuf::internal::kEmptyString) {
    semester_ = new ::std::string;
  }
  return semester_;
}
inline ::std::string* SrlCourse::release_semester() {
  clear_has_semester();
  if (semester_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = semester_;
    semester_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlCourse::set_allocated_semester(::std::string* semester) {
  if (semester_ != &::google::protobuf::internal::kEmptyString) {
    delete semester_;
  }
  if (semester) {
    set_has_semester();
    semester_ = semester;
  } else {
    clear_has_semester();
    semester_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string imageUrl = 7;
inline bool SrlCourse::has_imageurl() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SrlCourse::set_has_imageurl() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SrlCourse::clear_has_imageurl() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SrlCourse::clear_imageurl() {
  if (imageurl_ != &::google::protobuf::internal::kEmptyString) {
    imageurl_->clear();
  }
  clear_has_imageurl();
}
inline const ::std::string& SrlCourse::imageurl() const {
  return *imageurl_;
}
inline void SrlCourse::set_imageurl(const ::std::string& value) {
  set_has_imageurl();
  if (imageurl_ == &::google::protobuf::internal::kEmptyString) {
    imageurl_ = new ::std::string;
  }
  imageurl_->assign(value);
}
inline void SrlCourse::set_imageurl(const char* value) {
  set_has_imageurl();
  if (imageurl_ == &::google::protobuf::internal::kEmptyString) {
    imageurl_ = new ::std::string;
  }
  imageurl_->assign(value);
}
inline void SrlCourse::set_imageurl(const char* value, size_t size) {
  set_has_imageurl();
  if (imageurl_ == &::google::protobuf::internal::kEmptyString) {
    imageurl_ = new ::std::string;
  }
  imageurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlCourse::mutable_imageurl() {
  set_has_imageurl();
  if (imageurl_ == &::google::protobuf::internal::kEmptyString) {
    imageurl_ = new ::std::string;
  }
  return imageurl_;
}
inline ::std::string* SrlCourse::release_imageurl() {
  clear_has_imageurl();
  if (imageurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = imageurl_;
    imageurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlCourse::set_allocated_imageurl(::std::string* imageurl) {
  if (imageurl_ != &::google::protobuf::internal::kEmptyString) {
    delete imageurl_;
  }
  if (imageurl) {
    set_has_imageurl();
    imageurl_ = imageurl;
  } else {
    clear_has_imageurl();
    imageurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float grade = 8;
inline bool SrlCourse::has_grade() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SrlCourse::set_has_grade() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SrlCourse::clear_has_grade() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SrlCourse::clear_grade() {
  grade_ = 0;
  clear_has_grade();
}
inline float SrlCourse::grade() const {
  return grade_;
}
inline void SrlCourse::set_grade(float value) {
  set_has_grade();
  grade_ = value;
}

// optional .protobuf.srl.school.DateTime accessDate = 9;
inline bool SrlCourse::has_accessdate() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SrlCourse::set_has_accessdate() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SrlCourse::clear_has_accessdate() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SrlCourse::clear_accessdate() {
  if (accessdate_ != NULL) accessdate_->::protobuf::srl::school::DateTime::Clear();
  clear_has_accessdate();
}
inline const ::protobuf::srl::school::DateTime& SrlCourse::accessdate() const {
  return accessdate_ != NULL ? *accessdate_ : *default_instance_->accessdate_;
}
inline ::protobuf::srl::school::DateTime* SrlCourse::mutable_accessdate() {
  set_has_accessdate();
  if (accessdate_ == NULL) accessdate_ = new ::protobuf::srl::school::DateTime;
  return accessdate_;
}
inline ::protobuf::srl::school::DateTime* SrlCourse::release_accessdate() {
  clear_has_accessdate();
  ::protobuf::srl::school::DateTime* temp = accessdate_;
  accessdate_ = NULL;
  return temp;
}
inline void SrlCourse::set_allocated_accessdate(::protobuf::srl::school::DateTime* accessdate) {
  delete accessdate_;
  accessdate_ = accessdate;
  if (accessdate) {
    set_has_accessdate();
  } else {
    clear_has_accessdate();
  }
}

// optional .protobuf.srl.school.DateTime closeDate = 10;
inline bool SrlCourse::has_closedate() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SrlCourse::set_has_closedate() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SrlCourse::clear_has_closedate() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SrlCourse::clear_closedate() {
  if (closedate_ != NULL) closedate_->::protobuf::srl::school::DateTime::Clear();
  clear_has_closedate();
}
inline const ::protobuf::srl::school::DateTime& SrlCourse::closedate() const {
  return closedate_ != NULL ? *closedate_ : *default_instance_->closedate_;
}
inline ::protobuf::srl::school::DateTime* SrlCourse::mutable_closedate() {
  set_has_closedate();
  if (closedate_ == NULL) closedate_ = new ::protobuf::srl::school::DateTime;
  return closedate_;
}
inline ::protobuf::srl::school::DateTime* SrlCourse::release_closedate() {
  clear_has_closedate();
  ::protobuf::srl::school::DateTime* temp = closedate_;
  closedate_ = NULL;
  return temp;
}
inline void SrlCourse::set_allocated_closedate(::protobuf::srl::school::DateTime* closedate) {
  delete closedate_;
  closedate_ = closedate;
  if (closedate) {
    set_has_closedate();
  } else {
    clear_has_closedate();
  }
}

// optional .protobuf.srl.school.State state = 11;
inline bool SrlCourse::has_state() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SrlCourse::set_has_state() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SrlCourse::clear_has_state() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SrlCourse::clear_state() {
  if (state_ != NULL) state_->::protobuf::srl::school::State::Clear();
  clear_has_state();
}
inline const ::protobuf::srl::school::State& SrlCourse::state() const {
  return state_ != NULL ? *state_ : *default_instance_->state_;
}
inline ::protobuf::srl::school::State* SrlCourse::mutable_state() {
  set_has_state();
  if (state_ == NULL) state_ = new ::protobuf::srl::school::State;
  return state_;
}
inline ::protobuf::srl::school::State* SrlCourse::release_state() {
  clear_has_state();
  ::protobuf::srl::school::State* temp = state_;
  state_ = NULL;
  return temp;
}
inline void SrlCourse::set_allocated_state(::protobuf::srl::school::State* state) {
  delete state_;
  state_ = state;
  if (state) {
    set_has_state();
  } else {
    clear_has_state();
  }
}

// repeated string assignmentList = 12;
inline int SrlCourse::assignmentlist_size() const {
  return assignmentlist_.size();
}
inline void SrlCourse::clear_assignmentlist() {
  assignmentlist_.Clear();
}
inline const ::std::string& SrlCourse::assignmentlist(int index) const {
  return assignmentlist_.Get(index);
}
inline ::std::string* SrlCourse::mutable_assignmentlist(int index) {
  return assignmentlist_.Mutable(index);
}
inline void SrlCourse::set_assignmentlist(int index, const ::std::string& value) {
  assignmentlist_.Mutable(index)->assign(value);
}
inline void SrlCourse::set_assignmentlist(int index, const char* value) {
  assignmentlist_.Mutable(index)->assign(value);
}
inline void SrlCourse::set_assignmentlist(int index, const char* value, size_t size) {
  assignmentlist_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlCourse::add_assignmentlist() {
  return assignmentlist_.Add();
}
inline void SrlCourse::add_assignmentlist(const ::std::string& value) {
  assignmentlist_.Add()->assign(value);
}
inline void SrlCourse::add_assignmentlist(const char* value) {
  assignmentlist_.Add()->assign(value);
}
inline void SrlCourse::add_assignmentlist(const char* value, size_t size) {
  assignmentlist_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SrlCourse::assignmentlist() const {
  return assignmentlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SrlCourse::mutable_assignmentlist() {
  return &assignmentlist_;
}

// -------------------------------------------------------------------

// SrlAssignment_LatePolicy

// required .protobuf.srl.school.SrlAssignment.LatePolicy.FunctionType functionType = 1 [default = WINDOW_FUNCTION];
inline bool SrlAssignment_LatePolicy::has_functiontype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SrlAssignment_LatePolicy::set_has_functiontype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SrlAssignment_LatePolicy::clear_has_functiontype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SrlAssignment_LatePolicy::clear_functiontype() {
  functiontype_ = 1;
  clear_has_functiontype();
}
inline ::protobuf::srl::school::SrlAssignment_LatePolicy_FunctionType SrlAssignment_LatePolicy::functiontype() const {
  return static_cast< ::protobuf::srl::school::SrlAssignment_LatePolicy_FunctionType >(functiontype_);
}
inline void SrlAssignment_LatePolicy::set_functiontype(::protobuf::srl::school::SrlAssignment_LatePolicy_FunctionType value) {
  assert(::protobuf::srl::school::SrlAssignment_LatePolicy_FunctionType_IsValid(value));
  set_has_functiontype();
  functiontype_ = value;
}

// optional .protobuf.srl.school.SrlAssignment.LatePolicy.TimeFrame timeFrameType = 2 [default = DAY];
inline bool SrlAssignment_LatePolicy::has_timeframetype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SrlAssignment_LatePolicy::set_has_timeframetype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SrlAssignment_LatePolicy::clear_has_timeframetype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SrlAssignment_LatePolicy::clear_timeframetype() {
  timeframetype_ = 1;
  clear_has_timeframetype();
}
inline ::protobuf::srl::school::SrlAssignment_LatePolicy_TimeFrame SrlAssignment_LatePolicy::timeframetype() const {
  return static_cast< ::protobuf::srl::school::SrlAssignment_LatePolicy_TimeFrame >(timeframetype_);
}
inline void SrlAssignment_LatePolicy::set_timeframetype(::protobuf::srl::school::SrlAssignment_LatePolicy_TimeFrame value) {
  assert(::protobuf::srl::school::SrlAssignment_LatePolicy_TimeFrame_IsValid(value));
  set_has_timeframetype();
  timeframetype_ = value;
}

// optional float rate = 3;
inline bool SrlAssignment_LatePolicy::has_rate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SrlAssignment_LatePolicy::set_has_rate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SrlAssignment_LatePolicy::clear_has_rate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SrlAssignment_LatePolicy::clear_rate() {
  rate_ = 0;
  clear_has_rate();
}
inline float SrlAssignment_LatePolicy::rate() const {
  return rate_;
}
inline void SrlAssignment_LatePolicy::set_rate(float value) {
  set_has_rate();
  rate_ = value;
}

// optional bool subtractionType = 4;
inline bool SrlAssignment_LatePolicy::has_subtractiontype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SrlAssignment_LatePolicy::set_has_subtractiontype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SrlAssignment_LatePolicy::clear_has_subtractiontype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SrlAssignment_LatePolicy::clear_subtractiontype() {
  subtractiontype_ = false;
  clear_has_subtractiontype();
}
inline bool SrlAssignment_LatePolicy::subtractiontype() const {
  return subtractiontype_;
}
inline void SrlAssignment_LatePolicy::set_subtractiontype(bool value) {
  set_has_subtractiontype();
  subtractiontype_ = value;
}

// -------------------------------------------------------------------

// SrlAssignment

// required string courseId = 1;
inline bool SrlAssignment::has_courseid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SrlAssignment::set_has_courseid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SrlAssignment::clear_has_courseid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SrlAssignment::clear_courseid() {
  if (courseid_ != &::google::protobuf::internal::kEmptyString) {
    courseid_->clear();
  }
  clear_has_courseid();
}
inline const ::std::string& SrlAssignment::courseid() const {
  return *courseid_;
}
inline void SrlAssignment::set_courseid(const ::std::string& value) {
  set_has_courseid();
  if (courseid_ == &::google::protobuf::internal::kEmptyString) {
    courseid_ = new ::std::string;
  }
  courseid_->assign(value);
}
inline void SrlAssignment::set_courseid(const char* value) {
  set_has_courseid();
  if (courseid_ == &::google::protobuf::internal::kEmptyString) {
    courseid_ = new ::std::string;
  }
  courseid_->assign(value);
}
inline void SrlAssignment::set_courseid(const char* value, size_t size) {
  set_has_courseid();
  if (courseid_ == &::google::protobuf::internal::kEmptyString) {
    courseid_ = new ::std::string;
  }
  courseid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlAssignment::mutable_courseid() {
  set_has_courseid();
  if (courseid_ == &::google::protobuf::internal::kEmptyString) {
    courseid_ = new ::std::string;
  }
  return courseid_;
}
inline ::std::string* SrlAssignment::release_courseid() {
  clear_has_courseid();
  if (courseid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = courseid_;
    courseid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlAssignment::set_allocated_courseid(::std::string* courseid) {
  if (courseid_ != &::google::protobuf::internal::kEmptyString) {
    delete courseid_;
  }
  if (courseid) {
    set_has_courseid();
    courseid_ = courseid;
  } else {
    clear_has_courseid();
    courseid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string id = 2;
inline bool SrlAssignment::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SrlAssignment::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SrlAssignment::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SrlAssignment::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& SrlAssignment::id() const {
  return *id_;
}
inline void SrlAssignment::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void SrlAssignment::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void SrlAssignment::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlAssignment::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* SrlAssignment::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlAssignment::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 3;
inline bool SrlAssignment::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SrlAssignment::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SrlAssignment::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SrlAssignment::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& SrlAssignment::name() const {
  return *name_;
}
inline void SrlAssignment::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SrlAssignment::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SrlAssignment::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlAssignment::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* SrlAssignment::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlAssignment::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .protobuf.srl.school.SrlAssignment.AssignmentType type = 4 [default = HOMEWORK];
inline bool SrlAssignment::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SrlAssignment::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SrlAssignment::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SrlAssignment::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::protobuf::srl::school::SrlAssignment_AssignmentType SrlAssignment::type() const {
  return static_cast< ::protobuf::srl::school::SrlAssignment_AssignmentType >(type_);
}
inline void SrlAssignment::set_type(::protobuf::srl::school::SrlAssignment_AssignmentType value) {
  assert(::protobuf::srl::school::SrlAssignment_AssignmentType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string other = 5;
inline bool SrlAssignment::has_other() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SrlAssignment::set_has_other() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SrlAssignment::clear_has_other() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SrlAssignment::clear_other() {
  if (other_ != &::google::protobuf::internal::kEmptyString) {
    other_->clear();
  }
  clear_has_other();
}
inline const ::std::string& SrlAssignment::other() const {
  return *other_;
}
inline void SrlAssignment::set_other(const ::std::string& value) {
  set_has_other();
  if (other_ == &::google::protobuf::internal::kEmptyString) {
    other_ = new ::std::string;
  }
  other_->assign(value);
}
inline void SrlAssignment::set_other(const char* value) {
  set_has_other();
  if (other_ == &::google::protobuf::internal::kEmptyString) {
    other_ = new ::std::string;
  }
  other_->assign(value);
}
inline void SrlAssignment::set_other(const char* value, size_t size) {
  set_has_other();
  if (other_ == &::google::protobuf::internal::kEmptyString) {
    other_ = new ::std::string;
  }
  other_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlAssignment::mutable_other() {
  set_has_other();
  if (other_ == &::google::protobuf::internal::kEmptyString) {
    other_ = new ::std::string;
  }
  return other_;
}
inline ::std::string* SrlAssignment::release_other() {
  clear_has_other();
  if (other_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = other_;
    other_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlAssignment::set_allocated_other(::std::string* other) {
  if (other_ != &::google::protobuf::internal::kEmptyString) {
    delete other_;
  }
  if (other) {
    set_has_other();
    other_ = other;
  } else {
    clear_has_other();
    other_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string description = 6;
inline bool SrlAssignment::has_description() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SrlAssignment::set_has_description() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SrlAssignment::clear_has_description() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SrlAssignment::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& SrlAssignment::description() const {
  return *description_;
}
inline void SrlAssignment::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void SrlAssignment::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void SrlAssignment::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlAssignment::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* SrlAssignment::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlAssignment::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string links = 7;
inline int SrlAssignment::links_size() const {
  return links_.size();
}
inline void SrlAssignment::clear_links() {
  links_.Clear();
}
inline const ::std::string& SrlAssignment::links(int index) const {
  return links_.Get(index);
}
inline ::std::string* SrlAssignment::mutable_links(int index) {
  return links_.Mutable(index);
}
inline void SrlAssignment::set_links(int index, const ::std::string& value) {
  links_.Mutable(index)->assign(value);
}
inline void SrlAssignment::set_links(int index, const char* value) {
  links_.Mutable(index)->assign(value);
}
inline void SrlAssignment::set_links(int index, const char* value, size_t size) {
  links_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlAssignment::add_links() {
  return links_.Add();
}
inline void SrlAssignment::add_links(const ::std::string& value) {
  links_.Add()->assign(value);
}
inline void SrlAssignment::add_links(const char* value) {
  links_.Add()->assign(value);
}
inline void SrlAssignment::add_links(const char* value, size_t size) {
  links_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SrlAssignment::links() const {
  return links_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SrlAssignment::mutable_links() {
  return &links_;
}

// optional .protobuf.srl.school.SrlAssignment.LatePolicy latePolicy = 8;
inline bool SrlAssignment::has_latepolicy() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SrlAssignment::set_has_latepolicy() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SrlAssignment::clear_has_latepolicy() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SrlAssignment::clear_latepolicy() {
  if (latepolicy_ != NULL) latepolicy_->::protobuf::srl::school::SrlAssignment_LatePolicy::Clear();
  clear_has_latepolicy();
}
inline const ::protobuf::srl::school::SrlAssignment_LatePolicy& SrlAssignment::latepolicy() const {
  return latepolicy_ != NULL ? *latepolicy_ : *default_instance_->latepolicy_;
}
inline ::protobuf::srl::school::SrlAssignment_LatePolicy* SrlAssignment::mutable_latepolicy() {
  set_has_latepolicy();
  if (latepolicy_ == NULL) latepolicy_ = new ::protobuf::srl::school::SrlAssignment_LatePolicy;
  return latepolicy_;
}
inline ::protobuf::srl::school::SrlAssignment_LatePolicy* SrlAssignment::release_latepolicy() {
  clear_has_latepolicy();
  ::protobuf::srl::school::SrlAssignment_LatePolicy* temp = latepolicy_;
  latepolicy_ = NULL;
  return temp;
}
inline void SrlAssignment::set_allocated_latepolicy(::protobuf::srl::school::SrlAssignment_LatePolicy* latepolicy) {
  delete latepolicy_;
  latepolicy_ = latepolicy;
  if (latepolicy) {
    set_has_latepolicy();
  } else {
    clear_has_latepolicy();
  }
}

// optional string gradeWeight = 9;
inline bool SrlAssignment::has_gradeweight() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SrlAssignment::set_has_gradeweight() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SrlAssignment::clear_has_gradeweight() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SrlAssignment::clear_gradeweight() {
  if (gradeweight_ != &::google::protobuf::internal::kEmptyString) {
    gradeweight_->clear();
  }
  clear_has_gradeweight();
}
inline const ::std::string& SrlAssignment::gradeweight() const {
  return *gradeweight_;
}
inline void SrlAssignment::set_gradeweight(const ::std::string& value) {
  set_has_gradeweight();
  if (gradeweight_ == &::google::protobuf::internal::kEmptyString) {
    gradeweight_ = new ::std::string;
  }
  gradeweight_->assign(value);
}
inline void SrlAssignment::set_gradeweight(const char* value) {
  set_has_gradeweight();
  if (gradeweight_ == &::google::protobuf::internal::kEmptyString) {
    gradeweight_ = new ::std::string;
  }
  gradeweight_->assign(value);
}
inline void SrlAssignment::set_gradeweight(const char* value, size_t size) {
  set_has_gradeweight();
  if (gradeweight_ == &::google::protobuf::internal::kEmptyString) {
    gradeweight_ = new ::std::string;
  }
  gradeweight_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlAssignment::mutable_gradeweight() {
  set_has_gradeweight();
  if (gradeweight_ == &::google::protobuf::internal::kEmptyString) {
    gradeweight_ = new ::std::string;
  }
  return gradeweight_;
}
inline ::std::string* SrlAssignment::release_gradeweight() {
  clear_has_gradeweight();
  if (gradeweight_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gradeweight_;
    gradeweight_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlAssignment::set_allocated_gradeweight(::std::string* gradeweight) {
  if (gradeweight_ != &::google::protobuf::internal::kEmptyString) {
    delete gradeweight_;
  }
  if (gradeweight) {
    set_has_gradeweight();
    gradeweight_ = gradeweight;
  } else {
    clear_has_gradeweight();
    gradeweight_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float grade = 10;
inline bool SrlAssignment::has_grade() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SrlAssignment::set_has_grade() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SrlAssignment::clear_has_grade() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SrlAssignment::clear_grade() {
  grade_ = 0;
  clear_has_grade();
}
inline float SrlAssignment::grade() const {
  return grade_;
}
inline void SrlAssignment::set_grade(float value) {
  set_has_grade();
  grade_ = value;
}

// optional .protobuf.srl.school.DateTime accessDate = 11;
inline bool SrlAssignment::has_accessdate() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SrlAssignment::set_has_accessdate() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SrlAssignment::clear_has_accessdate() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SrlAssignment::clear_accessdate() {
  if (accessdate_ != NULL) accessdate_->::protobuf::srl::school::DateTime::Clear();
  clear_has_accessdate();
}
inline const ::protobuf::srl::school::DateTime& SrlAssignment::accessdate() const {
  return accessdate_ != NULL ? *accessdate_ : *default_instance_->accessdate_;
}
inline ::protobuf::srl::school::DateTime* SrlAssignment::mutable_accessdate() {
  set_has_accessdate();
  if (accessdate_ == NULL) accessdate_ = new ::protobuf::srl::school::DateTime;
  return accessdate_;
}
inline ::protobuf::srl::school::DateTime* SrlAssignment::release_accessdate() {
  clear_has_accessdate();
  ::protobuf::srl::school::DateTime* temp = accessdate_;
  accessdate_ = NULL;
  return temp;
}
inline void SrlAssignment::set_allocated_accessdate(::protobuf::srl::school::DateTime* accessdate) {
  delete accessdate_;
  accessdate_ = accessdate;
  if (accessdate) {
    set_has_accessdate();
  } else {
    clear_has_accessdate();
  }
}

// optional .protobuf.srl.school.DateTime dueDate = 12;
inline bool SrlAssignment::has_duedate() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SrlAssignment::set_has_duedate() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SrlAssignment::clear_has_duedate() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SrlAssignment::clear_duedate() {
  if (duedate_ != NULL) duedate_->::protobuf::srl::school::DateTime::Clear();
  clear_has_duedate();
}
inline const ::protobuf::srl::school::DateTime& SrlAssignment::duedate() const {
  return duedate_ != NULL ? *duedate_ : *default_instance_->duedate_;
}
inline ::protobuf::srl::school::DateTime* SrlAssignment::mutable_duedate() {
  set_has_duedate();
  if (duedate_ == NULL) duedate_ = new ::protobuf::srl::school::DateTime;
  return duedate_;
}
inline ::protobuf::srl::school::DateTime* SrlAssignment::release_duedate() {
  clear_has_duedate();
  ::protobuf::srl::school::DateTime* temp = duedate_;
  duedate_ = NULL;
  return temp;
}
inline void SrlAssignment::set_allocated_duedate(::protobuf::srl::school::DateTime* duedate) {
  delete duedate_;
  duedate_ = duedate;
  if (duedate) {
    set_has_duedate();
  } else {
    clear_has_duedate();
  }
}

// optional .protobuf.srl.school.DateTime closeDate = 13;
inline bool SrlAssignment::has_closedate() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SrlAssignment::set_has_closedate() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SrlAssignment::clear_has_closedate() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SrlAssignment::clear_closedate() {
  if (closedate_ != NULL) closedate_->::protobuf::srl::school::DateTime::Clear();
  clear_has_closedate();
}
inline const ::protobuf::srl::school::DateTime& SrlAssignment::closedate() const {
  return closedate_ != NULL ? *closedate_ : *default_instance_->closedate_;
}
inline ::protobuf::srl::school::DateTime* SrlAssignment::mutable_closedate() {
  set_has_closedate();
  if (closedate_ == NULL) closedate_ = new ::protobuf::srl::school::DateTime;
  return closedate_;
}
inline ::protobuf::srl::school::DateTime* SrlAssignment::release_closedate() {
  clear_has_closedate();
  ::protobuf::srl::school::DateTime* temp = closedate_;
  closedate_ = NULL;
  return temp;
}
inline void SrlAssignment::set_allocated_closedate(::protobuf::srl::school::DateTime* closedate) {
  delete closedate_;
  closedate_ = closedate;
  if (closedate) {
    set_has_closedate();
  } else {
    clear_has_closedate();
  }
}

// optional .protobuf.srl.school.State state = 14;
inline bool SrlAssignment::has_state() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SrlAssignment::set_has_state() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SrlAssignment::clear_has_state() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SrlAssignment::clear_state() {
  if (state_ != NULL) state_->::protobuf::srl::school::State::Clear();
  clear_has_state();
}
inline const ::protobuf::srl::school::State& SrlAssignment::state() const {
  return state_ != NULL ? *state_ : *default_instance_->state_;
}
inline ::protobuf::srl::school::State* SrlAssignment::mutable_state() {
  set_has_state();
  if (state_ == NULL) state_ = new ::protobuf::srl::school::State;
  return state_;
}
inline ::protobuf::srl::school::State* SrlAssignment::release_state() {
  clear_has_state();
  ::protobuf::srl::school::State* temp = state_;
  state_ = NULL;
  return temp;
}
inline void SrlAssignment::set_allocated_state(::protobuf::srl::school::State* state) {
  delete state_;
  state_ = state;
  if (state) {
    set_has_state();
  } else {
    clear_has_state();
  }
}

// optional string imageUrl = 15;
inline bool SrlAssignment::has_imageurl() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SrlAssignment::set_has_imageurl() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SrlAssignment::clear_has_imageurl() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SrlAssignment::clear_imageurl() {
  if (imageurl_ != &::google::protobuf::internal::kEmptyString) {
    imageurl_->clear();
  }
  clear_has_imageurl();
}
inline const ::std::string& SrlAssignment::imageurl() const {
  return *imageurl_;
}
inline void SrlAssignment::set_imageurl(const ::std::string& value) {
  set_has_imageurl();
  if (imageurl_ == &::google::protobuf::internal::kEmptyString) {
    imageurl_ = new ::std::string;
  }
  imageurl_->assign(value);
}
inline void SrlAssignment::set_imageurl(const char* value) {
  set_has_imageurl();
  if (imageurl_ == &::google::protobuf::internal::kEmptyString) {
    imageurl_ = new ::std::string;
  }
  imageurl_->assign(value);
}
inline void SrlAssignment::set_imageurl(const char* value, size_t size) {
  set_has_imageurl();
  if (imageurl_ == &::google::protobuf::internal::kEmptyString) {
    imageurl_ = new ::std::string;
  }
  imageurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlAssignment::mutable_imageurl() {
  set_has_imageurl();
  if (imageurl_ == &::google::protobuf::internal::kEmptyString) {
    imageurl_ = new ::std::string;
  }
  return imageurl_;
}
inline ::std::string* SrlAssignment::release_imageurl() {
  clear_has_imageurl();
  if (imageurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = imageurl_;
    imageurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlAssignment::set_allocated_imageurl(::std::string* imageurl) {
  if (imageurl_ != &::google::protobuf::internal::kEmptyString) {
    delete imageurl_;
  }
  if (imageurl) {
    set_has_imageurl();
    imageurl_ = imageurl;
  } else {
    clear_has_imageurl();
    imageurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string problemList = 16;
inline int SrlAssignment::problemlist_size() const {
  return problemlist_.size();
}
inline void SrlAssignment::clear_problemlist() {
  problemlist_.Clear();
}
inline const ::std::string& SrlAssignment::problemlist(int index) const {
  return problemlist_.Get(index);
}
inline ::std::string* SrlAssignment::mutable_problemlist(int index) {
  return problemlist_.Mutable(index);
}
inline void SrlAssignment::set_problemlist(int index, const ::std::string& value) {
  problemlist_.Mutable(index)->assign(value);
}
inline void SrlAssignment::set_problemlist(int index, const char* value) {
  problemlist_.Mutable(index)->assign(value);
}
inline void SrlAssignment::set_problemlist(int index, const char* value, size_t size) {
  problemlist_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlAssignment::add_problemlist() {
  return problemlist_.Add();
}
inline void SrlAssignment::add_problemlist(const ::std::string& value) {
  problemlist_.Add()->assign(value);
}
inline void SrlAssignment::add_problemlist(const char* value) {
  problemlist_.Add()->assign(value);
}
inline void SrlAssignment::add_problemlist(const char* value, size_t size) {
  problemlist_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SrlAssignment::problemlist() const {
  return problemlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SrlAssignment::mutable_problemlist() {
  return &problemlist_;
}

// optional .protobuf.srl.school.SrlPermission accessPermission = 17;
inline bool SrlAssignment::has_accesspermission() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void SrlAssignment::set_has_accesspermission() {
  _has_bits_[0] |= 0x00010000u;
}
inline void SrlAssignment::clear_has_accesspermission() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void SrlAssignment::clear_accesspermission() {
  if (accesspermission_ != NULL) accesspermission_->::protobuf::srl::school::SrlPermission::Clear();
  clear_has_accesspermission();
}
inline const ::protobuf::srl::school::SrlPermission& SrlAssignment::accesspermission() const {
  return accesspermission_ != NULL ? *accesspermission_ : *default_instance_->accesspermission_;
}
inline ::protobuf::srl::school::SrlPermission* SrlAssignment::mutable_accesspermission() {
  set_has_accesspermission();
  if (accesspermission_ == NULL) accesspermission_ = new ::protobuf::srl::school::SrlPermission;
  return accesspermission_;
}
inline ::protobuf::srl::school::SrlPermission* SrlAssignment::release_accesspermission() {
  clear_has_accesspermission();
  ::protobuf::srl::school::SrlPermission* temp = accesspermission_;
  accesspermission_ = NULL;
  return temp;
}
inline void SrlAssignment::set_allocated_accesspermission(::protobuf::srl::school::SrlPermission* accesspermission) {
  delete accesspermission_;
  accesspermission_ = accesspermission;
  if (accesspermission) {
    set_has_accesspermission();
  } else {
    clear_has_accesspermission();
  }
}

// -------------------------------------------------------------------

// SrlProblem

// required string id = 1;
inline bool SrlProblem::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SrlProblem::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SrlProblem::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SrlProblem::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& SrlProblem::id() const {
  return *id_;
}
inline void SrlProblem::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void SrlProblem::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void SrlProblem::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlProblem::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* SrlProblem::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlProblem::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string courseId = 2;
inline bool SrlProblem::has_courseid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SrlProblem::set_has_courseid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SrlProblem::clear_has_courseid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SrlProblem::clear_courseid() {
  if (courseid_ != &::google::protobuf::internal::kEmptyString) {
    courseid_->clear();
  }
  clear_has_courseid();
}
inline const ::std::string& SrlProblem::courseid() const {
  return *courseid_;
}
inline void SrlProblem::set_courseid(const ::std::string& value) {
  set_has_courseid();
  if (courseid_ == &::google::protobuf::internal::kEmptyString) {
    courseid_ = new ::std::string;
  }
  courseid_->assign(value);
}
inline void SrlProblem::set_courseid(const char* value) {
  set_has_courseid();
  if (courseid_ == &::google::protobuf::internal::kEmptyString) {
    courseid_ = new ::std::string;
  }
  courseid_->assign(value);
}
inline void SrlProblem::set_courseid(const char* value, size_t size) {
  set_has_courseid();
  if (courseid_ == &::google::protobuf::internal::kEmptyString) {
    courseid_ = new ::std::string;
  }
  courseid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlProblem::mutable_courseid() {
  set_has_courseid();
  if (courseid_ == &::google::protobuf::internal::kEmptyString) {
    courseid_ = new ::std::string;
  }
  return courseid_;
}
inline ::std::string* SrlProblem::release_courseid() {
  clear_has_courseid();
  if (courseid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = courseid_;
    courseid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlProblem::set_allocated_courseid(::std::string* courseid) {
  if (courseid_ != &::google::protobuf::internal::kEmptyString) {
    delete courseid_;
  }
  if (courseid) {
    set_has_courseid();
    courseid_ = courseid;
  } else {
    clear_has_courseid();
    courseid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string assignmentId = 3;
inline bool SrlProblem::has_assignmentid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SrlProblem::set_has_assignmentid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SrlProblem::clear_has_assignmentid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SrlProblem::clear_assignmentid() {
  if (assignmentid_ != &::google::protobuf::internal::kEmptyString) {
    assignmentid_->clear();
  }
  clear_has_assignmentid();
}
inline const ::std::string& SrlProblem::assignmentid() const {
  return *assignmentid_;
}
inline void SrlProblem::set_assignmentid(const ::std::string& value) {
  set_has_assignmentid();
  if (assignmentid_ == &::google::protobuf::internal::kEmptyString) {
    assignmentid_ = new ::std::string;
  }
  assignmentid_->assign(value);
}
inline void SrlProblem::set_assignmentid(const char* value) {
  set_has_assignmentid();
  if (assignmentid_ == &::google::protobuf::internal::kEmptyString) {
    assignmentid_ = new ::std::string;
  }
  assignmentid_->assign(value);
}
inline void SrlProblem::set_assignmentid(const char* value, size_t size) {
  set_has_assignmentid();
  if (assignmentid_ == &::google::protobuf::internal::kEmptyString) {
    assignmentid_ = new ::std::string;
  }
  assignmentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlProblem::mutable_assignmentid() {
  set_has_assignmentid();
  if (assignmentid_ == &::google::protobuf::internal::kEmptyString) {
    assignmentid_ = new ::std::string;
  }
  return assignmentid_;
}
inline ::std::string* SrlProblem::release_assignmentid() {
  clear_has_assignmentid();
  if (assignmentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = assignmentid_;
    assignmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlProblem::set_allocated_assignmentid(::std::string* assignmentid) {
  if (assignmentid_ != &::google::protobuf::internal::kEmptyString) {
    delete assignmentid_;
  }
  if (assignmentid) {
    set_has_assignmentid();
    assignmentid_ = assignmentid;
  } else {
    clear_has_assignmentid();
    assignmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string problemBankId = 4;
inline bool SrlProblem::has_problembankid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SrlProblem::set_has_problembankid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SrlProblem::clear_has_problembankid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SrlProblem::clear_problembankid() {
  if (problembankid_ != &::google::protobuf::internal::kEmptyString) {
    problembankid_->clear();
  }
  clear_has_problembankid();
}
inline const ::std::string& SrlProblem::problembankid() const {
  return *problembankid_;
}
inline void SrlProblem::set_problembankid(const ::std::string& value) {
  set_has_problembankid();
  if (problembankid_ == &::google::protobuf::internal::kEmptyString) {
    problembankid_ = new ::std::string;
  }
  problembankid_->assign(value);
}
inline void SrlProblem::set_problembankid(const char* value) {
  set_has_problembankid();
  if (problembankid_ == &::google::protobuf::internal::kEmptyString) {
    problembankid_ = new ::std::string;
  }
  problembankid_->assign(value);
}
inline void SrlProblem::set_problembankid(const char* value, size_t size) {
  set_has_problembankid();
  if (problembankid_ == &::google::protobuf::internal::kEmptyString) {
    problembankid_ = new ::std::string;
  }
  problembankid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlProblem::mutable_problembankid() {
  set_has_problembankid();
  if (problembankid_ == &::google::protobuf::internal::kEmptyString) {
    problembankid_ = new ::std::string;
  }
  return problembankid_;
}
inline ::std::string* SrlProblem::release_problembankid() {
  clear_has_problembankid();
  if (problembankid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = problembankid_;
    problembankid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlProblem::set_allocated_problembankid(::std::string* problembankid) {
  if (problembankid_ != &::google::protobuf::internal::kEmptyString) {
    delete problembankid_;
  }
  if (problembankid) {
    set_has_problembankid();
    problembankid_ = problembankid;
  } else {
    clear_has_problembankid();
    problembankid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 5;
inline bool SrlProblem::has_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SrlProblem::set_has_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SrlProblem::clear_has_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SrlProblem::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& SrlProblem::name() const {
  return *name_;
}
inline void SrlProblem::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SrlProblem::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SrlProblem::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlProblem::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* SrlProblem::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlProblem::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string description = 6;
inline bool SrlProblem::has_description() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SrlProblem::set_has_description() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SrlProblem::clear_has_description() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SrlProblem::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& SrlProblem::description() const {
  return *description_;
}
inline void SrlProblem::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void SrlProblem::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void SrlProblem::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlProblem::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* SrlProblem::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlProblem::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .protobuf.srl.school.SrlBankProblem problemInfo = 7;
inline bool SrlProblem::has_probleminfo() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SrlProblem::set_has_probleminfo() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SrlProblem::clear_has_probleminfo() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SrlProblem::clear_probleminfo() {
  if (probleminfo_ != NULL) probleminfo_->::protobuf::srl::school::SrlBankProblem::Clear();
  clear_has_probleminfo();
}
inline const ::protobuf::srl::school::SrlBankProblem& SrlProblem::probleminfo() const {
  return probleminfo_ != NULL ? *probleminfo_ : *default_instance_->probleminfo_;
}
inline ::protobuf::srl::school::SrlBankProblem* SrlProblem::mutable_probleminfo() {
  set_has_probleminfo();
  if (probleminfo_ == NULL) probleminfo_ = new ::protobuf::srl::school::SrlBankProblem;
  return probleminfo_;
}
inline ::protobuf::srl::school::SrlBankProblem* SrlProblem::release_probleminfo() {
  clear_has_probleminfo();
  ::protobuf::srl::school::SrlBankProblem* temp = probleminfo_;
  probleminfo_ = NULL;
  return temp;
}
inline void SrlProblem::set_allocated_probleminfo(::protobuf::srl::school::SrlBankProblem* probleminfo) {
  delete probleminfo_;
  probleminfo_ = probleminfo;
  if (probleminfo) {
    set_has_probleminfo();
  } else {
    clear_has_probleminfo();
  }
}

// optional string gradeWeight = 8;
inline bool SrlProblem::has_gradeweight() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SrlProblem::set_has_gradeweight() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SrlProblem::clear_has_gradeweight() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SrlProblem::clear_gradeweight() {
  if (gradeweight_ != &::google::protobuf::internal::kEmptyString) {
    gradeweight_->clear();
  }
  clear_has_gradeweight();
}
inline const ::std::string& SrlProblem::gradeweight() const {
  return *gradeweight_;
}
inline void SrlProblem::set_gradeweight(const ::std::string& value) {
  set_has_gradeweight();
  if (gradeweight_ == &::google::protobuf::internal::kEmptyString) {
    gradeweight_ = new ::std::string;
  }
  gradeweight_->assign(value);
}
inline void SrlProblem::set_gradeweight(const char* value) {
  set_has_gradeweight();
  if (gradeweight_ == &::google::protobuf::internal::kEmptyString) {
    gradeweight_ = new ::std::string;
  }
  gradeweight_->assign(value);
}
inline void SrlProblem::set_gradeweight(const char* value, size_t size) {
  set_has_gradeweight();
  if (gradeweight_ == &::google::protobuf::internal::kEmptyString) {
    gradeweight_ = new ::std::string;
  }
  gradeweight_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlProblem::mutable_gradeweight() {
  set_has_gradeweight();
  if (gradeweight_ == &::google::protobuf::internal::kEmptyString) {
    gradeweight_ = new ::std::string;
  }
  return gradeweight_;
}
inline ::std::string* SrlProblem::release_gradeweight() {
  clear_has_gradeweight();
  if (gradeweight_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gradeweight_;
    gradeweight_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlProblem::set_allocated_gradeweight(::std::string* gradeweight) {
  if (gradeweight_ != &::google::protobuf::internal::kEmptyString) {
    delete gradeweight_;
  }
  if (gradeweight) {
    set_has_gradeweight();
    gradeweight_ = gradeweight;
  } else {
    clear_has_gradeweight();
    gradeweight_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float grade = 9;
inline bool SrlProblem::has_grade() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SrlProblem::set_has_grade() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SrlProblem::clear_has_grade() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SrlProblem::clear_grade() {
  grade_ = 0;
  clear_has_grade();
}
inline float SrlProblem::grade() const {
  return grade_;
}
inline void SrlProblem::set_grade(float value) {
  set_has_grade();
  grade_ = value;
}

// optional .protobuf.srl.school.State state = 10;
inline bool SrlProblem::has_state() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SrlProblem::set_has_state() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SrlProblem::clear_has_state() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SrlProblem::clear_state() {
  if (state_ != NULL) state_->::protobuf::srl::school::State::Clear();
  clear_has_state();
}
inline const ::protobuf::srl::school::State& SrlProblem::state() const {
  return state_ != NULL ? *state_ : *default_instance_->state_;
}
inline ::protobuf::srl::school::State* SrlProblem::mutable_state() {
  set_has_state();
  if (state_ == NULL) state_ = new ::protobuf::srl::school::State;
  return state_;
}
inline ::protobuf::srl::school::State* SrlProblem::release_state() {
  clear_has_state();
  ::protobuf::srl::school::State* temp = state_;
  state_ = NULL;
  return temp;
}
inline void SrlProblem::set_allocated_state(::protobuf::srl::school::State* state) {
  delete state_;
  state_ = state;
  if (state) {
    set_has_state();
  } else {
    clear_has_state();
  }
}

// optional .protobuf.srl.school.SrlPermission accessPermission = 11;
inline bool SrlProblem::has_accesspermission() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SrlProblem::set_has_accesspermission() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SrlProblem::clear_has_accesspermission() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SrlProblem::clear_accesspermission() {
  if (accesspermission_ != NULL) accesspermission_->::protobuf::srl::school::SrlPermission::Clear();
  clear_has_accesspermission();
}
inline const ::protobuf::srl::school::SrlPermission& SrlProblem::accesspermission() const {
  return accesspermission_ != NULL ? *accesspermission_ : *default_instance_->accesspermission_;
}
inline ::protobuf::srl::school::SrlPermission* SrlProblem::mutable_accesspermission() {
  set_has_accesspermission();
  if (accesspermission_ == NULL) accesspermission_ = new ::protobuf::srl::school::SrlPermission;
  return accesspermission_;
}
inline ::protobuf::srl::school::SrlPermission* SrlProblem::release_accesspermission() {
  clear_has_accesspermission();
  ::protobuf::srl::school::SrlPermission* temp = accesspermission_;
  accesspermission_ = NULL;
  return temp;
}
inline void SrlProblem::set_allocated_accesspermission(::protobuf::srl::school::SrlPermission* accesspermission) {
  delete accesspermission_;
  accesspermission_ = accesspermission;
  if (accesspermission) {
    set_has_accesspermission();
  } else {
    clear_has_accesspermission();
  }
}

// optional int32 problemNumber = 12;
inline bool SrlProblem::has_problemnumber() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SrlProblem::set_has_problemnumber() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SrlProblem::clear_has_problemnumber() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SrlProblem::clear_problemnumber() {
  problemnumber_ = 0;
  clear_has_problemnumber();
}
inline ::google::protobuf::int32 SrlProblem::problemnumber() const {
  return problemnumber_;
}
inline void SrlProblem::set_problemnumber(::google::protobuf::int32 value) {
  set_has_problemnumber();
  problemnumber_ = value;
}

// -------------------------------------------------------------------

// SrlBankProblem

// required string id = 1;
inline bool SrlBankProblem::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SrlBankProblem::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SrlBankProblem::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SrlBankProblem::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& SrlBankProblem::id() const {
  return *id_;
}
inline void SrlBankProblem::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void SrlBankProblem::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void SrlBankProblem::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlBankProblem::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* SrlBankProblem::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlBankProblem::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string questionText = 2;
inline bool SrlBankProblem::has_questiontext() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SrlBankProblem::set_has_questiontext() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SrlBankProblem::clear_has_questiontext() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SrlBankProblem::clear_questiontext() {
  if (questiontext_ != &::google::protobuf::internal::kEmptyString) {
    questiontext_->clear();
  }
  clear_has_questiontext();
}
inline const ::std::string& SrlBankProblem::questiontext() const {
  return *questiontext_;
}
inline void SrlBankProblem::set_questiontext(const ::std::string& value) {
  set_has_questiontext();
  if (questiontext_ == &::google::protobuf::internal::kEmptyString) {
    questiontext_ = new ::std::string;
  }
  questiontext_->assign(value);
}
inline void SrlBankProblem::set_questiontext(const char* value) {
  set_has_questiontext();
  if (questiontext_ == &::google::protobuf::internal::kEmptyString) {
    questiontext_ = new ::std::string;
  }
  questiontext_->assign(value);
}
inline void SrlBankProblem::set_questiontext(const char* value, size_t size) {
  set_has_questiontext();
  if (questiontext_ == &::google::protobuf::internal::kEmptyString) {
    questiontext_ = new ::std::string;
  }
  questiontext_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlBankProblem::mutable_questiontext() {
  set_has_questiontext();
  if (questiontext_ == &::google::protobuf::internal::kEmptyString) {
    questiontext_ = new ::std::string;
  }
  return questiontext_;
}
inline ::std::string* SrlBankProblem::release_questiontext() {
  clear_has_questiontext();
  if (questiontext_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = questiontext_;
    questiontext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlBankProblem::set_allocated_questiontext(::std::string* questiontext) {
  if (questiontext_ != &::google::protobuf::internal::kEmptyString) {
    delete questiontext_;
  }
  if (questiontext) {
    set_has_questiontext();
    questiontext_ = questiontext;
  } else {
    clear_has_questiontext();
    questiontext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .protobuf.srl.school.SrlBankProblem.QuestionType questionType = 3 [default = SKETCH];
inline bool SrlBankProblem::has_questiontype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SrlBankProblem::set_has_questiontype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SrlBankProblem::clear_has_questiontype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SrlBankProblem::clear_questiontype() {
  questiontype_ = 1;
  clear_has_questiontype();
}
inline ::protobuf::srl::school::SrlBankProblem_QuestionType SrlBankProblem::questiontype() const {
  return static_cast< ::protobuf::srl::school::SrlBankProblem_QuestionType >(questiontype_);
}
inline void SrlBankProblem::set_questiontype(::protobuf::srl::school::SrlBankProblem_QuestionType value) {
  assert(::protobuf::srl::school::SrlBankProblem_QuestionType_IsValid(value));
  set_has_questiontype();
  questiontype_ = value;
}

// optional string image = 4;
inline bool SrlBankProblem::has_image() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SrlBankProblem::set_has_image() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SrlBankProblem::clear_has_image() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SrlBankProblem::clear_image() {
  if (image_ != &::google::protobuf::internal::kEmptyString) {
    image_->clear();
  }
  clear_has_image();
}
inline const ::std::string& SrlBankProblem::image() const {
  return *image_;
}
inline void SrlBankProblem::set_image(const ::std::string& value) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(value);
}
inline void SrlBankProblem::set_image(const char* value) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(value);
}
inline void SrlBankProblem::set_image(const char* value, size_t size) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlBankProblem::mutable_image() {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  return image_;
}
inline ::std::string* SrlBankProblem::release_image() {
  clear_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = image_;
    image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlBankProblem::set_allocated_image(::std::string* image) {
  if (image_ != &::google::protobuf::internal::kEmptyString) {
    delete image_;
  }
  if (image) {
    set_has_image();
    image_ = image;
  } else {
    clear_has_image();
    image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string solutionId = 5;
inline bool SrlBankProblem::has_solutionid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SrlBankProblem::set_has_solutionid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SrlBankProblem::clear_has_solutionid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SrlBankProblem::clear_solutionid() {
  if (solutionid_ != &::google::protobuf::internal::kEmptyString) {
    solutionid_->clear();
  }
  clear_has_solutionid();
}
inline const ::std::string& SrlBankProblem::solutionid() const {
  return *solutionid_;
}
inline void SrlBankProblem::set_solutionid(const ::std::string& value) {
  set_has_solutionid();
  if (solutionid_ == &::google::protobuf::internal::kEmptyString) {
    solutionid_ = new ::std::string;
  }
  solutionid_->assign(value);
}
inline void SrlBankProblem::set_solutionid(const char* value) {
  set_has_solutionid();
  if (solutionid_ == &::google::protobuf::internal::kEmptyString) {
    solutionid_ = new ::std::string;
  }
  solutionid_->assign(value);
}
inline void SrlBankProblem::set_solutionid(const char* value, size_t size) {
  set_has_solutionid();
  if (solutionid_ == &::google::protobuf::internal::kEmptyString) {
    solutionid_ = new ::std::string;
  }
  solutionid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlBankProblem::mutable_solutionid() {
  set_has_solutionid();
  if (solutionid_ == &::google::protobuf::internal::kEmptyString) {
    solutionid_ = new ::std::string;
  }
  return solutionid_;
}
inline ::std::string* SrlBankProblem::release_solutionid() {
  clear_has_solutionid();
  if (solutionid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = solutionid_;
    solutionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlBankProblem::set_allocated_solutionid(::std::string* solutionid) {
  if (solutionid_ != &::google::protobuf::internal::kEmptyString) {
    delete solutionid_;
  }
  if (solutionid) {
    set_has_solutionid();
    solutionid_ = solutionid;
  } else {
    clear_has_solutionid();
    solutionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string courseTopic = 6;
inline bool SrlBankProblem::has_coursetopic() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SrlBankProblem::set_has_coursetopic() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SrlBankProblem::clear_has_coursetopic() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SrlBankProblem::clear_coursetopic() {
  if (coursetopic_ != &::google::protobuf::internal::kEmptyString) {
    coursetopic_->clear();
  }
  clear_has_coursetopic();
}
inline const ::std::string& SrlBankProblem::coursetopic() const {
  return *coursetopic_;
}
inline void SrlBankProblem::set_coursetopic(const ::std::string& value) {
  set_has_coursetopic();
  if (coursetopic_ == &::google::protobuf::internal::kEmptyString) {
    coursetopic_ = new ::std::string;
  }
  coursetopic_->assign(value);
}
inline void SrlBankProblem::set_coursetopic(const char* value) {
  set_has_coursetopic();
  if (coursetopic_ == &::google::protobuf::internal::kEmptyString) {
    coursetopic_ = new ::std::string;
  }
  coursetopic_->assign(value);
}
inline void SrlBankProblem::set_coursetopic(const char* value, size_t size) {
  set_has_coursetopic();
  if (coursetopic_ == &::google::protobuf::internal::kEmptyString) {
    coursetopic_ = new ::std::string;
  }
  coursetopic_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlBankProblem::mutable_coursetopic() {
  set_has_coursetopic();
  if (coursetopic_ == &::google::protobuf::internal::kEmptyString) {
    coursetopic_ = new ::std::string;
  }
  return coursetopic_;
}
inline ::std::string* SrlBankProblem::release_coursetopic() {
  clear_has_coursetopic();
  if (coursetopic_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = coursetopic_;
    coursetopic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlBankProblem::set_allocated_coursetopic(::std::string* coursetopic) {
  if (coursetopic_ != &::google::protobuf::internal::kEmptyString) {
    delete coursetopic_;
  }
  if (coursetopic) {
    set_has_coursetopic();
    coursetopic_ = coursetopic;
  } else {
    clear_has_coursetopic();
    coursetopic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string subTopic = 7;
inline bool SrlBankProblem::has_subtopic() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SrlBankProblem::set_has_subtopic() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SrlBankProblem::clear_has_subtopic() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SrlBankProblem::clear_subtopic() {
  if (subtopic_ != &::google::protobuf::internal::kEmptyString) {
    subtopic_->clear();
  }
  clear_has_subtopic();
}
inline const ::std::string& SrlBankProblem::subtopic() const {
  return *subtopic_;
}
inline void SrlBankProblem::set_subtopic(const ::std::string& value) {
  set_has_subtopic();
  if (subtopic_ == &::google::protobuf::internal::kEmptyString) {
    subtopic_ = new ::std::string;
  }
  subtopic_->assign(value);
}
inline void SrlBankProblem::set_subtopic(const char* value) {
  set_has_subtopic();
  if (subtopic_ == &::google::protobuf::internal::kEmptyString) {
    subtopic_ = new ::std::string;
  }
  subtopic_->assign(value);
}
inline void SrlBankProblem::set_subtopic(const char* value, size_t size) {
  set_has_subtopic();
  if (subtopic_ == &::google::protobuf::internal::kEmptyString) {
    subtopic_ = new ::std::string;
  }
  subtopic_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlBankProblem::mutable_subtopic() {
  set_has_subtopic();
  if (subtopic_ == &::google::protobuf::internal::kEmptyString) {
    subtopic_ = new ::std::string;
  }
  return subtopic_;
}
inline ::std::string* SrlBankProblem::release_subtopic() {
  clear_has_subtopic();
  if (subtopic_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subtopic_;
    subtopic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlBankProblem::set_allocated_subtopic(::std::string* subtopic) {
  if (subtopic_ != &::google::protobuf::internal::kEmptyString) {
    delete subtopic_;
  }
  if (subtopic) {
    set_has_subtopic();
    subtopic_ = subtopic;
  } else {
    clear_has_subtopic();
    subtopic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string source = 8;
inline bool SrlBankProblem::has_source() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SrlBankProblem::set_has_source() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SrlBankProblem::clear_has_source() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SrlBankProblem::clear_source() {
  if (source_ != &::google::protobuf::internal::kEmptyString) {
    source_->clear();
  }
  clear_has_source();
}
inline const ::std::string& SrlBankProblem::source() const {
  return *source_;
}
inline void SrlBankProblem::set_source(const ::std::string& value) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    source_ = new ::std::string;
  }
  source_->assign(value);
}
inline void SrlBankProblem::set_source(const char* value) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    source_ = new ::std::string;
  }
  source_->assign(value);
}
inline void SrlBankProblem::set_source(const char* value, size_t size) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    source_ = new ::std::string;
  }
  source_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlBankProblem::mutable_source() {
  set_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    source_ = new ::std::string;
  }
  return source_;
}
inline ::std::string* SrlBankProblem::release_source() {
  clear_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = source_;
    source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlBankProblem::set_allocated_source(::std::string* source) {
  if (source_ != &::google::protobuf::internal::kEmptyString) {
    delete source_;
  }
  if (source) {
    set_has_source();
    source_ = source;
  } else {
    clear_has_source();
    source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string otherKeywords = 9;
inline int SrlBankProblem::otherkeywords_size() const {
  return otherkeywords_.size();
}
inline void SrlBankProblem::clear_otherkeywords() {
  otherkeywords_.Clear();
}
inline const ::std::string& SrlBankProblem::otherkeywords(int index) const {
  return otherkeywords_.Get(index);
}
inline ::std::string* SrlBankProblem::mutable_otherkeywords(int index) {
  return otherkeywords_.Mutable(index);
}
inline void SrlBankProblem::set_otherkeywords(int index, const ::std::string& value) {
  otherkeywords_.Mutable(index)->assign(value);
}
inline void SrlBankProblem::set_otherkeywords(int index, const char* value) {
  otherkeywords_.Mutable(index)->assign(value);
}
inline void SrlBankProblem::set_otherkeywords(int index, const char* value, size_t size) {
  otherkeywords_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlBankProblem::add_otherkeywords() {
  return otherkeywords_.Add();
}
inline void SrlBankProblem::add_otherkeywords(const ::std::string& value) {
  otherkeywords_.Add()->assign(value);
}
inline void SrlBankProblem::add_otherkeywords(const char* value) {
  otherkeywords_.Add()->assign(value);
}
inline void SrlBankProblem::add_otherkeywords(const char* value, size_t size) {
  otherkeywords_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SrlBankProblem::otherkeywords() const {
  return otherkeywords_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SrlBankProblem::mutable_otherkeywords() {
  return &otherkeywords_;
}

// optional .protobuf.srl.school.SrlPermission accessPermission = 10;
inline bool SrlBankProblem::has_accesspermission() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SrlBankProblem::set_has_accesspermission() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SrlBankProblem::clear_has_accesspermission() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SrlBankProblem::clear_accesspermission() {
  if (accesspermission_ != NULL) accesspermission_->::protobuf::srl::school::SrlPermission::Clear();
  clear_has_accesspermission();
}
inline const ::protobuf::srl::school::SrlPermission& SrlBankProblem::accesspermission() const {
  return accesspermission_ != NULL ? *accesspermission_ : *default_instance_->accesspermission_;
}
inline ::protobuf::srl::school::SrlPermission* SrlBankProblem::mutable_accesspermission() {
  set_has_accesspermission();
  if (accesspermission_ == NULL) accesspermission_ = new ::protobuf::srl::school::SrlPermission;
  return accesspermission_;
}
inline ::protobuf::srl::school::SrlPermission* SrlBankProblem::release_accesspermission() {
  clear_has_accesspermission();
  ::protobuf::srl::school::SrlPermission* temp = accesspermission_;
  accesspermission_ = NULL;
  return temp;
}
inline void SrlBankProblem::set_allocated_accesspermission(::protobuf::srl::school::SrlPermission* accesspermission) {
  delete accesspermission_;
  accesspermission_ = accesspermission;
  if (accesspermission) {
    set_has_accesspermission();
  } else {
    clear_has_accesspermission();
  }
}

// -------------------------------------------------------------------

// SrlGrade

// required string id = 1;
inline bool SrlGrade::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SrlGrade::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SrlGrade::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SrlGrade::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& SrlGrade::id() const {
  return *id_;
}
inline void SrlGrade::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void SrlGrade::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void SrlGrade::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlGrade::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* SrlGrade::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlGrade::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string problemId = 2;
inline bool SrlGrade::has_problemid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SrlGrade::set_has_problemid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SrlGrade::clear_has_problemid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SrlGrade::clear_problemid() {
  if (problemid_ != &::google::protobuf::internal::kEmptyString) {
    problemid_->clear();
  }
  clear_has_problemid();
}
inline const ::std::string& SrlGrade::problemid() const {
  return *problemid_;
}
inline void SrlGrade::set_problemid(const ::std::string& value) {
  set_has_problemid();
  if (problemid_ == &::google::protobuf::internal::kEmptyString) {
    problemid_ = new ::std::string;
  }
  problemid_->assign(value);
}
inline void SrlGrade::set_problemid(const char* value) {
  set_has_problemid();
  if (problemid_ == &::google::protobuf::internal::kEmptyString) {
    problemid_ = new ::std::string;
  }
  problemid_->assign(value);
}
inline void SrlGrade::set_problemid(const char* value, size_t size) {
  set_has_problemid();
  if (problemid_ == &::google::protobuf::internal::kEmptyString) {
    problemid_ = new ::std::string;
  }
  problemid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlGrade::mutable_problemid() {
  set_has_problemid();
  if (problemid_ == &::google::protobuf::internal::kEmptyString) {
    problemid_ = new ::std::string;
  }
  return problemid_;
}
inline ::std::string* SrlGrade::release_problemid() {
  clear_has_problemid();
  if (problemid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = problemid_;
    problemid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlGrade::set_allocated_problemid(::std::string* problemid) {
  if (problemid_ != &::google::protobuf::internal::kEmptyString) {
    delete problemid_;
  }
  if (problemid) {
    set_has_problemid();
    problemid_ = problemid;
  } else {
    clear_has_problemid();
    problemid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required float grade = 3;
inline bool SrlGrade::has_grade() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SrlGrade::set_has_grade() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SrlGrade::clear_has_grade() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SrlGrade::clear_grade() {
  grade_ = 0;
  clear_has_grade();
}
inline float SrlGrade::grade() const {
  return grade_;
}
inline void SrlGrade::set_grade(float value) {
  set_has_grade();
  grade_ = value;
}

// optional string comment = 4;
inline bool SrlGrade::has_comment() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SrlGrade::set_has_comment() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SrlGrade::clear_has_comment() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SrlGrade::clear_comment() {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    comment_->clear();
  }
  clear_has_comment();
}
inline const ::std::string& SrlGrade::comment() const {
  return *comment_;
}
inline void SrlGrade::set_comment(const ::std::string& value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void SrlGrade::set_comment(const char* value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void SrlGrade::set_comment(const char* value, size_t size) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlGrade::mutable_comment() {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  return comment_;
}
inline ::std::string* SrlGrade::release_comment() {
  clear_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = comment_;
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlGrade::set_allocated_comment(::std::string* comment) {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    delete comment_;
  }
  if (comment) {
    set_has_comment();
    comment_ = comment;
  } else {
    clear_has_comment();
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// DateTime

// optional int32 year = 1;
inline bool DateTime::has_year() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DateTime::set_has_year() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DateTime::clear_has_year() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DateTime::clear_year() {
  year_ = 0;
  clear_has_year();
}
inline ::google::protobuf::int32 DateTime::year() const {
  return year_;
}
inline void DateTime::set_year(::google::protobuf::int32 value) {
  set_has_year();
  year_ = value;
}

// optional int32 month = 2;
inline bool DateTime::has_month() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DateTime::set_has_month() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DateTime::clear_has_month() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DateTime::clear_month() {
  month_ = 0;
  clear_has_month();
}
inline ::google::protobuf::int32 DateTime::month() const {
  return month_;
}
inline void DateTime::set_month(::google::protobuf::int32 value) {
  set_has_month();
  month_ = value;
}

// optional int32 day = 3;
inline bool DateTime::has_day() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DateTime::set_has_day() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DateTime::clear_has_day() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DateTime::clear_day() {
  day_ = 0;
  clear_has_day();
}
inline ::google::protobuf::int32 DateTime::day() const {
  return day_;
}
inline void DateTime::set_day(::google::protobuf::int32 value) {
  set_has_day();
  day_ = value;
}

// optional int32 hour = 4;
inline bool DateTime::has_hour() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DateTime::set_has_hour() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DateTime::clear_has_hour() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DateTime::clear_hour() {
  hour_ = 0;
  clear_has_hour();
}
inline ::google::protobuf::int32 DateTime::hour() const {
  return hour_;
}
inline void DateTime::set_hour(::google::protobuf::int32 value) {
  set_has_hour();
  hour_ = value;
}

// optional int32 minute = 5;
inline bool DateTime::has_minute() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DateTime::set_has_minute() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DateTime::clear_has_minute() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DateTime::clear_minute() {
  minute_ = 0;
  clear_has_minute();
}
inline ::google::protobuf::int32 DateTime::minute() const {
  return minute_;
}
inline void DateTime::set_minute(::google::protobuf::int32 value) {
  set_has_minute();
  minute_ = value;
}

// optional int32 second = 6;
inline bool DateTime::has_second() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DateTime::set_has_second() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DateTime::clear_has_second() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DateTime::clear_second() {
  second_ = 0;
  clear_has_second();
}
inline ::google::protobuf::int32 DateTime::second() const {
  return second_;
}
inline void DateTime::set_second(::google::protobuf::int32 value) {
  set_has_second();
  second_ = value;
}

// optional uint64 millisecond = 7;
inline bool DateTime::has_millisecond() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DateTime::set_has_millisecond() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DateTime::clear_has_millisecond() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DateTime::clear_millisecond() {
  millisecond_ = GOOGLE_ULONGLONG(0);
  clear_has_millisecond();
}
inline ::google::protobuf::uint64 DateTime::millisecond() const {
  return millisecond_;
}
inline void DateTime::set_millisecond(::google::protobuf::uint64 value) {
  set_has_millisecond();
  millisecond_ = value;
}

// -------------------------------------------------------------------

// DomainInformation

// optional string stuff = 1;
inline bool DomainInformation::has_stuff() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DomainInformation::set_has_stuff() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DomainInformation::clear_has_stuff() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DomainInformation::clear_stuff() {
  if (stuff_ != &::google::protobuf::internal::kEmptyString) {
    stuff_->clear();
  }
  clear_has_stuff();
}
inline const ::std::string& DomainInformation::stuff() const {
  return *stuff_;
}
inline void DomainInformation::set_stuff(const ::std::string& value) {
  set_has_stuff();
  if (stuff_ == &::google::protobuf::internal::kEmptyString) {
    stuff_ = new ::std::string;
  }
  stuff_->assign(value);
}
inline void DomainInformation::set_stuff(const char* value) {
  set_has_stuff();
  if (stuff_ == &::google::protobuf::internal::kEmptyString) {
    stuff_ = new ::std::string;
  }
  stuff_->assign(value);
}
inline void DomainInformation::set_stuff(const char* value, size_t size) {
  set_has_stuff();
  if (stuff_ == &::google::protobuf::internal::kEmptyString) {
    stuff_ = new ::std::string;
  }
  stuff_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DomainInformation::mutable_stuff() {
  set_has_stuff();
  if (stuff_ == &::google::protobuf::internal::kEmptyString) {
    stuff_ = new ::std::string;
  }
  return stuff_;
}
inline ::std::string* DomainInformation::release_stuff() {
  clear_has_stuff();
  if (stuff_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stuff_;
    stuff_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DomainInformation::set_allocated_stuff(::std::string* stuff) {
  if (stuff_ != &::google::protobuf::internal::kEmptyString) {
    delete stuff_;
  }
  if (stuff) {
    set_has_stuff();
    stuff_ = stuff;
  } else {
    clear_has_stuff();
    stuff_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// State

// optional bool published = 1;
inline bool State::has_published() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void State::set_has_published() {
  _has_bits_[0] |= 0x00000001u;
}
inline void State::clear_has_published() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void State::clear_published() {
  published_ = false;
  clear_has_published();
}
inline bool State::published() const {
  return published_;
}
inline void State::set_published(bool value) {
  set_has_published();
  published_ = value;
}

// optional bool accessible = 2;
inline bool State::has_accessible() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void State::set_has_accessible() {
  _has_bits_[0] |= 0x00000002u;
}
inline void State::clear_has_accessible() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void State::clear_accessible() {
  accessible_ = false;
  clear_has_accessible();
}
inline bool State::accessible() const {
  return accessible_;
}
inline void State::set_accessible(bool value) {
  set_has_accessible();
  accessible_ = value;
}

// optional bool pastDue = 3;
inline bool State::has_pastdue() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void State::set_has_pastdue() {
  _has_bits_[0] |= 0x00000004u;
}
inline void State::clear_has_pastdue() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void State::clear_pastdue() {
  pastdue_ = false;
  clear_has_pastdue();
}
inline bool State::pastdue() const {
  return pastdue_;
}
inline void State::set_pastdue(bool value) {
  set_has_pastdue();
  pastdue_ = value;
}

// optional bool started = 4;
inline bool State::has_started() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void State::set_has_started() {
  _has_bits_[0] |= 0x00000008u;
}
inline void State::clear_has_started() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void State::clear_started() {
  started_ = false;
  clear_has_started();
}
inline bool State::started() const {
  return started_;
}
inline void State::set_started(bool value) {
  set_has_started();
  started_ = value;
}

// optional bool completed = 5;
inline bool State::has_completed() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void State::set_has_completed() {
  _has_bits_[0] |= 0x00000010u;
}
inline void State::clear_has_completed() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void State::clear_completed() {
  completed_ = false;
  clear_has_completed();
}
inline bool State::completed() const {
  return completed_;
}
inline void State::set_completed(bool value) {
  set_has_completed();
  completed_ = value;
}

// optional bool graded = 6;
inline bool State::has_graded() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void State::set_has_graded() {
  _has_bits_[0] |= 0x00000020u;
}
inline void State::clear_has_graded() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void State::clear_graded() {
  graded_ = false;
  clear_has_graded();
}
inline bool State::graded() const {
  return graded_;
}
inline void State::set_graded(bool value) {
  set_has_graded();
  graded_ = value;
}

// -------------------------------------------------------------------

// SrlUser

// required string username = 1;
inline bool SrlUser::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SrlUser::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SrlUser::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SrlUser::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& SrlUser::username() const {
  return *username_;
}
inline void SrlUser::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void SrlUser::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void SrlUser::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlUser::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* SrlUser::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlUser::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string email = 2;
inline bool SrlUser::has_email() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SrlUser::set_has_email() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SrlUser::clear_has_email() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SrlUser::clear_email() {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& SrlUser::email() const {
  return *email_;
}
inline void SrlUser::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void SrlUser::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void SrlUser::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlUser::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  return email_;
}
inline ::std::string* SrlUser::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlUser::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string courseList = 3;
inline int SrlUser::courselist_size() const {
  return courselist_.size();
}
inline void SrlUser::clear_courselist() {
  courselist_.Clear();
}
inline const ::std::string& SrlUser::courselist(int index) const {
  return courselist_.Get(index);
}
inline ::std::string* SrlUser::mutable_courselist(int index) {
  return courselist_.Mutable(index);
}
inline void SrlUser::set_courselist(int index, const ::std::string& value) {
  courselist_.Mutable(index)->assign(value);
}
inline void SrlUser::set_courselist(int index, const char* value) {
  courselist_.Mutable(index)->assign(value);
}
inline void SrlUser::set_courselist(int index, const char* value, size_t size) {
  courselist_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlUser::add_courselist() {
  return courselist_.Add();
}
inline void SrlUser::add_courselist(const ::std::string& value) {
  courselist_.Add()->assign(value);
}
inline void SrlUser::add_courselist(const char* value) {
  courselist_.Add()->assign(value);
}
inline void SrlUser::add_courselist(const char* value, size_t size) {
  courselist_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SrlUser::courselist() const {
  return courselist_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SrlUser::mutable_courselist() {
  return &courselist_;
}

// optional string schoolIdentity = 4;
inline bool SrlUser::has_schoolidentity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SrlUser::set_has_schoolidentity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SrlUser::clear_has_schoolidentity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SrlUser::clear_schoolidentity() {
  if (schoolidentity_ != &::google::protobuf::internal::kEmptyString) {
    schoolidentity_->clear();
  }
  clear_has_schoolidentity();
}
inline const ::std::string& SrlUser::schoolidentity() const {
  return *schoolidentity_;
}
inline void SrlUser::set_schoolidentity(const ::std::string& value) {
  set_has_schoolidentity();
  if (schoolidentity_ == &::google::protobuf::internal::kEmptyString) {
    schoolidentity_ = new ::std::string;
  }
  schoolidentity_->assign(value);
}
inline void SrlUser::set_schoolidentity(const char* value) {
  set_has_schoolidentity();
  if (schoolidentity_ == &::google::protobuf::internal::kEmptyString) {
    schoolidentity_ = new ::std::string;
  }
  schoolidentity_->assign(value);
}
inline void SrlUser::set_schoolidentity(const char* value, size_t size) {
  set_has_schoolidentity();
  if (schoolidentity_ == &::google::protobuf::internal::kEmptyString) {
    schoolidentity_ = new ::std::string;
  }
  schoolidentity_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlUser::mutable_schoolidentity() {
  set_has_schoolidentity();
  if (schoolidentity_ == &::google::protobuf::internal::kEmptyString) {
    schoolidentity_ = new ::std::string;
  }
  return schoolidentity_;
}
inline ::std::string* SrlUser::release_schoolidentity() {
  clear_has_schoolidentity();
  if (schoolidentity_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = schoolidentity_;
    schoolidentity_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlUser::set_allocated_schoolidentity(::std::string* schoolidentity) {
  if (schoolidentity_ != &::google::protobuf::internal::kEmptyString) {
    delete schoolidentity_;
  }
  if (schoolidentity) {
    set_has_schoolidentity();
    schoolidentity_ = schoolidentity;
  } else {
    clear_has_schoolidentity();
    schoolidentity_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string firstName = 5;
inline bool SrlUser::has_firstname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SrlUser::set_has_firstname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SrlUser::clear_has_firstname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SrlUser::clear_firstname() {
  if (firstname_ != &::google::protobuf::internal::kEmptyString) {
    firstname_->clear();
  }
  clear_has_firstname();
}
inline const ::std::string& SrlUser::firstname() const {
  return *firstname_;
}
inline void SrlUser::set_firstname(const ::std::string& value) {
  set_has_firstname();
  if (firstname_ == &::google::protobuf::internal::kEmptyString) {
    firstname_ = new ::std::string;
  }
  firstname_->assign(value);
}
inline void SrlUser::set_firstname(const char* value) {
  set_has_firstname();
  if (firstname_ == &::google::protobuf::internal::kEmptyString) {
    firstname_ = new ::std::string;
  }
  firstname_->assign(value);
}
inline void SrlUser::set_firstname(const char* value, size_t size) {
  set_has_firstname();
  if (firstname_ == &::google::protobuf::internal::kEmptyString) {
    firstname_ = new ::std::string;
  }
  firstname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlUser::mutable_firstname() {
  set_has_firstname();
  if (firstname_ == &::google::protobuf::internal::kEmptyString) {
    firstname_ = new ::std::string;
  }
  return firstname_;
}
inline ::std::string* SrlUser::release_firstname() {
  clear_has_firstname();
  if (firstname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = firstname_;
    firstname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlUser::set_allocated_firstname(::std::string* firstname) {
  if (firstname_ != &::google::protobuf::internal::kEmptyString) {
    delete firstname_;
  }
  if (firstname) {
    set_has_firstname();
    firstname_ = firstname;
  } else {
    clear_has_firstname();
    firstname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string lastName = 6;
inline bool SrlUser::has_lastname() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SrlUser::set_has_lastname() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SrlUser::clear_has_lastname() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SrlUser::clear_lastname() {
  if (lastname_ != &::google::protobuf::internal::kEmptyString) {
    lastname_->clear();
  }
  clear_has_lastname();
}
inline const ::std::string& SrlUser::lastname() const {
  return *lastname_;
}
inline void SrlUser::set_lastname(const ::std::string& value) {
  set_has_lastname();
  if (lastname_ == &::google::protobuf::internal::kEmptyString) {
    lastname_ = new ::std::string;
  }
  lastname_->assign(value);
}
inline void SrlUser::set_lastname(const char* value) {
  set_has_lastname();
  if (lastname_ == &::google::protobuf::internal::kEmptyString) {
    lastname_ = new ::std::string;
  }
  lastname_->assign(value);
}
inline void SrlUser::set_lastname(const char* value, size_t size) {
  set_has_lastname();
  if (lastname_ == &::google::protobuf::internal::kEmptyString) {
    lastname_ = new ::std::string;
  }
  lastname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlUser::mutable_lastname() {
  set_has_lastname();
  if (lastname_ == &::google::protobuf::internal::kEmptyString) {
    lastname_ = new ::std::string;
  }
  return lastname_;
}
inline ::std::string* SrlUser::release_lastname() {
  clear_has_lastname();
  if (lastname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = lastname_;
    lastname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlUser::set_allocated_lastname(::std::string* lastname) {
  if (lastname_ != &::google::protobuf::internal::kEmptyString) {
    delete lastname_;
  }
  if (lastname) {
    set_has_lastname();
    lastname_ = lastname;
  } else {
    clear_has_lastname();
    lastname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 7;
inline bool SrlUser::has_password() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SrlUser::set_has_password() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SrlUser::clear_has_password() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SrlUser::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& SrlUser::password() const {
  return *password_;
}
inline void SrlUser::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void SrlUser::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void SrlUser::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlUser::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* SrlUser::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlUser::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SrlGroup

// repeated string userId = 1;
inline int SrlGroup::userid_size() const {
  return userid_.size();
}
inline void SrlGroup::clear_userid() {
  userid_.Clear();
}
inline const ::std::string& SrlGroup::userid(int index) const {
  return userid_.Get(index);
}
inline ::std::string* SrlGroup::mutable_userid(int index) {
  return userid_.Mutable(index);
}
inline void SrlGroup::set_userid(int index, const ::std::string& value) {
  userid_.Mutable(index)->assign(value);
}
inline void SrlGroup::set_userid(int index, const char* value) {
  userid_.Mutable(index)->assign(value);
}
inline void SrlGroup::set_userid(int index, const char* value, size_t size) {
  userid_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlGroup::add_userid() {
  return userid_.Add();
}
inline void SrlGroup::add_userid(const ::std::string& value) {
  userid_.Add()->assign(value);
}
inline void SrlGroup::add_userid(const char* value) {
  userid_.Add()->assign(value);
}
inline void SrlGroup::add_userid(const char* value, size_t size) {
  userid_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SrlGroup::userid() const {
  return userid_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SrlGroup::mutable_userid() {
  return &userid_;
}

// required string groupId = 2;
inline bool SrlGroup::has_groupid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SrlGroup::set_has_groupid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SrlGroup::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SrlGroup::clear_groupid() {
  if (groupid_ != &::google::protobuf::internal::kEmptyString) {
    groupid_->clear();
  }
  clear_has_groupid();
}
inline const ::std::string& SrlGroup::groupid() const {
  return *groupid_;
}
inline void SrlGroup::set_groupid(const ::std::string& value) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(value);
}
inline void SrlGroup::set_groupid(const char* value) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(value);
}
inline void SrlGroup::set_groupid(const char* value, size_t size) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlGroup::mutable_groupid() {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  return groupid_;
}
inline ::std::string* SrlGroup::release_groupid() {
  clear_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = groupid_;
    groupid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlGroup::set_allocated_groupid(::std::string* groupid) {
  if (groupid_ != &::google::protobuf::internal::kEmptyString) {
    delete groupid_;
  }
  if (groupid) {
    set_has_groupid();
    groupid_ = groupid;
  } else {
    clear_has_groupid();
    groupid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string groupName = 3;
inline bool SrlGroup::has_groupname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SrlGroup::set_has_groupname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SrlGroup::clear_has_groupname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SrlGroup::clear_groupname() {
  if (groupname_ != &::google::protobuf::internal::kEmptyString) {
    groupname_->clear();
  }
  clear_has_groupname();
}
inline const ::std::string& SrlGroup::groupname() const {
  return *groupname_;
}
inline void SrlGroup::set_groupname(const ::std::string& value) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(value);
}
inline void SrlGroup::set_groupname(const char* value) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(value);
}
inline void SrlGroup::set_groupname(const char* value, size_t size) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlGroup::mutable_groupname() {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  return groupname_;
}
inline ::std::string* SrlGroup::release_groupname() {
  clear_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = groupname_;
    groupname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SrlGroup::set_allocated_groupname(::std::string* groupname) {
  if (groupname_ != &::google::protobuf::internal::kEmptyString) {
    delete groupname_;
  }
  if (groupname) {
    set_has_groupname();
    groupname_ = groupname;
  } else {
    clear_has_groupname();
    groupname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string admin = 4;
inline int SrlGroup::admin_size() const {
  return admin_.size();
}
inline void SrlGroup::clear_admin() {
  admin_.Clear();
}
inline const ::std::string& SrlGroup::admin(int index) const {
  return admin_.Get(index);
}
inline ::std::string* SrlGroup::mutable_admin(int index) {
  return admin_.Mutable(index);
}
inline void SrlGroup::set_admin(int index, const ::std::string& value) {
  admin_.Mutable(index)->assign(value);
}
inline void SrlGroup::set_admin(int index, const char* value) {
  admin_.Mutable(index)->assign(value);
}
inline void SrlGroup::set_admin(int index, const char* value, size_t size) {
  admin_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlGroup::add_admin() {
  return admin_.Add();
}
inline void SrlGroup::add_admin(const ::std::string& value) {
  admin_.Add()->assign(value);
}
inline void SrlGroup::add_admin(const char* value) {
  admin_.Add()->assign(value);
}
inline void SrlGroup::add_admin(const char* value, size_t size) {
  admin_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SrlGroup::admin() const {
  return admin_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SrlGroup::mutable_admin() {
  return &admin_;
}

// -------------------------------------------------------------------

// SrlPermission

// repeated string adminPermission = 1;
inline int SrlPermission::adminpermission_size() const {
  return adminpermission_.size();
}
inline void SrlPermission::clear_adminpermission() {
  adminpermission_.Clear();
}
inline const ::std::string& SrlPermission::adminpermission(int index) const {
  return adminpermission_.Get(index);
}
inline ::std::string* SrlPermission::mutable_adminpermission(int index) {
  return adminpermission_.Mutable(index);
}
inline void SrlPermission::set_adminpermission(int index, const ::std::string& value) {
  adminpermission_.Mutable(index)->assign(value);
}
inline void SrlPermission::set_adminpermission(int index, const char* value) {
  adminpermission_.Mutable(index)->assign(value);
}
inline void SrlPermission::set_adminpermission(int index, const char* value, size_t size) {
  adminpermission_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlPermission::add_adminpermission() {
  return adminpermission_.Add();
}
inline void SrlPermission::add_adminpermission(const ::std::string& value) {
  adminpermission_.Add()->assign(value);
}
inline void SrlPermission::add_adminpermission(const char* value) {
  adminpermission_.Add()->assign(value);
}
inline void SrlPermission::add_adminpermission(const char* value, size_t size) {
  adminpermission_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SrlPermission::adminpermission() const {
  return adminpermission_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SrlPermission::mutable_adminpermission() {
  return &adminpermission_;
}

// repeated string moderatorPermission = 2;
inline int SrlPermission::moderatorpermission_size() const {
  return moderatorpermission_.size();
}
inline void SrlPermission::clear_moderatorpermission() {
  moderatorpermission_.Clear();
}
inline const ::std::string& SrlPermission::moderatorpermission(int index) const {
  return moderatorpermission_.Get(index);
}
inline ::std::string* SrlPermission::mutable_moderatorpermission(int index) {
  return moderatorpermission_.Mutable(index);
}
inline void SrlPermission::set_moderatorpermission(int index, const ::std::string& value) {
  moderatorpermission_.Mutable(index)->assign(value);
}
inline void SrlPermission::set_moderatorpermission(int index, const char* value) {
  moderatorpermission_.Mutable(index)->assign(value);
}
inline void SrlPermission::set_moderatorpermission(int index, const char* value, size_t size) {
  moderatorpermission_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlPermission::add_moderatorpermission() {
  return moderatorpermission_.Add();
}
inline void SrlPermission::add_moderatorpermission(const ::std::string& value) {
  moderatorpermission_.Add()->assign(value);
}
inline void SrlPermission::add_moderatorpermission(const char* value) {
  moderatorpermission_.Add()->assign(value);
}
inline void SrlPermission::add_moderatorpermission(const char* value, size_t size) {
  moderatorpermission_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SrlPermission::moderatorpermission() const {
  return moderatorpermission_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SrlPermission::mutable_moderatorpermission() {
  return &moderatorpermission_;
}

// repeated string userPermission = 3;
inline int SrlPermission::userpermission_size() const {
  return userpermission_.size();
}
inline void SrlPermission::clear_userpermission() {
  userpermission_.Clear();
}
inline const ::std::string& SrlPermission::userpermission(int index) const {
  return userpermission_.Get(index);
}
inline ::std::string* SrlPermission::mutable_userpermission(int index) {
  return userpermission_.Mutable(index);
}
inline void SrlPermission::set_userpermission(int index, const ::std::string& value) {
  userpermission_.Mutable(index)->assign(value);
}
inline void SrlPermission::set_userpermission(int index, const char* value) {
  userpermission_.Mutable(index)->assign(value);
}
inline void SrlPermission::set_userpermission(int index, const char* value, size_t size) {
  userpermission_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrlPermission::add_userpermission() {
  return userpermission_.Add();
}
inline void SrlPermission::add_userpermission(const ::std::string& value) {
  userpermission_.Add()->assign(value);
}
inline void SrlPermission::add_userpermission(const char* value) {
  userpermission_.Add()->assign(value);
}
inline void SrlPermission::add_userpermission(const char* value, size_t size) {
  userpermission_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SrlPermission::userpermission() const {
  return userpermission_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SrlPermission::mutable_userpermission() {
  return &userpermission_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace school
}  // namespace srl
}  // namespace protobuf

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protobuf::srl::school::SrlCourse_Accessibility>() {
  return ::protobuf::srl::school::SrlCourse_Accessibility_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protobuf::srl::school::SrlAssignment_LatePolicy_FunctionType>() {
  return ::protobuf::srl::school::SrlAssignment_LatePolicy_FunctionType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protobuf::srl::school::SrlAssignment_LatePolicy_TimeFrame>() {
  return ::protobuf::srl::school::SrlAssignment_LatePolicy_TimeFrame_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protobuf::srl::school::SrlAssignment_AssignmentType>() {
  return ::protobuf::srl::school::SrlAssignment_AssignmentType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protobuf::srl::school::SrlBankProblem_QuestionType>() {
  return ::protobuf::srl::school::SrlBankProblem_QuestionType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protobuf::srl::school::UserType>() {
  return ::protobuf::srl::school::UserType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_input_2fschool_2eproto__INCLUDED
